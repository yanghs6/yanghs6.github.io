---
title: 백준 14938번 서강그라운드
date: 2022-04-12 23:04:00 +/-0900
categories: [Problem Solve, boj]
tags: [문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra), 플로이드-워셜 알고리즘(floyd_warshall_algorithm)]

---
## 정보
### 문제 바로가기 [[클릭](https://www.acmicpc.net/problem/14938)]
### 난이도: Gold4
### 관련 개념: [#그래프이론](https://www.acmicpc.net/problemset?sort=ac_desc&algo=7) [#다익스트라](https://www.acmicpc.net/problemset?sort=ac_desc&algo=22) [#플로이드-워셜](https://www.acmicpc.net/problemset?sort=ac_desc&algo=31)

---
## 조건

시간 제한|메모리 제한
:---:|:---:
1 초|128 MB

---
## 문제
예은이는 요즘 가장 인기가 있는 게임 서강그라운드를 즐기고 있다. 서강그라운드는 여러 지역중 하나의 지역에 낙하산을 타고 낙하하여, 그 지역에 떨어져 있는 아이템들을 이용해 서바이벌을 하는 게임이다. 서강그라운드에서 1등을 하면 보상으로 치킨을 주는데, 예은이는 단 한번도 치킨을 먹을 수가 없었다. 자신이 치킨을 못 먹는 이유는 실력 때문이 아니라 아이템 운이 없어서라고 생각한 예은이는 낙하산에서 떨어질 때 각 지역에 아이템 들이 몇 개 있는지 알려주는 프로그램을 개발을 하였지만 어디로 낙하해야 자신의 수색 범위 내에서 가장 많은 아이템을 얻을 수 있는지 알 수 없었다.

각 지역은 일정한 길이 l (1 ≤ l ≤ 15)의 길로 다른 지역과 연결되어 있고 이 길은 양방향 통행이 가능하다. 예은이는 낙하한 지역을 중심으로 거리가 수색 범위 m (1 ≤ m ≤ 15) 이내의 모든 지역의 아이템을 습득 가능하다고 할 때, 예은이가 얻을 수 있는 아이템의 최대 개수를 알려주자.

![지역 그림](/assets/img/problem_solve/0059/0059_problem.png "지역 그림")

주어진 필드가 위의 그림과 같고, 예은이의 수색범위가 4라고 하자. ( 원 밖의 숫자는 지역 번호, 안의 숫자는 아이템 수, 선 위의 숫자는 거리를 의미한다) 예은이가 2번 지역에 떨어지게 되면 1번,2번(자기 지역), 3번, 5번 지역에 도달할 수 있다. (4번 지역의 경우 가는 거리가 3 + 5 = 8 > 4(수색범위) 이므로 4번 지역의 아이템을 얻을 수 없다.) 이렇게 되면 예은이는 23개의 아이템을 얻을 수 있고, 이는 위의 필드에서 예은이가 얻을 수 있는 아이템의 최대 개수이다.

---
## 입력
첫째 줄에는 지역의 개수 n (1 ≤ n ≤ 100)과 예은이의 수색범위 m (1 ≤ m ≤ 15), 길의 개수 r (1 ≤ r ≤ 100)이 주어진다.

둘째 줄에는 n개의 숫자가 차례대로  각 구역에 있는 아이템의 수 t (1 ≤ t ≤ 30)를 알려준다.

세 번째 줄부터 r+2번째 줄 까지 길 양 끝에 존재하는 지역의 번호 a, b, 그리고 길의 길이 l (1 ≤ l ≤ 15)가 주어진다.

---
## 출력
예은이가 얻을 수 있는 최대 아이템 개수를 출력한다.

---
## 예제 입출력 1
입력
```
5 5 4
5 7 8 2 3
1 4 5
5 2 4
3 2 3
1 2 3
```

출력
```
23
```

---
## 코드(파이썬)
```python
import heapq
import sys


n, m, r = map(int, sys.stdin.readline().split())
field = [0] + list(map(int, sys.stdin.readline().split()))
graph = {i:[] for i in range(1, n+1)}
result = -1

# 그래프 생성
for _ in range(r):
    s, e, w = map(int, sys.stdin.readline().split())
    graph[s].append((e, w))
    graph[e].append((s, w))
    
# 정점 별로 다익스트라
for start in range(1, n+1):
    visited = [False for _ in range(n + 1)]
    d = [0] + [16 for _ in range(n)]
    heap = [(0, start)]
    
    while heap:
        w, node = heapq.heappop(heap)
        
        if w > m:
            break
        elif not visited[node]:
            d[node] = w
            visited[node] = True
            
            for node2, w2 in graph[node]:
                heapq.heappush(heap, (w+w2, node2))
        
    result = max(result, sum([field[i] for i in range(1, n+1) if 0 <= d[i] <= m]))
    
print(result)

```

---
## 특이사항
- 풀이과정
  - 정점 별로 다익스트라 수행
  - 다른 정점까지의 최단경로가 수색범위보다 작은 값들의 아이템들을 result에 저장

---
## 참고문헌
\-
