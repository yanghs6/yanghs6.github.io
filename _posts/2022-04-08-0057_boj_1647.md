---
title: 백준 1647번 도시 분할 계획
date: 2022-04-08 16:50:00 +/-0900
categories: [Problem Solve, boj]
tags: [문제풀이(problem_solve), 백준(boj), 최소 신장 트리(minimum_spanning_tree)]
math: true

---
## 정보
### 문제 바로가기 [[클릭](https://www.acmicpc.net/problem/1647)]
### 난이도: Gold4
### 관련 개념: [#그래프이론](https://www.acmicpc.net/problemset?sort=ac_desc&algo=7) [#최소 스패닝 트리](https://www.acmicpc.net/problemset?sort=ac_desc&algo=49)

---
## 조건

시간 제한|메모리 제한
:---:|:---:
2 초|256 MB

---
## 문제
동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.

마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.

마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.

그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.

---
## 입력
첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2이상 100,000이하인 정수이고, M은 1이상 1,000,000이하인 정수이다. 그 다음 줄부터 M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻이다.

---
## 출력
첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력한다.

---
## 예제 입출력 1
입력
```
7 12
1 2 3
1 3 2
3 2 1
2 5 2
3 4 4
7 3 6
5 1 5
1 6 2
6 4 1
6 5 3
4 5 3
6 7 4
```

출력
```
8
```

---
## 코드(파이썬)
```python
import sys


def find(x):
    return x if p[x] == x else find(p[x])

n, m = map(int, sys.stdin.readline().split())
edges = list()
p = dict()
result = 0
cnt = 0

for _ in range(m):
    s, e, d = map(int, sys.stdin.readline().split())

    edges.append((d, s, e))
    p[s] = s
    p[e] = e
    
edges.sort(key=lambda e:-e[0])
    
while cnt < n-2:
    d, s, e = edges.pop()
    r1 = find(s)
    r2 = find(e)        
    
    if r1 != r2:
        cnt += 1
        result += d
        
        if r1 < r2:
            p[r2] = p[r1]
        else:
            p[r1] = p[r2]
            
print(result)

```

---
## 특이사항
- 최소 스패닝 트리(최소 신장 트리) 문제
- 여기서는 크루스칼 알고리즘을 사용
  - 모든 간선을 거리를 오름차순으로 정렬
  - 가장 거리가 작은 간선을 가져옴
  - 각 간선이 속한 트리가 다르다면 두 트리를 합침
  - 모든 정점을 합칠 때까지 반복
  - 트리의 표현은 배열을 활용했으며 Union, Find 메서드를 적용
- 프림 알고리즘을 사용했으나 시간 초과
  - 프림 알고리즘 시간복잡도: $O(n) = E log V $
  - 크루스칼 알고리즘 시간복잡도: $O(n) = E log E $ 
  - 이 문제는 정점의 개수에 비해 간선의 개수가 비교적 적으므로 크루스칼 알고리즘이 적합

---
## 참고문헌
- 문병로, *쉽게 배우는 알고리즘 :관계 중심의 사고법*, 문병로, 2018
