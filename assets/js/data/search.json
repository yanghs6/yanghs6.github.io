[
  
  {
    "title": "2022년 회고",
    "url": "/posts/9002_2022_retrospect/",
    "categories": "Life, retrospect",
    "tags": "문제풀이(problem_solve), 회고(retrospect)",
    "date": "2022-12-31 21:52:00 +0900",
    





    
    "snippet": "들어가기 앞서이번 2022년은 저에게 있어 참으로 뜻깊고 즐겁고 치열한 한 해로 남습니다.빠르게 회고해보자면 다음과 같아요!  국비교육 수강  1개월 간의 인턴  첫 취업!1. 국비교육 수강: 데이터에 대해 조금 더 배워보자문제풀이 회고 글에서 얼핏 확인하실 수 있겠지만 상반기 동안 국비교육을 수강하였습니다.당시에는 프로젝트형빅데이터분석서비스개발, 현...",
    "content": "들어가기 앞서이번 2022년은 저에게 있어 참으로 뜻깊고 즐겁고 치열한 한 해로 남습니다.빠르게 회고해보자면 다음과 같아요!  국비교육 수강  1개월 간의 인턴  첫 취업!1. 국비교육 수강: 데이터에 대해 조금 더 배워보자문제풀이 회고 글에서 얼핏 확인하실 수 있겠지만 상반기 동안 국비교육을 수강하였습니다.당시에는 프로젝트형빅데이터분석서비스개발, 현재는 \\[멀티잇\\]데이터 분석 서비스 개발자 취업캠프(융합PJT) 라는 교육이었습니다.약 5개월 동안 대면과 비대면을 번갈아가며 수강하였습니다.(결석 2회는 예비군 1회, 마지막날 퇴실을 놓쳐서 1회입니다)커리큘럼: 기초부터 차근차근  HTTP, CSS, JavaScript 등 웹 기초  Python 기초 및 Django 활용 서비스 개발 (1차 프로젝트)  R 기초와 분석 기법 및 시각화 (2차 프로젝트)  Python 활용한 분석 기법 및 시각화  사물인터넷‧클라우드‧빅데이터‧인공지능 4개 분야의 융합 프로젝트 (최종 프로젝트)장점: 데이터 분야의 시작점 + 타분야와의 협력 경험  비전공자여도 강의 수강 및 기술 습득에 큰 걸림돌이 없는 난이도          당시 강사님께서는 수강생들의 거의 모든 질문에 답변을 해주시려 노력하셨습니다.      또한 최종 프로젝트는 멘토링 시간이 주마다 존재하여 프로젝트 내용 외에도 각종 기술, 현업에서의 고려 사항, 취업 조언 등 빠른 피드백이 가능했습니다.        데이터 분야에 관심이 있다면 강의 수강을 통해 더 깊은 이해 가능          데이터 분야 안에서도 대략적으로 나뉘는 갈래를 확인할 수 있습니다.      막연하게 데이터 분야가 아니라, 데이터 분석, 데이터 엔지니어링, 데이터 사이언티스트 등 세부 분야에 대해 고민하게 됩니다.        프로젝트 3번의 협력 경험          최종 프로젝트는 IoT, Cloud, AI 등 명확하게 알지 못하는 분야와의 협업이 필수적입니다.      협업 전반에 걸쳐 끊임없이 의견을 교환하고, 대립이 발생하면 토론하며, 서로에게 부족한 부분은 채워나갔습니다.      당시 만난 분들과 여전히 연락을 하며 지내고 있습니다. 좋은 사람들과 만나는 일을 언제나 즐겁더라구요!      단점: 이미 길이 정해져 있다면, 혹은 여유가 없다면  방대한 분야 대비 깊지 않은 접근          저는 전공자였고, 데이터 분야 중 데이터 엔지니어링에 관심이 있는 상태로 강의를 수강하였습니다.      그 덕분에 커리큘럼에 있는 내용 중 상당 부분은 알고 있는 지식이었습니다.      데이터 엔지니어링과 관련된 기술을 얻기는 어려움이 있었습니다.        5개월의 강의 기간          개인에 따라서 다르겠지만 5개월의 강의 시간은 다소 길게 느껴질 수 있습니다.      의지가 확고하다면 스터디 등 다른 경로를 고려해봄직 합니다.      2. 1개월 간의 인턴: 데이터 시각화와 분석을 들여다보다위의 교육이 끝나자마자 데이터 시각화 전문기업인 뉴스젤리에서 인턴을 수행했습니다.지원하게 된 계기는 데이터 분야 중 엔지니어링 외의 경험을 원했습니다.약 1개월 동안 인턴을 수행하면서 토이 프로젝트를 수행하였습니다.대시보드 제작: 뉴스젤리의 DAISY 툴을 활용하여자전거 타기 좋은 시도가 어딜까?라는 주제로 수행하였습니다.자전거 관련 통계를 수집하고, 자전거 대여소나 자전거 수리점 등 정보를 KAKAO API에서 가져왔습니다.또한 자전거 관련 검색량을 가져오기 위해 네이버랩을 활용하여 데이터를 받고 이를 기반으로 검색량 추이를 계산하였습니다.비록 참신한 주제는 아니었지만 스스로 데이터 분석을 해본 좋은 경험이었습니다.3. 첫 취업!: 크라우드웍스에서의 5개월올해 8월부터는 크라우드웍스에서 일을 시작하게 되었습니다.제가 원하던 DE의 업무는 아니었지만, 5개월 동안 다른 부서와 협업을 통해 고객사의 니즈를 맞추는 것에 주력했습니다.파이썬에 익숙해지다파이썬을 주력 언어로 사용하다보니 익숙해지게 되었습니다.예를 들어 딕셔너리들로 이루어진 리스트를 하나로 합칠 때, 다음과 같은 코드를 작성할 수 있습니다.from functools import reducelist_of_dicts = [{\"1\":1234}, {\"a\":5}, {1:777}]print(reduce(lambda next, cur: dict(cur, **next), list_of_dicts))생각하지 못 했던 사항을 고려해보다현재 업무는 데이터 포맷을 변경하는 업무입니다.그렇다보니 평소에는 생각하지 못 했던 사항을 고려하게 됩니다.예를 들어 2GB 이상의 JSON 파일을 읽어야 했습니다.파이썬의 기본 라이브러리로는 메모리 초과 오류가 발생하여 직접 라이브러리를 확인한 결과, 파일 포인터 기준으로 전체 텍스트를 읽어오는 코드가 있었습니다.이를 해결하기 위해서는 파일의 iterable한 접근이 필요했고 ijson이라는 라이브러리를 찾아 해결하였습니다.최근에는 멀티쓰레드를 사용한 파일에서 메모리를 지나치게 사용하는 것을 발견해서 확인 중입니다.2023년에는 무엇을 할까??내년 목표는 크게 3가지입니다.  블로그 데이터 기반의 파이프라인 작성하기  블로그에 조금 더 열심히 기록하기  운전면허 따기이 글을 보는 여러분들도 2022년 열심히 달려오시느라 정말 고생 많으셨습니다.2023년도 모두모두 건강하고 기운차고 목표를 모두 이루는 한 해가 되기를 소망합니다!! 😊"
  },
  
  {
    "title": "220일 문제 풀이 여정의 끝과 새로운 시작",
    "url": "/posts/0111_ps_retrospect/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 회고(retrospect)",
    "date": "2022-07-31 22:47:00 +0900",
    





    
    "snippet": "발단: 일단 뭐라도 해보자!2021년 겨울방학, 4학년 2학기를 마쳐가며 자신을 되돌아보았습니다.주변 친구들에 비해 뚜렷한 장점이 보이지 않았습니다.무기력함을 깨기 위해, 그리고 무언가를 루틴처럼 수행해보고자 무작정 코딩 문제를 마음먹었습니다.이후 어떠한 방식으로 진행할지 구체적으로 그려보았습니다.그 결과 매주 평일마다 프로그래밍 문제 1개 풀기를 통...",
    "content": "발단: 일단 뭐라도 해보자!2021년 겨울방학, 4학년 2학기를 마쳐가며 자신을 되돌아보았습니다.주변 친구들에 비해 뚜렷한 장점이 보이지 않았습니다.무기력함을 깨기 위해, 그리고 무언가를 루틴처럼 수행해보고자 무작정 코딩 문제를 마음먹었습니다.이후 어떠한 방식으로 진행할지 구체적으로 그려보았습니다.그 결과 매주 평일마다 프로그래밍 문제 1개 풀기를 통해 파이썬과 알고리즘에 숙련도를 키우자는 목표를 세웠습니다.전개: 50일, 100일, 150일, …평일 동안 하루 1개의 백준 문제 풀기.정말 단순해 보이는 계획은 매주 차곡차곡 쌓여갔습니다.하지만 생각보다 다양한 상황이 펼쳐졌습니다. 물 위의 백조의 모습 아래에는 열심히 헤엄치는 물갈퀴가 있듯 저 역시 보이지 않는 곳에서 열심히 노력했습니다.시간 부족2~3일 마다 겪던 문제입니다. 1월부터 6월까지 [빅데이터분석서비스개발] 이라는 국비지원 교육을 수강했는데요. 교육이 끝나고 집에 오면 늘 시간에 허덕였습니다.그 날 풀지 못한 경우에는 매일 할당량의 기존에 익숙한 알고리즘의 문제를 풀고, 남은 풀이는 다음 날 혹은 주말에 진행했습니다..!!지인과의 약속저는 상당한 집돌이지만 그럼에도 때때로 약속이 생겼습니다. 주말이라면 편하게 다녀왔지만, 평일이라면 약속 이후에 문제를 풀 시간이 사실상 없었습니다.이 경우 전날 2개의 문제를 풀고 1개는 바로 제출, 나머지 하나는 12시가 넘어 제출하는 방식을 취했습니다.예기치 못한 상황한 번은 문제 푸는 걸 깜박한 상태로 노트북 없이 외부에 있던 적이 있었습니다.굉장히 당황스러웠지만 우리는 모두 스마트폰이라는 고성능 컴퓨터가 있죠!바로 스마트폰을 켜서 알고리즘이 복잡한 문제 대신 비교적 간단한 문제를 제출했고 안도의 한숨을 돌릴 수 있었습니다.절정: 아니 이게 왜 안 풀리지????저는 학부 과정에서 자료구조와 알고리즘 강의를 수강했습니다.그러나 학습은 배우고 익히는 것입니다. 저의 경우, 열심히 학을 수행하고 습을 하지 않았습니다…결국 기초 중 기초인 빅오 표기법부터 차근차근 공부해나갔습니다.기초적인 알고리즘도 모르면서 어설프게 아는 척 해왔던 스스로를 보며 자신감이 많이 떨어지기도 했습니다.하지만 떨어진 공이 바닥을 만나면 튀어 오르듯, 모자람을 알았다면 다시 채우면 된다고 믿었습니다.결말: 220일 동안 160개의 문제를 되돌아보며이후 2021년 12월 21일부터 2022년 7월 29일까지 220일 동안 160개의 문제를 풀었습니다.7개월 동안 매주 평일마다 1개의 문제를 풀었다는 점은 그렇게 대단한 성과가 아닐 겁니다.그렇지만 달성할 수 있는 계획을 세우고, 돌발상황을 예측해 대비하고, 천천히 꾸준하게 나아온 지금의 경험은 저만의 경쟁력으로 자리매김할 수 있었습니다.다시 첫걸음을 떼다2022년 8월 1일, 좋은 인연이 닿아 첫 직장으로 첫 출근을 하게 되었습니다.그래서 앞으로의 문제 풀이 포스트는 이전과 같이 올리기 어렵게 되었습니다. (물론 봐주시는 분들이 많지는 않았지만요 하하)저의 목표는 데이터 엔지니어입니다.이를 위해 가야 할 길은 지금까지와는 비교도 안 될 만큼 험난합니다.하지만 천릿길도 한 걸음부터라고 첫걸음을 뗐으니 이제는 나아갈 수 있습니다.이 글을 보시는 독자 여러분들도 작은 성과를 보여주는 무언가부터 시작해보신다면 그 끝은 누구보다 창대하리라 믿어 의심치 않습니다.“이걸로 뭐가 되겠어?” 대신 “이걸로 어떻게 되려나? 너가 이기나 내가 이기나 해보자!“로 첫걸음을 떼보시는 건 어떨까요?끝으로 저와 독자 분을 포함한 그동안 노력한 모두에게 감사를 또한 앞으로 노력할 모두에게 응원을 보냅니다.감사합니다."
  },
  
  {
    "title": "백준 2166번 다각형의 면적",
    "url": "/posts/0110_boj_2166/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 기하학(geometry), 다각형의 넓이(area_of_polygon)",
    "date": "2022-07-26 22:17:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #기하학 #다각형의 넓이조건            시간 제한      메모리 제한                  2 초      128 MB      문제2차원 평면상에 N(3 ≤ N ≤ 10,000)개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.입력첫째 줄에...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #기하학 #다각형의 넓이조건            시간 제한      메모리 제한                  2 초      128 MB      문제2차원 평면상에 N(3 ≤ N ≤ 10,000)개의 점으로 이루어진 다각형이 있다. 이 다각형의 면적을 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. 다음 N개의 줄에는 다각형을 이루는 순서대로 N개의 점의 x, y좌표가 주어진다. 좌표값은 절댓값이 100,000을 넘지 않는 정수이다.출력첫째 줄에 면적을 출력한다. 면적을 출력할 때에는 소수점 아래 둘째 자리에서 반올림하여 첫째 자리까지 출력한다.예제 입출력 1입력40 00 1010 1010 0출력100.0코드(파이썬)import sysn = int(sys.stdin.readline())nums = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]nums = nums + [nums[0]]left, right = 0, 0for i in range(n):    left += nums[i][0] * nums[i+1][1]    right += nums[i][1] * nums[i+1][0]    print(f\"{abs(left-right) / 2:.1f}\")특이사항  해결방법          다각형의 넓이를 구하는 방법 탐색                  모든 i번째 x좌표와 y좌표를 i+1번째 y좌표와 x좌표를 곱함(첫 번째 좌표를 마지막에 추가)          i_x, i+1_y의 곱의 합과 i_y, i+1_x의 곱의 합을 빼고 이를 2로 나누면 다각형의 면적                    그대로 알고리즘 구현      참고문헌  “다각형 넓이 구하기”, wikiHow, ko.wikihow.com/다각형-넓이-구하기"
  },
  
  {
    "title": "백준 2661번 좋은수열",
    "url": "/posts/0109_boj_2661/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 백트래킹(backtracking)",
    "date": "2022-07-25 22:14:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #백트래킹조건            시간 제한      메모리 제한                  1 초      128 MB      문제숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #백트래킹조건            시간 제한      메모리 제한                  1 초      128 MB      문제숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.다음은 나쁜 수열의 예이다.  33  32121323  123123213다음은 좋은 수열의 예이다.  2  32  32123  1232123길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.입력입력은 숫자 N하나로 이루어진다. N은 1 이상 80 이하이다.출력첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.예제 입출력 1입력7출력1213121코드(파이썬)def check(num):    tmp = stack + [num]    len_tmp = len(tmp)-1    for i in range(len_tmp//2+1):        if tmp[len_tmp-1-2*i:len_tmp-i] == tmp[len_tmp-i:]:            return False    return Truedef back_track(num):    global still_find        if len(stack) == n:        print(\"\".join(map(str, stack)))        still_find = False        return        for i in nums[num]:        if still_find and check(i):            stack.append(i)            back_track(i)            stack.pop()            n = int(input())nums = [[0, 0], [2, 3], [1, 3], [1, 2]]still_find = Truestack = [1]back_track(1)특이사항  해결방법          백트래킹으로 경우의 수 탐색      check 함수에서 현재 숫자를 추가했을 때 인접한 2개의 부분수열이 있는지 확인      길이가 n인 수열을 찾았다면 still_find를 False로 변경해 백트래킹 종료      참고문헌-"
  },
  
  {
    "title": "백준 17609번 회문",
    "url": "/posts/0108_boj_17609/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 투포인터(two_pointer), 문자열(string)",
    "date": "2022-07-22 22:18:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #투포인터 #문자열조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      512 MB      문제회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #투포인터 #문자열조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      512 MB      문제회문(回文) 또는 팰린드롬(palindrome)은 앞 뒤 방향으로 볼 때 같은 순서의 문자로 구성된 문자열을 말한다. 예를 들어 ‘abba’ ‘kayak’, ‘reviver’, ‘madam’은 모두 회문이다. 만일 그 자체는 회문이 아니지만 한 문자를 삭제하여 회문으로 만들 수 있는 문자열이라면 우리는 이런 문자열을 “유사회문”(pseudo palindrome)이라고 부른다. 예를 들어 ‘summuus’는 5번째나 혹은 6번째 문자 ‘u’를 제거하여 ‘summus’인 회문이 되므로 유사회문이다.여러분은 제시된 문자열을 분석하여 그것이 그 자체로 회문인지, 또는 한 문자를 삭제하면 회문이 되는 “유사회문”인지, 아니면 회문이나 유사회문도 아닌 일반 문자열인지를 판단해야 한다. 만일 문자열 그 자체로 회문이면 0, 유사회문이면 1, 그 외는 2를 출력해야 한다.입력입력의 첫 줄에는 주어지는 문자열의 개수를 나타내는 정수 T(1 ≤ T ≤ 30)가 주어진다. 다음 줄부터 T개의 줄에 걸쳐 한 줄에 하나의 문자열이 입력으로 주어진다. 주어지는 문자열의 길이는 3 이상 100,000 이하이고, 영문 알파벳 소문자로만 이루어져 있다.출력각 문자열이 회문인지, 유사 회문인지, 둘 모두 해당되지 않는지를 판단하여 회문이면 0, 유사 회문이면 1, 둘 모두 아니면 2를 순서대로 한 줄에 하나씩 출력한다.예제 입출력 1입력7abbasummuusxabbaxabbaycomcomcomwwmoccomwwtmoc출력0112201코드(파이썬)import sysdef palindrome(start, end, count):    while end-start &gt; 0:        if line[start] != line[end]:            if count &lt;= 1:                count += min(palindrome(start+1, end, count+1), palindrome(start, end-1, count+1))            break        start += 1        end -= 1            return count        t = int(sys.stdin.readline())for _ in range(t):    line = sys.stdin.readline().rstrip()        print(min(palindrome(0, len(line)-1, 0), 2))특이사항  해결방법          함수를 활용해 양쪽에서 다가오는 투포인터        내 코드(30,840KB, 348ms)에 비해 우수한 코드(바로가기, 30,840KB, 260ms)와 비교                  from sys import stdininput = stdin.readlineT = int(input())def isPal(S):    left = 0    right = len(S)-1    while left &lt; right:        if S[left] == S[right]:            left += 1            right -= 1        else:            return min(isPseudo(S, left+1, right), isPseudo(S, left, right-1))    return 0def isPseudo(S, left, right):    while left &lt; right:        if S[left] == S[right]:            left += 1            right -= 1        else:            return 2    return 1for _ in range(T):    print(isPal(input().rstrip()))                    회문 → 유사회문 판단                  기존: 1개의 함수에서 break로 중지          개선: 2개의 함수에서 return으로 중지                    참고문헌-"
  },
  
  {
    "title": "백준 2470번 두 용액",
    "url": "/posts/0107_boj_2470/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 정렬(sorting), 투포인터(two_pointer), 이분탐색(binary_search)",
    "date": "2022-07-18 21:18:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #정렬 #이분 탐색 #투포인터조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      128 MB      문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #정렬 #이분 탐색 #투포인터조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      128 MB      문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다.  산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-2, 4, -99, -1, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액이 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.입력첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.출력첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.예제 입출력 1입력5-2 4 -99 -1 98출력-99 98코드(파이썬)import sysn = int(sys.stdin.readline())liquid = list(map(int, sys.stdin.readline().split()))liquid.sort(key=lambda x:abs(x))result = 2 * 1000000000result_l = [0, 0]for i in range(1, n):    l, r = liquid[i-1], liquid[i]    if result &gt; abs(l + r):        result = abs(l + r)        result_l = [l, r]    print(min(result_l), max(result_l))특이사항  해결방법          용액들을 절댓값으로 오름차순 정렬      서로 인접한 두 용액을 합쳐서 특성값이 0에 가까운 경우 탐색      참고문헌-"
  },
  
  {
    "title": "백준 2225번 합분해",
    "url": "/posts/0106_boj_2225/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 수학(math)",
    "date": "2022-07-14 21:57:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #수학조건            시간 제한      메모리 제한                  2 초      128 MB      문제0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.덧셈의 순서가 바뀐 경우는 다른 경우로 센다(...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #수학조건            시간 제한      메모리 제한                  2 초      128 MB      문제0부터 N까지의 정수 K개를 더해서 그 합이 N이 되는 경우의 수를 구하는 프로그램을 작성하시오.덧셈의 순서가 바뀐 경우는 다른 경우로 센다(1+2와 2+1은 서로 다른 경우). 또한 한 개의 수를 여러 번 쓸 수도 있다.입력첫째 줄에 두 정수 N(1 ≤ N ≤ 200), K(1 ≤ K ≤ 200)가 주어진다.출력첫째 줄에 답을 1,000,000,000으로 나눈 나머지를 출력한다.예제 입출력 1입력20 2출력21예제 입출력 2입력6 4출력84코드(파이썬)n, k = map(int, input().split())dp = [[0] + [1]*k] + [[0] * (k+1) for _ in range(n)]for i in range(1, n+1):    for j in range(1, k+1):        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % 1000000000    print(dp[-1][-1])특이사항  해결방법          행을 합으로, 열을 정수의 갯수로 가지는 2차원 리스트 dp 생성      0을 더할 수 있는 경우(같은 행, 이전 열)와 그렇지 않은 경우(이전 행, 같은 열)을 더해 현재 행, 현재 열에 저장      참고문헌-"
  },
  
  {
    "title": "백준 2294번 동전 2",
    "url": "/posts/0105_boj_2294/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-07-13 22:15:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      128 MB      문제n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      128 MB      문제n가지 종류의 동전이 있다. 이 동전들을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그러면서 동전의 개수가 최소가 되도록 하려고 한다. 각각의 동전은 몇 개라도 사용할 수 있다.사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.입력첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다. 가치가 같은 동전이 여러 번 주어질 수도 있다.출력첫째 줄에 사용한 동전의 최소 개수를 출력한다. 불가능한 경우에는 -1을 출력한다.예제 입출력 1입력3 151512출력3코드(파이썬)import sysn, k = map(int, sys.stdin.readline().split())coins = list(set([int(sys.stdin.readline()) for _ in range(n)]))coins.sort()dp = [0] + [10001] * kfor coin in coins:    for i in range(coin, k+1):        dp[i] = min(dp[i], dp[i-coin]+1)    print(dp[-1] if dp[-1] &lt; 10001 else -1)특이사항  해결방법          가격에 따라 동전의 갯수를 카운트할 dp 리스트 생성      현재 가격의 갯수와 (현재 가격-동전) 가격의 갯수를 비교해 더 작은 값으로 수정      반복      참고문헌-"
  },
  
  {
    "title": "백준 2467번 용액",
    "url": "/posts/0104_boj_2467/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 투포인터(two_pointer), 이분탐색(binary_search)",
    "date": "2022-07-12 22:14:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #투포인터 #이분탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #투포인터 #이분탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제KOI 부설 과학연구소에서는 많은 종류의 산성 용액과 알칼리성 용액을 보유하고 있다. 각 용액에는 그 용액의 특성을 나타내는 하나의 정수가 주어져있다. 산성 용액의 특성값은 1부터 1,000,000,000까지의 양의 정수로 나타내고, 알칼리성 용액의 특성값은 -1부터 -1,000,000,000까지의 음의 정수로 나타낸다.같은 양의 두 용액을 혼합한 용액의 특성값은 혼합에 사용된 각 용액의 특성값의 합으로 정의한다. 이 연구소에서는 같은 양의 두 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들려고 한다.예를 들어, 주어진 용액들의 특성값이 [-99, -2, -1, 4, 98]인 경우에는 특성값이 -99인 용액과 특성값이 98인 용액을 혼합하면 특성값이 -1인 용액을 만들 수 있고, 이 용액의 특성값이 0에 가장 가까운 용액이다. 참고로, 두 종류의 알칼리성 용액만으로나 혹은 두 종류의 산성 용액만으로 특성값이 0에 가장 가까운 혼합 용액을 만드는 경우도 존재할 수 있다.산성 용액과 알칼리성 용액의 특성값이 정렬된 순서로 주어졌을 때, 이 중 두 개의 서로 다른 용액을 혼합하여 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액을 찾는 프로그램을 작성하시오.입력첫째 줄에는 전체 용액의 수 N이 입력된다. N은 2 이상 100,000 이하의 정수이다. 둘째 줄에는 용액의 특성값을 나타내는 N개의 정수가 빈칸을 사이에 두고 오름차순으로 입력되며, 이 수들은 모두 -1,000,000,000 이상 1,000,000,000 이하이다. N개의 용액들의 특성값은 모두 서로 다르고, 산성 용액만으로나 알칼리성 용액만으로 입력이 주어지는 경우도 있을 수 있다.출력첫째 줄에 특성값이 0에 가장 가까운 용액을 만들어내는 두 용액의 특성값을 출력한다. 출력해야 하는 두 용액은 특성값의 오름차순으로 출력한다. 특성값이 0에 가장 가까운 용액을 만들어내는 경우가 두 개 이상일 경우에는 그 중 아무것이나 하나를 출력한다.예제 입출력 1입력5-99 -2 -1 4 98출력-99 98예제 입출력 2입력4-100 -2 -1 103출력-2 -1코드(파이썬)import sysn = int(sys.stdin.readline())nums = list(map(int, sys.stdin.readline().split()))nums.sort(key=lambda x:abs(x))least = 10 ** 10result_idx = 0for i in range(1, n):    now = abs(nums[i-1] + nums[i])        if least &gt; now:        least = now        result_idx = i    print(*sorted([nums[result_idx], nums[result_idx-1]]))특이사항  해결방법          숫자들을 절대값 순으로 정렬      옆의 숫자를 차례대로 합쳐 0과 가장 가까운 값 2개 탐색      탐색 이후 가장 가까운 값 2개 출력      참고문헌-"
  },
  
  {
    "title": "백준 2293번 동전 1",
    "url": "/posts/0103_boj_2293/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-07-11 22:18:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      4 MB      문제n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      4 MB      문제n가지 종류의 동전이 있다. 각각의 동전이 나타내는 가치는 다르다. 이 동전을 적당히 사용해서, 그 가치의 합이 k원이 되도록 하고 싶다. 그 경우의 수를 구하시오. 각각의 동전은 몇 개라도 사용할 수 있다.사용한 동전의 구성이 같은데, 순서만 다른 것은 같은 경우이다.입력첫째 줄에 n, k가 주어진다. (1 ≤ n ≤ 100, 1 ≤ k ≤ 10,000) 다음 n개의 줄에는 각각의 동전의 가치가 주어진다. 동전의 가치는 100,000보다 작거나 같은 자연수이다.출력첫째 줄에 경우의 수를 출력한다. 경우의 수는 231보다 작다.예제 입출력 1입력3 10125출력10코드(파이썬)import sysn, k = map(int, sys.stdin.readline().split())coins = [int(sys.stdin.readline()) for _ in range(n)]coins.sort()dp = [1] + [0] * kfor coin in coins:    for i in range(coin, k+1):        dp[i] += dp[i-coin]        print(dp[-1])특이사항  해결방법          작은 가치의 동전부터 순차적으로 dp 리스트에 추가      참고문헌-"
  },
  
  {
    "title": "백준 1715번 카드 정렬하기",
    "url": "/posts/0102_boj_1715/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그리디 알고리즘(greedy_algorithm), 우선순위큐(priority_queue), 자료구조(data_structure)",
    "date": "2022-07-05 23:18:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #그리디 알고리즘 #우선순위큐조건            시간 제한      메모리 제한                  2 초      128 MB      문제정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #그리디 알고리즘 #우선순위큐조건            시간 제한      메모리 제한                  2 초      128 MB      문제정렬된 두 묶음의 숫자 카드가 있다고 하자. 각 묶음의 카드의 수를 A, B라 하면 보통 두 묶음을 합쳐서 하나로 만드는 데에는 A+B 번의 비교를 해야 한다. 이를테면, 20장의 숫자 카드 묶음과 30장의 숫자 카드 묶음을 합치려면 50번의 비교가 필요하다.매우 많은 숫자 카드 묶음이 책상 위에 놓여 있다. 이들을 두 묶음씩 골라 서로 합쳐나간다면, 고르는 순서에 따라서 비교 횟수가 매우 달라진다. 예를 들어 10장, 20장, 40장의 묶음이 있다면 10장과 20장을 합친 뒤, 합친 30장 묶음과 40장을 합친다면 (10 + 20) + (30 + 40) = 100번의 비교가 필요하다. 그러나 10장과 40장을 합친 뒤, 합친 50장 묶음과 20장을 합친다면 (10 + 40) + (50 + 20) = 120 번의 비교가 필요하므로 덜 효율적인 방법이다.N개의 숫자 카드 묶음의 각각의 크기가 주어질 때, 최소한 몇 번의 비교가 필요한지를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100,000) 이어서 N개의 줄에 걸쳐 숫자 카드 묶음의 각각의 크기가 주어진다. 숫자 카드 묶음의 크기는 1,000보다 작거나 같은 양의 정수이다.출력첫째 줄에 최소 비교 횟수를 출력한다.예제 입출력 1입력3102040출력100코드(파이썬)import heapqimport sysn = int(sys.stdin.readline())cards = list()result = 0for _ in range(n):    num = int(sys.stdin.readline())    heapq.heappush(cards, num)    for _ in range(n-1):    least1 = heapq.heappop(cards)    least2 = heapq.heappop(cards)    result += least1 + least2    heapq.heappush(cards, least1+least2)    print(result)특이사항  해결방법          힙에 모든 카드 묶음 삽입      가장 작은 카드 묶음 2개 삭제      2개를 합친 후 다시 힙에 삽입      위 과정을 반복      참고문헌-"
  },
  
  {
    "title": "백준 3190번 뱀",
    "url": "/posts/0101_boj_3190/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 시뮬레이션(simulation), 자료구조(data_structure), 덱(deque), 큐(queue)",
    "date": "2022-07-04 22:29:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #구현 #시뮬레이션 #자료구조 #덱 #큐조건            시간 제한      메모리 제한                  1 초      128 MB      문제‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #구현 #시뮬레이션 #자료구조 #덱 #큐조건            시간 제한      메모리 제한                  1 초      128 MB      문제‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.  먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.  만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.  만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.  사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.입력첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데,  정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.출력첫째 줄에 게임이 몇 초에 끝나는지 출력한다.예제 입출력 1입력633 42 55 333 D15 L17 D출력9예제 입출력 2입력1041 21 31 41 548 D10 D11 D13 L출력21예제 입출력 3입력1051 51 31 21 61 748 D10 D11 D13 L출력13코드(파이썬)from collections import dequen = int(input())board = [[0] * n for _ in range(n)]d_yx = [(0, 1), (1, 0), (0, -1), (-1, 0)]d_next = [(3, 1), (0, 2), (1, 3), (2, 0)]d_now = 0snake = deque([(0, 0)])change = [-1] * 10001for _ in range(int(input())):    i, j = map(lambda x: x-1, map(int, input().split()))    board[i][j] = 2for _ in range(int(input())):    time, d = input().split()    time = int(time)    d = 0 if d == \"L\" else 1        change[time] = d    for now in range(0, 10000):    if change[now] != -1:        d_now = d_next[d_now][change[now]]        d_y, d_x = d_yx[d_now]    head_y, head_x = snake[-1]    next_y = d_y + head_y    next_x = d_x + head_x        if -1&lt;next_y&lt;n and -1&lt;next_x&lt;n:        if (next_y,next_x) in snake:            break        else:            snake.append((next_y, next_x))            if board[next_y][next_x] != 2:                snake.popleft()            else:                board[next_y][next_x] = 0    else:        break        print(now+1)특이사항  해결방법          문제의 조건에 맞는 snake deque 생성(시작: 꼬리, 끝: 머리)      이동한 칸이 끝이거나 몸이라면 종료      머리부터 이동      이동한 칸에 사과가 있다면 꼬리는 움직이지 않음      이동한 칸에 사과가 없다면 꼬리가 움직임      참고문헌-"
  },
  
  {
    "title": "백준 14503번 로봇청소기",
    "url": "/posts/0100_boj_14503/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 시뮬레이션(simulation)",
    "date": "2022-07-01 23:38:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  2 초      512 MB      문제로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  2 초      512 MB      문제로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 북쪽에서부터 r번째, 서쪽에서부터 c번째로 위치한 칸은 (r, c)로 나타낼 수 있다.로봇 청소기는 다음과 같이 작동한다.  현재 위치를 청소한다.      현재 위치에서 다음을 반복하면서 인접한 칸을 탐색한다.    a. 현재 위치의 바로 왼쪽에 아직 청소하지 않은 빈 공간이 존재한다면, 왼쪽 방향으로 회전한 다음 한 칸을 전진하고 1번으로 돌아간다. 그렇지 않을 경우, 왼쪽 방향으로 회전한다. 이때, 왼쪽은 현재 바라보는 방향을 기준으로 한다.    b. 1번으로 돌아가거나 후진하지 않고 2a번 단계가 연속으로 네 번 실행되었을 경우, 바로 뒤쪽이 벽이라면 작동을 멈춘다. 그렇지 않다면 한 칸 후진한다.  입력첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.출력로봇 청소기가 청소하는 칸의 개수를 출력한다.예제 입출력 1입력3 31 1 01 1 11 0 11 1 1출력1예제 입출력 2입력11 107 4 01 1 1 1 1 1 1 1 1 11 0 0 0 0 0 0 0 0 11 0 0 0 1 1 1 1 0 11 0 0 1 1 0 0 0 0 11 0 1 1 0 0 0 0 0 11 0 0 0 0 0 0 0 0 11 0 0 0 0 0 0 1 0 11 0 0 0 0 0 1 1 0 11 0 0 0 0 0 1 1 0 11 0 0 0 0 0 0 0 0 11 1 1 1 1 1 1 1 1 1출력57코드(파이썬)from itertools import combinationsfrom copy import deepcopydef bfs():    queue = start.copy()    tmp_lab = deepcopy(lab)        while queue:        y, x = queue.pop()        tmp_lab[y][x] = 2                for i in range(4):            next_x = x + dx[i]            next_y = y + dy[i]            if -1 &lt; next_y &lt; n and -1 &lt; next_x &lt; m and tmp_lab[next_y][next_x] == 0:                queue.append((next_y, next_x))                return sum([row.count(0) for row in tmp_lab])n, m = map(int, input().split())lab = [list(map(int, input().split())) for _ in range(n)]blank = [(i,j) for i in range(n) for j in range(m) if lab[i][j] == 0]start = [(i,j) for i in range(n) for j in range(m) if lab[i][j] == 2]dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]result = 0for walls in combinations(blank, 3):    for i, j in walls:        lab[i][j] = 1            result = max(result, bfs())        for i, j in walls:        lab[i][j] = 0        print(result)특이사항  해결방법          DFS 형식을 빌림      cleaning 함수에서 문제의 조건에 따라 조건 작성      4번의 왼쪽 방향 확인 후 이동한다면 non_zero를 1로 수정      non_zero가 1이라면(4번의 왼쪽 모두 갈 수 없다면)                  마지막 방향의 뒤를 확인          벽이 아니라면 후퇴, 벽이라면 종료                    참고문헌-"
  },
  
  {
    "title": "백준 14502번 연구소",
    "url": "/posts/0099_boj_14502/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 구현(implementation), 브루트포스(bruteforce), 너비우선탐색(breadth_first_search)",
    "date": "2022-06-23 22:23:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #그래프이론 #그래프탐색 #너비 우선 탐색  #브루트포스조건            시간 제한      메모리 제한                  2 초      512 MB      문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #그래프이론 #그래프탐색 #너비 우선 탐색  #브루트포스조건            시간 제한      메모리 제한                  2 초      512 MB      문제인체에 치명적인 바이러스를 연구하던 연구소에서 바이러스가 유출되었다. 다행히 바이러스는 아직 퍼지지 않았고, 바이러스의 확산을 막기 위해서 연구소에 벽을 세우려고 한다.연구소는 크기가 N×M인 직사각형으로 나타낼 수 있으며, 직사각형은 1×1 크기의 정사각형으로 나누어져 있다. 연구소는 빈 칸, 벽으로 이루어져 있으며, 벽은 칸 하나를 가득 차지한다.일부 칸은 바이러스가 존재하며, 이 바이러스는 상하좌우로 인접한 빈 칸으로 모두 퍼져나갈 수 있다. 새로 세울 수 있는 벽의 개수는 3개이며, 꼭 3개를 세워야 한다.예를 들어, 아래와 같이 연구소가 생긴 경우를 살펴보자.2 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0이때, 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 곳이다. 아무런 벽을 세우지 않는다면, 바이러스는 모든 빈 칸으로 퍼져나갈 수 있다.2행 1열, 1행 2열, 4행 6열에 벽을 세운다면 지도의 모양은 아래와 같아지게 된다.2 1 0 0 1 1 01 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 1 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0바이러스가 퍼진 뒤의 모습은 아래와 같아진다.2 1 0 0 1 1 21 0 1 0 1 2 20 1 1 0 1 2 20 1 0 0 0 1 20 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0벽을 3개 세운 뒤, 바이러스가 퍼질 수 없는 곳을 안전 영역이라고 한다. 위의 지도에서 안전 영역의 크기는 27이다.연구소의 지도가 주어졌을 때 얻을 수 있는 안전 영역 크기의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 지도의 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 8)둘째 줄부터 N개의 줄에 지도의 모양이 주어진다. 0은 빈 칸, 1은 벽, 2는 바이러스가 있는 위치이다. 2의 개수는 2보다 크거나 같고, 10보다 작거나 같은 자연수이다.빈 칸의 개수는 3개 이상이다.출력첫째 줄에 얻을 수 있는 안전 영역의 최대 크기를 출력한다.예제 입출력 1입력7 72 0 0 0 1 1 00 0 1 0 1 2 00 1 1 0 1 0 00 1 0 0 0 0 00 0 0 0 0 1 10 1 0 0 0 0 00 1 0 0 0 0 0출력27예제 입출력 2입력4 60 0 0 0 0 01 0 0 0 0 21 1 1 0 0 20 0 0 0 0 2출력9예제 입출력 3입력8 82 0 0 0 0 0 0 22 0 0 0 0 0 0 22 0 0 0 0 0 0 22 0 0 0 0 0 0 22 0 0 0 0 0 0 20 0 0 0 0 0 0 00 0 0 0 0 0 0 00 0 0 0 0 0 0 0출력3코드(파이썬)from itertools import combinationsfrom copy import deepcopydef bfs():    queue = start.copy()    tmp_lab = deepcopy(lab)        while queue:        y, x = queue.pop()        tmp_lab[y][x] = 2                for i in range(4):            next_x = x + dx[i]            next_y = y + dy[i]            if -1 &lt; next_y &lt; n and -1 &lt; next_x &lt; m and tmp_lab[next_y][next_x] == 0:                queue.append((next_y, next_x))                return sum([row.count(0) for row in tmp_lab])n, m = map(int, input().split())lab = [list(map(int, input().split())) for _ in range(n)]blank = [(i,j) for i in range(n) for j in range(m) if lab[i][j] == 0]start = [(i,j) for i in range(n) for j in range(m) if lab[i][j] == 2]dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]result = 0for walls in combinations(blank, 3):    for i, j in walls:        lab[i][j] = 1            result = max(result, bfs())        for i, j in walls:        lab[i][j] = 0        print(result)특이사항  해결방법          연구소 최대 크기가 8x8이어서 브루트포스로 진행      최대 조합의 수는 62C3 = 37820이므로 시간초과가 없었지만 풀이의 방법은 시간복잡도가 높아 간신히 통과        내 코드(30,966KB, 5,665ms)에 비해 우수한 코드(바로가기, 32,528KB, 1,552ms)와 비교                  import sys; input = sys.stdin.readlinefrom itertools import combinationsfrom collections import dequeN, M = map(int, input().split())graph = []for _ in range(N) :    graph.append(input().split())total = N * Mwall = 0virus = 0virus_pos = []zero_pos = []for i in range(N) :    for j in range(M) :        if graph[i][j] == '1' :            wall += 1        elif graph[i][j] == '2' :            virus_pos.append((i, j))            virus += 1        else :            zero_pos.append((i, j))def bfs(set_wall_yx, new_graph) :    for sy, sx in set_wall_yx :        new_graph[sy][sx] = '1'    safe_cnt = total - virus - wall - 3    que = deque(virus_pos)    while que :        length = len(que)        infected_cnt = 0        for _ in range(length) :            vi, vj = que.popleft()            if 0 &lt;= vi - 1 and new_graph[vi-1][vj] == '0' :                new_graph[vi-1][vj] = '2'                que.append((vi-1, vj))                infected_cnt += 1            if vi + 1 &lt; N and new_graph[vi+1][vj] == '0' :                new_graph[vi+1][vj] = '2'                que.append((vi+1, vj))                infected_cnt += 1            if 0 &lt;= vj - 1 and new_graph[vi][vj-1] == '0' :                new_graph[vi][vj-1] = '2'                que.append((vi, vj-1))                infected_cnt += 1            if vj + 1 &lt; M and new_graph[vi][vj+1] == '0' :                new_graph[vi][vj+1] = '2'                que.append((vi, vj+1))                infected_cnt += 1        safe_cnt -= infected_cnt        if not infected_cnt :            return safe_cntmax_safe_cnt = 0for set_wall_yx in combinations(zero_pos, 3) :    copy_graph = [graph[i][:] for i in range(N)]    each_safe_cnt = bfs(set_wall_yx, copy_graph)    if each_safe_cnt &gt; max_safe_cnt :        max_safe_cnt = each_safe_cntprint(max_safe_cnt)                    안전 영역 계산                  기존: lab의 모든 0의 개수를 더함          개선: lab의 0을 지날 때마다 cnt를 1씩 증가시키고 마지막에 이를 뻄                    참고문헌-"
  },
  
  {
    "title": "백준 1062번 호텔",
    "url": "/posts/0098_boj_1062/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 백트래킹(backtracking), 브루트포스(bruteforce), 비트마스킹(bitmasking)",
    "date": "2022-06-22 22:29:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #브루트포스 #백트래킹 #비트마스킹조건            시간 제한      메모리 제한                  1 초      128 MB      문제남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #브루트포스 #백트래킹 #비트마스킹조건            시간 제한      메모리 제한                  1 초      128 MB      문제남극에 사는 김지민 선생님은 학생들이 되도록이면 많은 단어를 읽을 수 있도록 하려고 한다. 그러나 지구온난화로 인해 얼음이 녹아서 곧 학교가 무너지기 때문에, 김지민은 K개의 글자를 가르칠 시간 밖에 없다. 김지민이 가르치고 난 후에는, 학생들은 그 K개의 글자로만 이루어진 단어만을 읽을 수 있다. 김지민은 어떤 K개의 글자를 가르쳐야 학생들이 읽을 수 있는 단어의 개수가 최대가 되는지 고민에 빠졌다.남극언어의 모든 단어는 “anta”로 시작되고, “tica”로 끝난다. 남극언어에 단어는 N개 밖에 없다고 가정한다. 학생들이 읽을 수 있는 단어의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 단어의 개수 N과 K가 주어진다. N은 50보다 작거나 같은 자연수이고, K는 26보다 작거나 같은 자연수 또는 0이다. 둘째 줄부터 N개의 줄에 남극 언어의 단어가 주어진다. 단어는 영어 소문자로만 이루어져 있고, 길이가 8보다 크거나 같고, 15보다 작거나 같다. 모든 단어는 중복되지 않는다.출력첫째 줄에 김지민이 K개의 글자를 가르칠 때, 학생들이 읽을 수 있는 단어 개수의 최댓값을 출력한다.예제 입출력 1입력3 6antarcticaantahelloticaantacartica출력2예제 입출력 2입력2 3antaxxxxxxxticaantarctica출력0예제 입출력 3입력9 8antabticaantaxticaantadticaantaeticaantafticaantagticaantahticaantajticaantaktica출력3코드(파이썬)from itertools import combinationsfrom functools import reduceantatica = {ord(c) - ord('a') for c in \"antatica\"}result = 0n, k = map(int, input().split())words = [{ord(c) - ord('a') for c in input().rstrip()}.difference(antatica) for _ in range(n)]all_words = reduce(lambda a, b:a.union(b), words)if k &gt; 4:    if len(all_words) &gt; k-5:        for set_word in map(set, combinations(all_words, k-5)):            result = max(result, sum([w.difference(set_word)==set() for w in words]))    else:        result = len(words)print(result)특이사항  해결방법          입력 문자열을 문자셋 리스트인 words로 변경      지금 있는 모든 문자를 all_words에 저장      k가 4보다 크다면                  all_words의 길이가 k-5보다 길다면 all_words의 문자들의 조합을 만들어 브루트포스로 최댓값 탐색          all_words의 길이가 더 짧거나 같다면 words의 길이로 최댓값                      내 코드(32,452KB, 4,448ms)에 비해 우수한 코드(바로가기, 30,840KB, 864ms)와 비교                  from itertools import combinationsfrom sys import stdininput = stdin.readlinedef solution():    n,k = map(int, input().split())    if k &lt; 5:        return 0    k -= 5    learned = set('antic')    unlearned = set()    cant_read_words = []    can_read_cnt = 0    for _ in range(n):        word = set(input().rstrip()) - learned        if word:            unlearned.update(word)            cant_read_words.append(word)        else:            can_read_cnt += 1            if len(unlearned) &lt;= k:        return n    answer = 0    for comb in combinations(unlearned,k):        comb = set(comb)        cnt = 0        for word in cant_read_words:            if comb &gt;= word:                cnt += 1        answer = max(answer, cnt)            answer += can_read_cnt    return answerprint(solution())                    큰 틀에서는 동일한 알고리즘으로 보임 -&gt; 4배의 차이가 나는 명확한 이유 확인 필요      참고문헌-"
  },
  
  {
    "title": "백준 1106번 호텔",
    "url": "/posts/0097_boj_1106/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 배낭문제(knapsack_problem)",
    "date": "2022-06-21 23:04:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #배낭문제조건            시간 제한      메모리 제한                  2 초      128 MB      문제세계적인 호텔인 형택 호텔의 사장인 김형택은 이번에 수입을 조금 늘리기 위해서 홍보를 하려고 한다.형택이가 홍보를 할 수 있는 도시가 주어...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #배낭문제조건            시간 제한      메모리 제한                  2 초      128 MB      문제세계적인 호텔인 형택 호텔의 사장인 김형택은 이번에 수입을 조금 늘리기 위해서 홍보를 하려고 한다.형택이가 홍보를 할 수 있는 도시가 주어지고, 각 도시별로 홍보하는데 드는 비용과, 그 때 몇 명의 호텔 고객이 늘어나는지에 대한 정보가 있다.예를 들어, “어떤 도시에서 9원을 들여서 홍보하면 3명의 고객이 늘어난다.”와 같은 정보이다. 이때, 이러한 정보에 나타난 돈에 정수배 만큼을 투자할 수 있다. 즉, 9원을 들여서 3명의 고객, 18원을 들여서 6명의 고객, 27원을 들여서 9명의 고객을 늘어나게 할 수 있지만, 3원을 들여서 홍보해서 1명의 고객, 12원을 들여서 4명의 고객을 늘어나게 할 수는 없다.각 도시에는 무한 명의 잠재적인 고객이 있다. 이때, 호텔의 고객을 적어도 C명 늘이기 위해 형택이가 투자해야 하는 돈의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 C와 형택이가 홍보할 수 있는 도시의 개수 N이 주어진다. C는 1,000보다 작거나 같은 자연수이고, N은 20보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 각 도시에서 홍보할 때 대는 비용과 그 비용으로 얻을 수 있는 고객의 수가 주어진다. 이 값은 100보다 작거나 같은 자연수이다.출력첫째 줄에 문제의 정답을 출력한다.예제 입출력 1입력12 23 51 1출력8예제 입출력 2입력10 33 12 21 3출력4예제 입출력 3입력10 101 12 23 34 45 56 67 78 89 910 10출력10예제 입출력 4입력100 64 99 113 48 71 29 8출력45코드(파이썬)import sys    c, n = map(int, sys.stdin.readline().split())promotion = [tuple(map(int, sys.stdin.readline().split())) for _ in range(n)]promotion.sort()dp = [0] + [100001] * (c+100)for i in range(1, promotion[0][1]+1):    dp[i] = promotion[0][0]for cost, people in promotion:    for i in range(promotion[0][1]+1, c+100):        dp[i] = min(dp[i], dp[i-people]+cost)        print(min(dp[c:]))특이사항  참고문헌-"
  },
  
  {
    "title": "백준 2623번 음악프로그램",
    "url": "/posts/0096_boj_2623/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 위상정렬(topology_sort)",
    "date": "2022-06-17 23:00:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #위상정렬조건            시간 제한      메모리 제한                  1 초      128 MB      문제인터넷 방송 KOI(Korea Open Internet)의 음악 프로그램 PD인 남일이는 자기가 맡은 프로그램 ‘뮤직 KOI’에서 가수의 출연 순서...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #위상정렬조건            시간 제한      메모리 제한                  1 초      128 MB      문제인터넷 방송 KOI(Korea Open Internet)의 음악 프로그램 PD인 남일이는 자기가 맡은 프로그램 ‘뮤직 KOI’에서 가수의 출연 순서를 정하는 일을 매우 골치 아파한다. 순서를 정하기 위해서는 많은 조건을 따져야 한다.그래서 오늘 출연 예정인 여섯 팀의 가수에 대해서 남일이가 보조 PD 세 명에게 각자 담당한 가수의 출연 순서를 정해오게 하였다. 보조 PD들이 가져온 것은 아래와 같다.  1 4 3  6 2 5 4  2 3첫 번째 보조 PD는 1번 가수가 먼저, 다음에 4번 가수, 다음에 3번 가수가 출연하기로 순서를 정했다. 두 번째 보조 PD는 6번, 2번, 5번, 4번 순으로 자기 담당 가수들의 순서를 정했다. 한 가수를 여러 보조 PD가 담당할 수도 있다. 마지막으로, 세 번째 보조 PD는 2번 먼저, 다음에 3번으로 정했다.남일이가 할 일은 이 순서들을 모아서 전체 가수의 순서를 정하는 것이다. 남일이는 잠시 생각을 하더니 6 2 1 5 4 3으로 순서를 정했다. 이렇게 가수 순서를 정하면 세 보조 PD가 정해온 순서를 모두 만족한다. 물론, 1 6 2 5 4 3으로 전체 순서를 정해도 괜찮다.경우에 따라서 남일이가 모두를 만족하는 순서를 정하는 것이 불가능할 수도 있다. 예를 들어, 세 번째 보조 PD가 순서를 2 3 대신에 3 2로 정해오면 남일이가 전체 순서를 정하는 것이 불가능하다. 이번에 남일이는 우리 나라의 월드컵 4강 진출 기념 음악제의 PD를 맡게 되었는데, 출연 가수가 아주 많다. 이제 여러분이 해야 할 일은 보조 PD들이 가져 온 순서들을 보고 남일이가 가수 출연 순서를 정할 수 있도록 도와 주는 일이다.보조 PD들이 만든 순서들이 입력으로 주어질 때, 전체 가수의 순서를 정하는 프로그램을 작성하시오.입력첫째 줄에는 가수의 수 N과 보조 PD의 수 M이 주어진다. 가수는 번호 1, 2,…,N 으로 표시한다. 둘째 줄부터 각 보조 PD가 정한 순서들이 한 줄에 하나씩 나온다. 각 줄의 맨 앞에는 보조 PD가 담당한 가수의 수가 나오고, 그 뒤로는 그 가수들의 순서가 나온다. N은 1이상 1,000이하의 정수이고, M은 1이상 100이하의 정수이다.출력출력은 N 개의 줄로 이뤄지며, 한 줄에 하나의 번호를 출력한 다. 이들은 남일이가 정한 가수들의 출연 순서를 나타낸다. 답이 여럿일 경우에는 아무거나 하나를 출력 한다. 만약 남일이가 순서를 정하는 것이 불가능할 경우에는 첫째 줄에 0을 출력한다.예제 입출력 1입력6 33 1 4 34 6 2 5 42 2 3출력621543코드(파이썬)from collections import dequeimport sysn, m = map(int, sys.stdin.readline().split())singers = {i:list() for i in range(1, n+1)}d = [0] * (n+1)result = list()for _ in range(m):    num, *orders = map(int, sys.stdin.readline().split())        for i in range(1, num):        if orders[i] not in singers[orders[i-1]]:            singers[orders[i-1]].append(orders[i])            d[orders[i]] += 1        queue = deque([i for i in range(1, n+1) if d[i] == 0])while queue:    now = queue.popleft()    result.append(now)        for next_ in singers[now]:        d[next_] -= 1                if d[next_] == 0:            queue.append(next_)            if all(i == 0 for i in d):    print(*result, sep=\"\\n\")else:    print(0)특이사항  위상정렬 문제  파이썬 내장 모듈 중 graphlib 발견 (3.9 이상에서 사용 가능)          graphlib.TopologicalSorter(graph=None) : 해시 가능 노드 그래프의 위상 정렬 기능 제공                  add(node, *predecessors): 새 노드와 선행 노드 추가          static_order(): 위상정렬된 iterable 객체 반환          순환이 감지되면 CycleError 발생          예시            import graphlibgraph = {\"D\": {\"B\", \"C\"}, \"C\": {\"A\"}, \"B\": {\"A\"}}ts = TopologicalSorter(graph)tuple(ts.static_order())    # ('A', 'C', 'B', 'D')                                          참고문헌-"
  },
  
  {
    "title": "백준 15686번 치킨 배달",
    "url": "/posts/0095_boj_15686/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 백트래킹(backtracking), 브루트포스(bruteforce)",
    "date": "2022-06-16 21:53:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #브루트포스 #백트래킹조건            시간 제한      메모리 제한                  1 초      512 MB      문제크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #브루트포스 #백트래킹조건            시간 제한      메모리 제한                  1 초      512 MB      문제크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 “치킨 거리”라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.0 2 0 1 01 0 1 0 00 0 0 0 00 0 0 1 10 0 0 1 20은 빈 칸, 1은 집, 2는 치킨집이다.(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6, (5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는  치킨집의 개수는 최대 M개라는 사실을 알아내었다.도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.입력첫째 줄에 N(2 ≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.출력첫째 줄에 폐업시키지 않을 치킨집을 최대 M개를 골랐을 때, 도시의 치킨 거리의 최솟값을 출력한다.예제 입출력 1입력5 30 0 1 0 00 0 2 0 10 1 2 0 00 0 1 0 00 0 0 0 2출력5예제 입출력 2입력5 20 2 0 1 01 0 1 0 00 0 0 0 02 0 0 1 12 2 0 1 2출력10예제 입출력 3입력5 11 2 0 0 01 2 0 0 01 2 0 0 01 2 0 0 01 2 0 0 0출력11예제 입출력 4입력5 11 2 0 2 11 2 0 2 11 2 0 2 11 2 0 2 11 2 0 2 1출력32코드(파이썬)from itertools import combinationsn, m = map(int, input().split())cities = [tuple(map(int, input().split())) for _ in range(n)]chickens = [(i, j) for j in range(n) for i in range(n) if cities[i][j] == 2]houses = [(i, j) for j in range(n) for i in range(n) if cities[i][j] == 1]cnt_house = len(houses)cnt_chicken = len(chickens)chicken_len = [[0] * cnt_house for _ in range(cnt_chicken)]result = 101 * 101for i in range(cnt_chicken):    for j in range(cnt_house):        chicken_len[i][j] = abs(chickens[i][0]-houses[j][0]) + abs(chickens[i][1]-houses[j][1])for candidate in tuple(combinations(range(cnt_chicken), m)):    result = min(result, sum([min([chicken_len[j][i] for j in candidate]) for i in range(cnt_house)]))print(result)특이사항  백트래킹을 활용하라는 문제였지만 놀랍게도 백트래킹 없이 구현 성공  해결방법          집과 치킨집의 좌표를 houses와 chickens 리스트에 저장      모든 집과 치킨집의 거리를 chicken_len 리스트에 저장(행: 치킨집, 열: 집)      치킨집의 모든 조합을 계산      각 조합의 치킨집들의 거리를 계산      참고문헌-"
  },
  
  {
    "title": "백준 2448번 별 찍기 - 11",
    "url": "/posts/0094_boj_2448/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 재귀(recursion)",
    "date": "2022-06-15 21:53:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #재귀조건            시간 제한      메모리 제한                  1 초      256 MB      문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.입력첫째 줄에 N이 주어진다. N은 항상 3×2k 수이다. (3, 6, 12, 24, 48, …) (0 ≤ k ≤...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #재귀조건            시간 제한      메모리 제한                  1 초      256 MB      문제예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.입력첫째 줄에 N이 주어진다. N은 항상 3×2k 수이다. (3, 6, 12, 24, 48, …) (0 ≤ k ≤ 10, k는 정수)출력첫째 줄부터 N번째 줄까지 별을 출력한다.예제 입출력 1입력24출력                       *                                              * *                                            *****                                          *     *                                        * *   * *                                      ***** *****                                    *           *                                  * *         * *                                *****       *****                              *     *     *     *                            * *   * *   * *   * *                          ***** ***** ***** *****                        *                       *                      * *                     * *                    *****                   *****                  *     *                 *     *                * *   * *               * *   * *              ***** *****             ***** *****            *           *           *           *          * *         * *         * *         * *        *****       *****       *****       *****      *     *     *     *     *     *     *     *    * *   * *   * *   * *   * *   * *   * *   * *  ***** ***** ***** ***** ***** ***** ***** *****코드(파이썬)import sysdef pattern(num, i, j):    if num == 3:        for x, y in tri:            result[x+i][y+j] = \"*\"    else:        pattern(num//2, i, j+num//2)        pattern(num//2, i+num//2, j)        pattern(num//2, i+num//2, j+num)n = int(input())result = [[\" \"] * (n//3 * 5 + n//3 - 1) for _ in range(n)]tri = ((0,2), (1,1), (1,3), (2,0), (2,1), (2,2), (2,3), (2,4))pattern(n, 0, 0)sys.stdout.write(\"\\n\".join([\"\".join(row) for row in result]))특이사항  재귀 문제였지만 생각보다 많은 메모리와 시간 소모에 아쉬움을 느낌  내 코드(211,408KB, 700ms)에 비해 우수한 코드(바로가기, 71,624KB, 128ms)와 비교                  import sysdef solution(N):    if N == 3:        return [\"  *  \", \" * * \", \"*****\"]    nn = N // 2    star = []    sub = solution(nn)    for i in range(nn):        star.append(f'{\" \" * nn}{sub[i]}{\" \" * nn}')    for i in range(nn):        star.append(f'{sub[i]} {sub[i]}')    return starIN = int(sys.stdin.readline())print(\"\\n\".join(solution(IN)))                    재귀 함수                  기존: 2차원 리스트 생성 이후 각 요소마다 * 문자로 변경          개선: star 리스트에 각 줄을 저장하고 반환                    참고문헌-"
  },
  
  {
    "title": "백준 2252번 줄 세우기",
    "url": "/posts/0093_boj_2252/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 위상정렬(topology_sort)",
    "date": "2022-06-14 08:59:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #위상정렬조건            시간 제한      메모리 제한                  2 초      128 MB      문제N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #위상정렬조건            시간 제한      메모리 제한                  2 초      128 MB      문제N명의 학생들을 키 순서대로 줄을 세우려고 한다. 각 학생의 키를 직접 재서 정렬하면 간단하겠지만, 마땅한 방법이 없어서 두 학생의 키를 비교하는 방법을 사용하기로 하였다. 그나마도 모든 학생들을 다 비교해 본 것이 아니고, 일부 학생들의 키만을 비교해 보았다.일부 학생들의 키를 비교한 결과가 주어졌을 때, 줄을 세우는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 32,000), M(1 ≤ M ≤ 100,000)이 주어진다. M은 키를 비교한 회수이다. 다음 M개의 줄에는 키를 비교한 두 학생의 번호 A, B가 주어진다. 이는 학생 A가 학생 B의 앞에 서야 한다는 의미이다.학생들의 번호는 1번부터 N번이다.출력첫째 줄에 학생들을 앞에서부터 줄을 세운 결과를 출력한다. 답이 여러 가지인 경우에는 아무거나 출력한다.예제 입출력 1입력3 21 32 3출력1 2 3예제 입출력 2입력4 24 23 1출력4 2 3 1코드(파이썬)from collections import defaultdict, dequeimport sysn, m = map(int, sys.stdin.readline().split())students = defaultdict(list)higher_students = [1] + [0] * (n)for _ in range(m):    high, low = map(int, sys.stdin.readline().split())    students[high].append(low)    higher_students[low] += 1    queue = deque([i for i in range(1, n+1) if higher_students[i] == 0])while queue:    student = queue.popleft()        for next_student in students[student]:        higher_students[next_student] -= 1                if higher_students[next_student] == 0:            queue.append(next_student)                print(student, end=\" \")특이사항  위상정렬을 처음으로 적용한 문제  해결방법          입력에 따라 큰 키를 가진 학생을 부모로, 작은 키를 가진 학생을 자식으로 하는 그래프 생성      위상정렬 진행 후 결과 출력      참고문헌  문병로, 쉽게 배우는 알고리즘 :관계 중심의 사고법, 문병로, 2018  “25. 위상 정렬(Topology Sort)”, 안경잡이개발자, https://m.blog.naver.com/ndb796/221236874984"
  },
  
  {
    "title": "백준 1238번 파티",
    "url": "/posts/0092_boj_1238/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra)",
    "date": "2022-06-09 22:05:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1 초      128 MB      문제N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1 초      128 MB      문제N개의 숫자로 구분된 각각의 마을에 한 명의 학생이 살고 있다.어느 날 이 N명의 학생이 X (1 ≤ X ≤ N)번 마을에 모여서 파티를 벌이기로 했다. 이 마을 사이에는 총 M개의 단방향 도로들이 있고 i번째 길을 지나는데 Ti(1 ≤ Ti ≤ 100)의 시간을 소비한다.각각의 학생들은 파티에 참석하기 위해 걸어가서 다시 그들의 마을로 돌아와야 한다. 하지만 이 학생들은 워낙 게을러서 최단 시간에 오고 가기를 원한다.이 도로들은 단방향이기 때문에 아마 그들이 오고 가는 길이 다를지도 모른다. N명의 학생들 중 오고 가는데 가장 많은 시간을 소비하는 학생은 누구일지 구하여라.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 10,000), X가 공백으로 구분되어 입력된다. 두 번째 줄부터 M+1번째 줄까지 i번째 도로의 시작점, 끝점, 그리고 이 도로를 지나는데 필요한 소요시간 Ti가 들어온다. 시작점과 끝점이 같은 도로는 없으며, 시작점과 한 도시 A에서 다른 도시 B로 가는 도로의 개수는 최대 1개이다.모든 학생들은 집에서 X에 갈수 있고, X에서 집으로 돌아올 수 있는 데이터만 입력으로 주어진다.출력첫 번째 줄에 N명의 학생들 중 오고 가는데 가장 오래 걸리는 학생의 소요시간을 출력한다.예제 입출력 1입력4 8 21 2 41 3 21 4 72 1 12 3 53 1 23 4 44 2 3출력10코드(파이썬)from collections import defaultdictimport heapqimport sysn, m, x = map(int, sys.stdin.readline().split())towns = defaultdict(list)towns_re = defaultdict(list)for _ in range(m):    s, e, w = map(int, sys.stdin.readline().split())        towns[s].append((w, e))    towns_re[e].append((-w, s))d = [1010000] * (n+1)d[x] = 0queue = [[0, x]]while queue:    weight, town = heapq.heappop(queue)    if d[town] &gt;= weight:        for next_weight, next_town in towns[town]:            if next_weight+weight &lt; d[next_town]:                d[next_town] = next_weight + weight                heapq.heappush(queue, (d[next_town], next_town))d2 = [1010000] * (n+1)d2[x] = 0queue = [[0, x]]while queue:    weight, town = heapq.heappop(queue)    weight = -weight        if d2[town] &gt;= weight:        for next_weight, next_town in towns_re[town]:                        next_weight = -next_weight            if next_weight+weight &lt; d2[next_town]:                d2[next_town] = next_weight + weight                heapq.heappush(queue, (-d2[next_town], next_town))print(max([d[i] + d2[i] for i in range(1, n+1)]))특이사항  해결방법          x 도시에서 다른 도시까지의 최단경로를 다익스트라로 계산      다른 도시에서 x 도시까지의 최단경로를 town_re를 통해 다익스트라를 반대로 활용해서 계산        내 코드(33,984KB, 664ms)에 비해 우수한 코드(바로가기, 33,932KB, 104ms)와 비교                  import collectionsimport heapqimport sysdef djikstra(lists,start):    hq = []    heapq.heappush(hq,[0,start])    inf = int(1e9)    res = [inf]*(n+1)    res[start] = 0    while hq:        ex = heapq.heappop(hq)        if ex[0] &gt; res[ex[1]]:            continue        for price,go in lists[ex[1]]:            cost = ex[0] + price            if cost &lt; res[go]:                res[go] = cost                heapq.heappush(hq,[cost,go])    return res[1:]n,m,x = map(int,sys.stdin.readline().split())distance_x = [[] for _ in range(n+1)]distance_y = [[] for _ in range(n+1)]for i in range(m):    a,b,c = map(int,sys.stdin.readline().split())    distance_x[a].append([c,b])    distance_y[b].append([c,a])        go_x = djikstra(distance_x,x)go_home = djikstra(distance_y,x)print(max([x+y for x,y in zip(go_x,go_home)]))                    목적지 -&gt; 모든 노드 다익스트라 적용                  기존: 도시간 거리에 - 연산 추가          개선: 도시간 거리를 그대로 사용                    참고문헌-"
  },
  
  {
    "title": "백준 2589번 보물섬",
    "url": "/posts/0091_boj_2589/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 브루트포스(bruteforce), 너비우선탐색(breadth_first_search)",
    "date": "2022-06-07 22:25:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #브루트포스 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      512 MB      문제보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #브루트포스 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      512 MB      문제보물섬 지도를 발견한 후크 선장은 보물을 찾아나섰다. 보물섬 지도는 아래 그림과 같이 직사각형 모양이며 여러 칸으로 나뉘어져 있다. 각 칸은 육지(L)나 바다(W)로 표시되어 있다. 이 지도에서 이동은 상하좌우로 이웃한 육지로만 가능하며, 한 칸 이동하는데 한 시간이 걸린다. 보물은 서로 간에 최단 거리로 이동하는데 있어 가장 긴 시간이 걸리는 육지 두 곳에 나뉘어 묻혀있다. 육지를 나타내는 두 곳 사이를 최단 거리로 이동하려면 같은 곳을 두 번 이상 지나가거나, 멀리 돌아가서는 안 된다.예를 들어 위와 같이 지도가 주어졌다면 보물은 아래 표시된 두 곳에 묻혀 있게 되고, 이 둘 사이의 최단 거리로 이동하는 시간은 8시간이 된다.보물 지도가 주어질 때, 보물이 묻혀 있는 두 곳 간의 최단 거리로 이동하는 시간을 구하는 프로그램을 작성하시오.입력첫째 줄에는 보물 지도의 세로의 크기와 가로의 크기가 빈칸을 사이에 두고 주어진다. 이어 L과 W로 표시된 보물 지도가 아래의 예와 같이 주어지며, 각 문자 사이에는 빈 칸이 없다. 보물 지도의 가로, 세로의 크기는 각각 50이하이다.출력첫째 줄에 보물이 묻혀 있는 두 곳 사이를 최단 거리로 이동하는 시간을 출력한다.예제 입출력 1입력5 7WLLWWWLLLLWLLLLWLWLWWLWLWLLLWLLWLWW출력8코드(파이썬)from collections import dequedef bfs(y, x):    queue = deque([[y, x]])    visited = [[0] * m for _ in range(n)]    visited[y][x] = 1    cnt = 0        while queue:        for _ in range(len(queue)):            now_y, now_x = queue.popleft()                            for i in range(4):                next_x = now_x + dx[i]                next_y = now_y + dy[i]                            if 0 &lt;= next_x &lt; m and 0 &lt;= next_y &lt; n and treasure[next_y][next_x] and visited[next_y][next_x] == 0:                    visited[next_y][next_x] = 1                    queue.append((next_y, next_x))        cnt += 1            return cnt-1n, m = map(int, input().split())dx = [1, -1, 0, 0]dy = [0, 0, 1, -1]treasure = [[1 if ch == \"L\" else 0 for ch in input().rstrip()] for _ in range(n)]shortest = 0for i in range(n):    for j in range(m):        if treasure[i][j]:            shortest = max(shortest, bfs(i, j))            print(shortest)특이사항  해결방법          단순한 BFS를 최적화해서 해결        BFS 의사코드를 확인하고 그동안 잘못 사용했던 부분을 수정함참고문헌-"
  },
  
  {
    "title": "백준 17070번 파이프 옮기기1",
    "url": "/posts/0090_boj_17070/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-06-03 21:32:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      512 MB      문제유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초(추가 시간 없음)      512 MB      문제유현이가 새 집으로 이사했다. 새 집의 크기는 N×N의 격자판으로 나타낼 수 있고, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 (r, c)로 나타낼 수 있다. 여기서 r은 행의 번호, c는 열의 번호이고, 행과 열의 번호는 1부터 시작한다. 각각의 칸은 빈 칸이거나 벽이다.오늘은 집 수리를 위해서 파이프 하나를 옮기려고 한다. 파이프는 아래와 같은 형태이고, 2개의 연속된 칸을 차지하는 크기이다.파이프는 회전시킬 수 있으며, 아래와 같이 3가지 방향이 가능하다.파이프는 매우 무겁기 때문에, 유현이는 파이프를 밀어서 이동시키려고 한다. 벽에는 새로운 벽지를 발랐기 때문에, 파이프가 벽을 긁으면 안 된다. 즉, 파이프는 항상 빈 칸만 차지해야 한다.파이프를 밀 수 있는 방향은 총 3가지가 있으며, →, ↘, ↓ 방향이다. 파이프는 밀면서 회전시킬 수 있다. 회전은 45도만 회전시킬 수 있으며, 미는 방향은 오른쪽, 아래, 또는 오른쪽 아래 대각선 방향이어야 한다.파이프가 가로로 놓여진 경우에 가능한 이동 방법은 총 2가지, 세로로 놓여진 경우에는 2가지, 대각선 방향으로 놓여진 경우에는 3가지가 있다.아래 그림은 파이프가 놓여진 방향에 따라서 이동할 수 있는 방법을 모두 나타낸 것이고, 꼭 빈 칸이어야 하는 곳은 색으로 표시되어져 있다.가로세로대각선가장 처음에 파이프는 (1, 1)와 (1, 2)를 차지하고 있고, 방향은 가로이다. 파이프의 한쪽 끝을 (N, N)로 이동시키는 방법의 개수를 구해보자.입력첫째 줄에 집의 크기 N(3 ≤ N ≤ 16)이 주어진다. 둘째 줄부터 N개의 줄에는 집의 상태가 주어진다. 빈 칸은 0, 벽은 1로 주어진다. (1, 1)과 (1, 2)는 항상 빈 칸이다.출력첫째 줄에 파이프의 한쪽 끝을 (N, N)으로 이동시키는 방법의 수를 출력한다. 이동시킬 수 없는 경우에는 0을 출력한다. 방법의 수는 항상 1,000,000보다 작거나 같다.예제 입출력 1입력30 0 00 0 00 0 0출력1예제 입출력 2입력40 0 0 00 0 0 00 0 0 00 0 0 0출력3예제 입출력 3입력50 0 1 0 00 0 0 0 00 0 0 0 00 0 0 0 00 0 0 0 0출력0예제 입출력 4입력60 0 0 0 0 00 1 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0출력13코드(파이썬)n = int(input())house = [list(map(int, input().split())) for _ in range(n)]house_state = [[[0, 0, 0] for _ in range(n+1)] for _ in range(n+1)]house_state[1][2][0] = 1for i in range(n):    for j in range(2, n):        house_state[i+1][j+1][0] = 0 if house[i][j-1] or house[i][j] else house_state[i+1][j][0] + house_state[i+1][j][1]        house_state[i+1][j+1][1] = 0 if i &lt; 1 or house[i-1][j] or house[i][j-1] or house[i][j] else sum(house_state[i][j])        house_state[i+1][j+1][2] = 0 if i &lt; 1 or house[i-1][j] or house[i][j] else house_state[i][j+1][1] + house_state[i][j+1][2]print(sum(house_state[n][n]))특이사항  해결방법          3차원 리스트를 활용한 다이나믹 프로그래밍      참고문헌-"
  },
  
  {
    "title": "백준 1451번 직사각형으로 나누기",
    "url": "/posts/0089_boj_1451/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 누적합(prefix_sum), 브루트포스(bruteforce), 많은 조건 분기(many_conditional_branches)",
    "date": "2022-05-30 21:08:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #누적합 #브루트포스 #많은 조건 분기조건            시간 제한      메모리 제한                  2 초      128 MB      문제세준이는 NM크기로 직사각형에 수를 NM개 써놓았다.세준이는 이 직사각형을 겹치지 않는 3개의 작은 직사각형으로 나누려고 한다. 각...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #누적합 #브루트포스 #많은 조건 분기조건            시간 제한      메모리 제한                  2 초      128 MB      문제세준이는 NM크기로 직사각형에 수를 NM개 써놓았다.세준이는 이 직사각형을 겹치지 않는 3개의 작은 직사각형으로 나누려고 한다. 각각의 칸은 단 하나의 작은 직사각형에 포함되어야 하고, 각각의 작은 직사각형은 적어도 하나의 숫자를 포함해야 한다.어떤 작은 직사각형의 합은 그 속에 있는 수의 합이다. 입력으로 주어진 직사각형을 3개의 작은 직사각형으로 나누었을 때, 각각의 작은 직사각형의 합의 곱을 최대로 하는 프로그램을 작성하시오.입력첫째 줄에 직사각형의 세로 크기 N과 가로 크기 M이 주어진다. 둘째 줄부터 직사각형에 들어가는 수가 가장 윗 줄부터 한 줄에 하나씩 M개의 수가 주어진다. N과 M은 50보다 작거나 같은 자연수이고, 직사각형엔 적어도 3개의 수가 있다. 또, 직사각형에 들어가는 수는 한 자리의 숫자이다.출력세 개의 작은 직사각형의 합의 곱의 최댓값을 출력한다.예제 입출력 1입력1 811911103출력108예제 입출력 2입력3 3123456789출력3264예제 입출력 3입력3 1793출력189코드(파이썬)n, m = map(int, input().split())squares = [list(map(int, list(input()))) for _ in range(n)]result = 0# 6가지 형태 존재# ││ / ㅏ / ㅓ# =  / ㅗ / ㅜfor i in range(1, m):    left = sum([sum(line[:i]) for line in squares])    for j in range(i+1, m):        middle = sum([sum(line[i:j]) for line in squares])        right = sum([sum(line[j:]) for line in squares])        result = max(result, left*middle*right)    for k in range(1, n):        top = sum([sum(line[i:]) for line in squares[:k]])        bottom = sum([sum(line[i:]) for line in squares[k:]])        result = max(result, left*top*bottom)for i in range(1, m):    right = sum([sum(line[i:]) for line in squares])    for k in range(1, n):        top = sum([sum(line[:i]) for line in squares[:k]])        bottom = sum([sum(line[:i]) for line in squares[k:]])        result = max(result, right*top*bottom)        for i in range(1, n):    top = sum([sum(line) for line in squares[:i]])    for j in range(i+1, n):        middle = sum([sum(line) for line in squares[i:j]])        bottom = sum([sum(line) for line in squares[j:]])        result = max(result, top*middle*bottom)    for k in range(1, n):        left = sum([sum(line[:k]) for line in squares[i:]])        right = sum([sum(line[k:]) for line in squares[i:]])        result = max(result, top*left*right)for i in range(1, n):    bottom = sum([sum(line) for line in squares[i:]])    for k in range(1, m):        left = sum([sum(line[:k]) for line in squares[:i]])        right = sum([sum(line[k:]) for line in squares[:i]])        result = max(result, bottom*left*right)        print(result)특이사항  해결방법          다익스트라를 이용      현재 방문 도시까지의 경로를 path 리스트에 저장      도착점에 도달하게 된다면 도착점까지의 경로를 출력        내 코드(30,840KB, 356ms)에 비해 우수한 코드(바로가기, 30,864KB, 80ms)와 비교                  import sysN, M = map(int, sys.stdin.readline().split())cum = [[0]*(M+1) for _ in range(N+1)] # cumulative sumfor i in range(1, N+1):    for j, val in enumerate(map(int, sys.stdin.readline().rstrip()), 1):        cum[i][j] = val + cum[i-1][j] + cum[i][j-1] - cum[i-1][j-1]cardinal = 0for i in range(1, N):    for j in range(1, M):        up = cum[i][j] * (cum[i][M] - cum[i][j]) * (cum[N][M] - cum[i][M])        down = cum[i][M] * (cum[N][j] - cum[i][j]) * (cum[N][M] - cum[i][M] - cum[N][j] + cum[i][j])        left = cum[i][j] * (cum[N][j] - cum[i][j]) * (cum[N][M] - cum[N][j])        right = cum[N][j] * (cum[i][M] - cum[i][j]) * (cum[N][M] - cum[i][M] - cum[N][j] + cum[i][j])        cardinal = max(cardinal, up, down, left, right)horizontal = 0for i1 in range(1, N-1):    for i2 in range(i1+1, N):        horizontal = max(horizontal, cum[i1][M] * (cum[i2][M] - cum[i1][M]) * (cum[N][M] - cum[i2][M]))vertical = 0for j1 in range(1, M-1):    for j2 in range(j1+1, M):        vertical = max(vertical, cum[N][j1] * (cum[N][j2] - cum[N][j1]) * (cum[N][M] - cum[N][j2]))print(max(cardinal, horizontal, vertical))                    직사각형 넓이 계산                  기존: 반복문을 이용해 계산          개선: cum 리스트에 넓이 저장                    참고문헌-"
  },
  
  {
    "title": "백준 11779번 최소비용 구하기2",
    "url": "/posts/0088_boj_11779/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra)",
    "date": "2022-05-27 23:41:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1 초      256 MB      문제n(1≤n≤1,000)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1≤m≤100,000)개의 버스가 있다. 우리는 A...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1 초      256 MB      문제n(1≤n≤1,000)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1≤m≤100,000)개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. 그러면 A번째 도시에서 B번째 도시 까지 가는데 드는 최소비용과 경로를 출력하여라. 항상 시작점에서 도착점으로의 경로가 존재한다.입력첫째 줄에 도시의 개수 n(1≤n≤1,000)이 주어지고 둘째 줄에는 버스의 개수 m(1≤m≤100,000)이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.그리고 m+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다.출력첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.둘째 줄에는 그러한 최소 비용을 갖는 경로에 포함되어있는 도시의 개수를 출력한다. 출발 도시와 도착 도시도 포함한다.셋째 줄에는 최소 비용을 갖는 경로를 방문하는 도시 순서대로 출력한다.예제 입출력 1입력581 2 21 3 31 4 11 5 102 4 23 4 13 5 14 5 31 5출력431 3 5코드(파이썬)from collections import defaultdictimport heapqimport sysn = int(sys.stdin.readline())m = int(sys.stdin.readline())graph = defaultdict(dict)for _ in range(m):    node1, node2, w = map(int, sys.stdin.readline().split())        graph[node1][node2] = min(graph[node1][node2], w) if node2 in graph[node1] else w        start, end = map(int, sys.stdin.readline().split())if start == end:    print(0)    print(graph[start][start])    print(start)else:    not_visited = [0] + [1] * 1000    d = [1000000001] * (n+1)    path = [list()] * 1001    path[start] = [start]    queue = [(0, start)]    d[start] = 0    while not_visited[end]:        now_w, now_n = heapq.heappop(queue)        if not_visited[now_n]:            not_visited[now_n] = 0            for next_n, next_w in graph[now_n].items():                if next_n != now_n and d[next_n] &gt; d[now_n] + next_w:                    path[next_n] = path[now_n] + [next_n]                    d[next_n] = d[now_n] + next_w                    heapq.heappush(queue, (d[next_n], next_n))                            print(d[end])    print(len(path[end]))    print(*path[end])특이사항  해결방법          다익스트라를 이용      현재 방문 도시까지의 경로를 path 리스트에 저장      도착점에 도달하게 된다면 도착점까지의 경로를 출력      참고문헌-"
  },
  
  {
    "title": "백준 1043번 거짓말",
    "url": "/posts/0087_boj_1043/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 자료구조(data_structure), 분리 집합(disjoint_set)",
    "date": "2022-05-24 21:39:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #분리 집합 #자료구조조건            시간 제한      메모리 제한                  2 초      128 MB      문제지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #분리 집합 #자료구조조건            시간 제한      메모리 제한                  2 초      128 MB      문제지민이는 파티에 가서 이야기 하는 것을 좋아한다. 파티에 갈 때마다, 지민이는 지민이가 가장 좋아하는 이야기를 한다. 지민이는 그 이야기를 말할 때, 있는 그대로 진실로 말하거나 엄청나게 과장해서 말한다. 당연히 과장해서 이야기하는 것이 훨씬 더 재미있기 때문에, 되도록이면 과장해서 이야기하려고 한다. 하지만, 지민이는 거짓말쟁이로 알려지기는 싫어한다. 문제는 몇몇 사람들은 그 이야기의 진실을 안다는 것이다. 따라서 이런 사람들이 파티에 왔을 때는, 지민이는 진실을 이야기할 수 밖에 없다. 당연히, 어떤 사람이 어떤 파티에서는 진실을 듣고, 또다른 파티에서는 과장된 이야기를 들었을 때도 지민이는 거짓말쟁이로 알려지게 된다. 지민이는 이런 일을 모두 피해야 한다.사람의 수 N이 주어진다. 그리고 그 이야기의 진실을 아는 사람이 주어진다. 그리고 각 파티에 오는 사람들의 번호가 주어진다. 지민이는 모든 파티에 참가해야 한다. 이때, 지민이가 거짓말쟁이로 알려지지 않으면서, 과장된 이야기를 할 수 있는 파티 개수의 최댓값을 구하는 프로그램을 작성하시오.입력첫째 줄에 사람의 수 N과 파티의 수 M이 주어진다.둘째 줄에는 이야기의 진실을 아는 사람의 수와 번호가 주어진다. 진실을 아는 사람의 수가 먼저 주어지고 그 개수만큼 사람들의 번호가 주어진다. 사람들의 번호는 1부터 N까지의 수로 주어진다.셋째 줄부터 M개의 줄에는 각 파티마다 오는 사람의 수와 번호가 같은 방식으로 주어진다.N, M은 50 이하의 자연수이고, 진실을 아는 사람의 수는 0 이상 50 이하의 정수, 각 파티마다 오는 사람의 수는 1 이상 50 이하의 정수이다.출력첫째 줄에 문제의 정답을 출력한다.예제 입출력 1입력4 302 1 21 33 2 3 4출력3예제 입출력 2입력4 11 14 1 2 3 4출력0예제 입출력 3입력4 104 1 2 3 4출력1예제 입출력 4입력4 51 11 11 21 31 42 4 1출력2예제 입출력 5입력10 94 1 2 3 42 1 52 2 61 71 82 7 81 91 102 3 101 4출력4예제 입출력 6입력8 53 1 2 72 3 41 52 5 62 6 81 8출력5예제 입출력 7입력3 41 31 11 22 1 23 1 2 3출력0코드(파이썬)def find(node):    if parents[node] != node:        parents[node] = find(parents[node])            return parents[node]def union(n1, n2):    r1 = find(n1)    r2 = find(n2)        if r1 != r2:        if r1 &lt; r2:            parents[r2] = r1        else:            parents[r1] = r2            n, m = map(int, input().split())known_input = tuple(map(int, input().split()))parents = [i for i in range(n+1)]if known_input[0] == 0:    for _ in range(m):        input()    result = melse:    known = min(known_input[1:])    parties = list()        for i in known_input[1:]:        parents[i] = known        for _ in range(m):        cnt, *people = list(map(int, input().split()))                for i in range(cnt-1):            union(people[i], people[i+1])        parties.append(find(people[0]))            known_root = find(known)            result = sum([1 for party in parties if find(party) != known_root])print(result)특이사항  해결방법          각 파티의 사람들을 하나의 집합으로 합연산      사실을 아는 사람들의 집합을 확인      각 파티의 집합과 사실을 아는 사람의 집합을 비교      참고문헌-"
  },
  
  {
    "title": "백준 12851번 숨바꼭질 2",
    "url": "/posts/0086_boj_12851/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-05-24 21:39:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.예제 입출력 1입력5 17출력42코드(파이썬)from collections import dequen, k = map(int, input().split())queue = deque([n])v = [1] * (100001)cnt = 0while queue and k not in queue:    tmp_v = set()    for _ in range(len(queue)):        now = queue.popleft()        if v[now]:            tmp_v.add(now)                        if now &gt; 0 and v[now-1]:                queue.append(now-1)            if now &lt; 100000 and v[now+1]:                queue.append(now+1)                        if now*2 &lt;= 100000 and v[now*2]:                queue.append(now*2)        for i in tmp_v:        v[i] = 0    cnt += 1print(cnt)print(queue.count(k))특이사항  해결방법          BFS를 이용해 트리의 층마다 탐색      다음 탐색 예정 큐에 k 값이 있다면 종료      참고문헌-"
  },
  
  {
    "title": "백준 9466번 텀 프로젝트",
    "url": "/posts/0085_boj_9466/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search)",
    "date": "2022-05-23 21:39:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  3 초      256 MB      문제이번 가을학기에 ‘문제 해결’ 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  3 초      256 MB      문제이번 가을학기에 ‘문제 해결’ 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 모든 학생들이 동일한 팀의 팀원인 경우와 같이 한 팀만 있을 수도 있다. 프로젝트 팀을 구성하기 위해, 모든 학생들은 프로젝트를 함께하고 싶은 학생을 선택해야 한다. (단, 단 한 명만 선택할 수 있다.) 혼자 하고 싶어하는 학생은 자기 자신을 선택하는 것도 가능하다.학생들이(s1, s2, …, sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,…, sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.예를 들어, 한 반에 7명의 학생이 있다고 하자. 학생들을 1번부터 7번으로 표현할 때, 선택의 결과는 다음과 같다.            1      2      3      4      5      6      7                  3      1      3      7      3      4      6      위의 결과를 통해 (3)과 (4, 7, 6)이 팀을 이룰 수 있다. 1, 2, 5는 어느 팀에도 속하지 않는다.주어진 선택의 결과를 보고 어느 프로젝트 팀에도 속하지 않는 학생들의 수를 계산하는 프로그램을 작성하라.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫 줄에는 학생의 수가 정수 n (2 ≤ n ≤ 100,000)으로 주어진다. 각 테스트 케이스의 둘째 줄에는 선택된 학생들의 번호가 주어진다. (모든 학생들은 1부터 n까지 번호가 부여된다.)출력각 테스트 케이스마다 한 줄에 출력하고, 각 줄에는 프로젝트 팀에 속하지 못한 학생들의 수를 나타내면 된다.예제 입출력 1입력273 1 3 7 3 4 681 2 3 4 5 6 7 8출력30코드(파이썬)from collections import OrderedDictimport syssys.setrecursionlimit(10**5+2)def dfs(num):    next_num = students[num]        if v[num]:        return cycle[num]    v[num] = 1    if next_num in stack:        tmp, _ = stack.popitem()                while tmp != next_num and stack:            cycle[tmp] = 1            tmp, _ = stack.popitem()                    cycle[tmp] = 1        return False    stack[next_num] = None    if dfs(next_num):        stack.popitem()        return True    else:        return False        t = int(sys.stdin.readline())for _ in range(t):    n = int(sys.stdin.readline())    students = list(map(lambda x:int(x)-1, sys.stdin.readline().split()))    cycle = [0] * n    v = [0] * n    for i in range(n):        if v[i] == 0:            stack = OrderedDict({i:None})            dfs(i)                print(n - sum(cycle))특이사항  해결방법          DFS 이용해 순서대로 접근      싸이클이 있거나 방문한 적이 있다면 종료      stack을 리스트 대신 OrderDict를 사용해 시간 초과 해결…        내 코드(153,916KB, 5,388ms)에 비해 우수한 코드(바로가기, 47,824KB, 2,460ms)와 비교                  from collections import dequeimport sysT = int(input())for _ in range(T):    n = int(input())    want = [0] + list(map(int, sys.stdin.readline().split()))    check = [0] * (n + 1)    result = 0    for i in range(1, n + 1):        check[want[i]] += 1    visit = deque()    for i in range(1, n + 1):        if check[i] == 0:            visit.append(i)    while visit:        result += 1        v = visit.popleft()        check[want[v]] -= 1        if check[want[v]] == 0:            visit.append(want[v])    print(result)                    자료구조                  기존: OrderedDict          개선: 리스트                    인덱스확인                  기존: OrderDict에서 순서대로 popitem          개선: check 리스트에 인덱스 저장                    참고문헌-"
  },
  
  {
    "title": "백준 1620번 나는야 포켓몬 마스터 이다솜",
    "url": "/posts/0084_boj_1620/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 해시를 사용한 집합과 맵(set_and_map_using_hash)",
    "date": "2022-05-20 22:58:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #자료구조 #해시를 사용한 집합과 맵조건            시간 제한      메모리 제한                  2 초      256 MB      문제안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #자료구조 #해시를 사용한 집합과 맵조건            시간 제한      메모리 제한                  2 초      256 MB      문제안녕? 내 이름은 이다솜. 나의 꿈은 포켓몬 마스터야. 일단 포켓몬 마스터가 되기 위해선 포켓몬을 한 마리 잡아야겠지? 근처 숲으로 가야겠어.(뚜벅 뚜벅)얏! 꼬렛이다. 꼬렛? 귀여운데, 나의 첫 포켓몬으로 딱 어울린데? 내가 잡고 말겠어. 가라! 몬스터볼~(펑!) 헐랭… 왜 안 잡히지?ㅜㅜ 몬스터 볼만 던지면 되는 게 아닌가…ㅜㅠ(터벅터벅)어? 누구지?오박사 : 나는 태초마을의 포켓몬 박사 오민식 박사라네. 다솜아, 포켓몬을 잡을 때는, 일단 상대 포켓몬의 체력을 적당히 바닥으로 만들어놓고 몬스터 볼을 던져야 한단다. 자, 내 포켓몬 이상해꽃으로 한번 잡아보렴. 포켓몬의 기술을 쓰는 것을 보고 포켓몬을 줄지 안줄지 결정을 하겠네. 자 한번 해보아라. 다솜아.이다솜 : 이상해꽃이라…음.. 꽃이니깐 왠지 햇빛을 받아서 공격을 할 것 같은데… 음… 이상해꽃! 햇빛공격!!!(꼬렛이 이상해꽃에게 공격을 받아 체력이 25 감소했다.)    가라! 몬스터 볼!!!    (꼬렛을 잡았습니다.)    야호! 신난다. 꼬렛을 잡았다.오박사 : 오우!! 방금 쓴 공격은 솔라빔이라고 하네.. 어떻게 공격을 한 건가? 솔라빔이란 공격에 대해서 공부를 한 건가?이다솜 : 꽃이니깐 왠지 햇빛을 제대로 받으면 광합성을 해서 음.. 그냥 그럴 것 같아서요 ☞☜오박사 : 다른 아이들은 넝쿨채찍이나, 나뭇잎 공격을 하는데, 다솜이는 역시 뭔가 다르구나. 그럼 나와 함께 연구소로 가자꾸나. 내가 포켓몬을 한 마리 줄 테니, 너의 꿈을 펼쳐보아라. 꿈은 이루어진단다.이다솜 : 네! 오박사님, 고마워요.ㅜㅜ오박사 : 가자. 나의 연구소는 너의 옆집의 아랫집이란다. 같이 가도록하자. 지금 포켓몬을 주마.이다솜 : 네. 야호!!오영식 : 어? 오박사님 얘는 누구인가요?오박사 : 얘는 너의 라이벌이 될 친구 이다솜이라고 하네. 자, 포켓몬을 한 마리 골라보도록 해봐라 다솜아. 레이디퍼스트 네가 먼저 골라봐라.이다솜 : 저는 생각해둔 포켓몬이 있어요. 피카츄 골라도 될까요?오박사 : 그래 여기 피카츄가 한 마리 있단다. 피카츄를 가져가거라.오영식 : 그럼 저는 이브이를 가져가겠어요. 그럼 나중에 보자 이다솜.이다솜 : 그럼 꼬렛을 다시 잡으러 가야겠다. 영식아, 그리고 민식박사님 빠잉!이다솜 : 피카츄 공격!가라 몬스터 볼!이다솜 : 야호! 신난다. 꼬렛을 잡았다!!!!!이다솜 : 그럼! 일단 사천왕을 이기고 오겠어!이다솜 : 여기가 사천왕과 대결하려면 가야하는 곳인가..경비원 : 사천왕과 대결을 하려면, 마을의 체육관 리더를 이겨서 배지를 8개를 모아야 한다네… 배지를 모아서 오도록 하게이다솜 : 잉ㅠㅜ… 그럼 배지부터 모아야 하는구나ㅠㅜㅠㅜ 나쁘당 그냥 좀 봐주지..&lt;1 년 후&gt;그동안의 줄거리 : 이다솜은 일단 상록 숲의 체육관 리더에게 도전을 했다. 하지만 상록숲 체육관의 리더는 실종된 상태. 따라서 회색마을부터 도전하기로 했다. 체육관의 리더를 이기면서, 로켓단을 해체시키기도 하고, 여러 가지 사건도 있었다. 결국 전설의 포켓몬도 잡고, 이제 사천왕을 이기려고 도전하기로 했다. 사천왕은 모두 가볍게 이기고, 이제 마지막 라이벌 오!영!식! 이다.오영식 : 훗. 1년 전의 그 이다솜이 사천왕을 이기고 현재 포켓몬 마스터인 나에게 덤벼? 어디 한번 덤벼보시지.이다솜 : 헐랭… 나를 우습게보네…. 한번 두고 보시지! 그럼 대결이닷!이다솜 : 휴… 이겼다.오영식 : 내가 지다니 분하다. ㅜㅜ오박사 : 그럼 다솜아 이제 진정한 포켓몬 마스터가 되기 위해 도감을 완성시키도록 하여라. 일단 네가 현재 가지고 있는 포켓몬 도감에서 포켓몬의 이름을 보면 포켓몬의 번호를 말하거나, 포켓몬의 번호를 보면 포켓몬의 이름을 말하는 연습을 하도록 하여라. 나의 시험을 통과하면, 내가 새로 만든 도감을 주도록 하겠네.입력첫째 줄에는 도감에 수록되어 있는 포켓몬의 개수 N이랑 내가 맞춰야 하는 문제의 개수 M이 주어져. N과 M은 1보다 크거나 같고, 100,000보다 작거나 같은 자연수인데, 자연수가 뭔지는 알지? 모르면 물어봐도 괜찮아. 나는 언제든지 질문에 답해줄 준비가 되어있어.둘째 줄부터 N개의 줄에 포켓몬의 번호가 1번인 포켓몬부터 N번에 해당하는 포켓몬까지 한 줄에 하나씩 입력으로 들어와. 포켓몬의 이름은 모두 영어로만 이루어져있고, 또, 음… 첫 글자만 대문자이고, 나머지 문자는 소문자로만 이루어져 있어. 아참! 일부 포켓몬은 마지막 문자만 대문자일 수도 있어. 포켓몬 이름의 최대 길이는 20, 최소 길이는 2야. 그 다음 줄부터 총 M개의 줄에 내가 맞춰야하는 문제가 입력으로 들어와. 문제가 알파벳으로만 들어오면 포켓몬 번호를 말해야 하고, 숫자로만 들어오면, 포켓몬 번호에 해당하는 문자를 출력해야해. 입력으로 들어오는 숫자는 반드시 1보다 크거나 같고, N보다 작거나 같고, 입력으로 들어오는 문자는 반드시 도감에 있는 포켓몬의 이름만 주어져. 그럼 화이팅!!!출력첫째 줄부터 차례대로 M개의 줄에 각각의 문제에 대한 답을 말해줬으면 좋겠어!!!. 입력으로 숫자가 들어왔다면 그 숫자에 해당하는 포켓몬의 이름을, 문자가 들어왔으면 그 포켓몬의 이름에 해당하는 번호를 출력하면 돼. 그럼 땡큐~이게 오박사님이 나에게 새로 주시려고 하는 도감이야. 너무 가지고 싶다ㅠㅜ. 꼭 만점을 받아줬으면 좋겠어!! 파이팅!!!예제 입출력 1입력26 5BulbasaurIvysaurVenusaurCharmanderCharmeleonCharizardSquirtleWartortleBlastoiseCaterpieMetapodButterfreeWeedleKakunaBeedrillPidgeyPidgeottoPidgeotRattataRaticateSpearowFearowEkansArbokPikachuRaichu25Raichu3PidgeyKakuna출력Pikachu26Venusaur1614코드(파이썬)import sysn, m = tuple(map(int, sys.stdin.readline().split()))pokes_dict = dict()nums_dict = dict()r = list()inputs = tuple(map(lambda line: line.strip(), sys.stdin.readlines()))for i in range(n):    pokes_dict[inputs[i]] = str(i + 1)    nums_dict = dict(zip(pokes_dict.values(), pokes_dict.keys()))for i in inputs[n:]:    if i.isnumeric():        r.append(nums_dict[i])    else:        r.append(pokes_dict[i])        sys.stdout.write(\"\\n\".join(r))특이사항  풀이를 보면 메모리와 시간이 반비례 형태를 보임  포켓몬 혹은 도감 번호를 키로 갖는 딕셔너리 2개 이용참고문헌-"
  },
  
  {
    "title": "백준 1091번 카드 섞기",
    "url": "/posts/0083_boj_1091/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 시뮬레이션(simulation)",
    "date": "2022-05-19 23:08:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  2초      128 MB      문제지민이는 카지노의 딜러이고, 지금 3명의 플레이어(0, 1, 2)가 있다. 이 게임은 N개의 카드를 이용한다. (0 ~ N-1번)일단 지민이는 카드를 몇...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  2초      128 MB      문제지민이는 카지노의 딜러이고, 지금 3명의 플레이어(0, 1, 2)가 있다. 이 게임은 N개의 카드를 이용한다. (0 ~ N-1번)일단 지민이는 카드를 몇 번 섞은 다음에, 그것을 플레이어들에게 나누어 준다. 0번째 위치에 있던 카드가 플레이어 0에게 가고, 1번째 위치에 있던 카드는 플레이어 1에게 가고, 2번째 위치에 있던 카드는 플레이어 2에게 가고, 3번째 위치에 있던 카드는 플레이어 0에게 가고, 이런식으로 카드를 나누어 준다. 하지만, 지민이는 약간 사기를 치려고 한다.지민이는 처음에 카드를 섞기 전에 카드의 순서를 알고 있고, 이 정보를 이용해 각 카드가 특정한 플레이어에게 보내지게 할 것이다.카드를 한 번 섞을 때는 주어진 방법을 이용해서만 섞을 수 있고, 이 방법은 길이가 N인 수열 S로 주어진다. 카드를 한 번 섞고 나면 i번째 위치에 있던 카드는 S[i]번째 위치로 이동하게 된다.각 카드가 어떤 플레이어에게 가야 하는지에 대한 정보는 길이가 N인 수열 P로 주어진다. 맨 처음 i번째 위치에 있던 카드를 최종적으로 플레이어 P[i] 에게 보내야한다.지민이가 목적을 달성하기 위해 필요한 카드 섞는 횟수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. N은 3보다 크거나 같고, 48보다 작거나 같은 3의 배수이다.둘째 줄에 길이가 N인 수열 P가 주어진다. 수열 P에 있는 수는 0, 1, 2 중 하나이다.셋째 줄에 길이가 N인 수열 S가 주어진다. 수열 S에 있는 수는 모두 N-1보다 작거나 같은 자연수 또는 0이고 중복되지 않는다.출력첫째 줄에 몇 번 섞어야 하는지 출력한다. 만약, 섞어도 섞어도 카드를 해당하는 플레이어에게 줄 수 없다면, -1을 출력한다.예제 입출력 1입력32 0 11 2 0출력2예제 입출력 2입력60 1 2 0 1 21 4 0 3 2 5출력0예제 입출력 3입력31 0 20 2 1출력-1예제 입출력 4입력121 1 2 0 2 0 1 0 2 2 1 05 0 9 7 1 8 3 10 4 11 6 2출력59코드(파이썬)def back_track(ch):    v[ch] = 1        if len(stack) == l:        if sum([v[ch] for ch in mo]) &gt; 0 and sum([v[ch] for ch in za]) &gt; 1:            print(\"\".join([chr(ch+ord('a')) for ch in stack]))    else:        for n_ch in alpha[index[ch]+1:]:            stack.append(n_ch)            back_track(n_ch)            stack.pop()                v[ch] = 0l, c = map(int, input().split())alpha = sorted([ord(ch)-ord('a') for ch in input().split()])mo_all = [ord('a')-ord('a'), ord('e')-ord('a'), ord('i')-ord('a'), ord('o')-ord('a'), ord('u')-ord('a')]za_all = [i for i in range(26) if i not in mo_all]mo = set(alpha).difference(za_all)za = set(alpha).difference(mo)v = [0 if i in alpha else 1 for i in range(26)]index = [alpha.index(i) if i in alpha else 0 for i in range(26)]stack = []for ch in alpha:    stack.append(ch)    back_track(ch)    stack.pop()특이사항  내 코드(48,248KB, 1000ms)에 비해 우수한 코드(바로가기, 30,840KB, 512ms)와 비교                  from sys import stdinn = int(input())p = list(map(int, input().split()))s = list(map(int, stdin.readline().split()))answer = [i%3 for i in range(n)]temp = pdef shuffle(list, shup):    arr = [0]*n    for i in range(n):        arr[shup[i]] = list[i]    return arrcnt = 0while p != answer:    p = shuffle(p, s)    cnt += 1    if p == temp:        print(-1)        exit()print(cnt)                    저장방식                  기존: 문자형          개선: 정수형                    중복 확인                  기존: v 세트          개선: 문자열을 섞다보면 결국 처음 문자열로 돌아가므로 해당 문자열만 확인                    참고문헌-"
  },
  
  {
    "title": "백준 1759번 암호 만들기",
    "url": "/posts/0082_boj_1759/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 백트래킹(backtracking), 브루트포스(bruteforce), 수학(math), 조합론(combinatorics)",
    "date": "2022-05-18 22:44:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #수학 #브루트포스 #조합론 #백트래킹조건            시간 제한      메모리 제한                  2초      128 MB      문제바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #수학 #브루트포스 #조합론 #백트래킹조건            시간 제한      메모리 제한                  2초      128 MB      문제바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음(a, e, i, o, u)과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.입력첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.출력각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.예제 입출력 1입력4 6a t c i s w출력acisacitaciwacstacswactwaistaiswaitwastwcistciswcitwistw코드(파이썬)def back_track(ch):    v[ch] = 1        if len(stack) == l:        if sum([v[ch] for ch in mo]) &gt; 0 and sum([v[ch] for ch in za]) &gt; 1:            print(\"\".join([chr(ch+ord('a')) for ch in stack]))    else:        for n_ch in alpha[index[ch]+1:]:            stack.append(n_ch)            back_track(n_ch)            stack.pop()                v[ch] = 0l, c = map(int, input().split())alpha = sorted([ord(ch)-ord('a') for ch in input().split()])mo_all = [ord('a')-ord('a'), ord('e')-ord('a'), ord('i')-ord('a'), ord('o')-ord('a'), ord('u')-ord('a')]za_all = [i for i in range(26) if i not in mo_all]mo = set(alpha).difference(za_all)za = set(alpha).difference(mo)v = [0 if i in alpha else 1 for i in range(26)]index = [alpha.index(i) if i in alpha else 0 for i in range(26)]stack = []for ch in alpha:    stack.append(ch)    back_track(ch)    stack.pop()특이사항  해결방법          mo와 za 세트에 모음과 자음 저장      v에 모음과 자음 상태 저장      stack으로 백트래킹 수행      현재 모음과 자음에 따라 stack 내용 출력        내 코드(30,840KB, 84ms)에 비해 우수한 코드(바로가기, 30,840KB, 72ms)와 비교                  from itertools import combinationsL, C = map(int, input().split())alpha = sorted(input().split())string = combinations(alpha, L)c = ['a', 'e', 'i', 'o', 'u']for s in string:    cnt_c = 0    cnt_v = set()    for i in s:        if i in c:            cnt_c += 1        else:            cnt_v.add(i)    if cnt_c &gt; 0 and len(cnt_v) &gt; 1:        print(''.join(s))                    해결방법                  기존: v 리스트, stack을 이용한 백트래킹 등 복잡한 알고리즘을 보임          개선: combinations 메서드를 통해 모든 경우의 수를 계산한 뒤 조건에 따라 출력                    참고문헌-"
  },
  
  {
    "title": "백준 2156번 포도주시식",
    "url": "/posts/0081_boj_2156/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-05-17 22:25:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  2초      128 MB      문제효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  2초      128 MB      문제효주는 포도주 시식회에 갔다. 그 곳에 갔더니, 테이블 위에 다양한 포도주가 들어있는 포도주 잔이 일렬로 놓여 있었다. 효주는 포도주 시식을 하려고 하는데, 여기에는 다음과 같은 두 가지 규칙이 있다.  포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 마신 후에는 원래 위치에 다시 놓아야 한다.  연속으로 놓여 있는 3잔을 모두 마실 수는 없다.효주는 될 수 있는 대로 많은 양의 포도주를 맛보기 위해서 어떤 포도주 잔을 선택해야 할지 고민하고 있다. 1부터 n까지의 번호가 붙어 있는 n개의 포도주 잔이 순서대로 테이블 위에 놓여 있고, 각 포도주 잔에 들어있는 포도주의 양이 주어졌을 때, 효주를 도와 가장 많은 양의 포도주를 마실 수 있도록 하는 프로그램을 작성하시오.예를 들어 6개의 포도주 잔이 있고, 각각의 잔에 순서대로 6, 10, 13, 9, 8, 1 만큼의 포도주가 들어 있을 때, 첫 번째, 두 번째, 네 번째, 다섯 번째 포도주 잔을 선택하면 총 포도주 양이 33으로 최대로 마실 수 있다.입력첫째 줄에 포도주 잔의 개수 n이 주어진다. (1 ≤ n ≤ 10,000) 둘째 줄부터 n+1번째 줄까지 포도주 잔에 들어있는 포도주의 양이 순서대로 주어진다. 포도주의 양은 1,000 이하의 음이 아닌 정수이다.출력첫째 줄에 최대로 마실 수 있는 포도주의 양을 출력한다.예제 입출력 1입력661013981출력33코드(파이썬)import sysn = int(sys.stdin.readline())wines = [int(sys.stdin.readline()) for _ in range(n)]# 0: 불연속됨 / 1: 연속됨dp = [[0, 0]] + [[i, i] for i in wines]for i in range(2, n+1):    if i == 2:        dp[i][1] += wines[0]    else:        dp[i][1] = max(max(dp[i-2])+wines[i-1], dp[i-3][1]+wines[i-2]+wines[i-1], max(dp[i-1]))        dp[i][0] = dp[i-1][1]    print(max(dp[-1]))특이사항  DP 기초 문제로 점화식만 세운다면 해결할 수 있으나 무려 1시간 30분이나 고민  dp 리스트를 1차원으로 수정한다면 공간복잡도, 시간복잡도, 코드의 간결성 모두 개선할 수 있음참고문헌-"
  },
  
  {
    "title": "백준 1717번 집합의 표현",
    "url": "/posts/0080_boj_1717/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 분리 집합(disjoint_set)",
    "date": "2022-05-16 23:08:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #분리 집합 #자료구조조건            시간 제한      메모리 제한                  1초      128 MB      문제초기에 {0}, {1}, {2}, … {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #분리 집합 #자료구조조건            시간 제한      메모리 제한                  1초      128 MB      문제초기에 {0}, {1}, {2}, … {n} 이 각각 n+1개의 집합을 이루고 있다. 여기에 합집합 연산과, 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산을 수행하려고 한다.집합을 표현하는 프로그램을 작성하시오.입력첫째 줄에 n(1 ≤ n ≤ 1,000,000), m(1 ≤ m ≤ 100,000)이 주어진다. m은 입력으로 주어지는 연산의 개수이다. 다음 m개의 줄에는 각각의 연산이 주어진다. 합집합은 0 a b의 형태로 입력이 주어진다. 이는 a가 포함되어 있는 집합과, b가 포함되어 있는 집합을 합친다는 의미이다. 두 원소가 같은 집합에 포함되어 있는지를 확인하는 연산은 1 a b의 형태로 입력이 주어진다. 이는 a와 b가 같은 집합에 포함되어 있는지를 확인하는 연산이다. a와 b는 n 이하의 자연수 또는 0이며 같을 수도 있다.출력1로 시작하는 입력에 대해서 한 줄에 하나씩 YES/NO로 결과를 출력한다. (yes/no 를 출력해도 된다)예제 입출력 1입력7 80 1 31 1 70 7 61 7 10 3 70 4 20 1 11 1 1출력NONOYES코드(파이썬)import syssys.setrecursionlimit(10**6)def find(num):    if sets[num] != num:        sets[num] = find(sets[num])    return sets[num]def union(num1, num2):    set1 = find(num1)    set2 = find(num2)        if set1 != set2:        if set1 &lt; set2:            sets[set2] = set1        else:            sets[set1] = set2            n, m = map(int, sys.stdin.readline().split())sets = list(range(n+1))for _ in range(m):    op, num1, num2 = map(int, sys.stdin.readline().split())    if op:        print(\"YES\" if find(num1) == find(num2) else \"NO\")    else:        union(num1, num2)특이사항  해결방식          기존의 리스트 이용 집합 표현 방식 사용      find 함수에서 시간이 다수 소요      각 집합이 가리키는 노드를 하나로 갱신하는 방법을 이용해 시간 단축      참고문헌  문병로, 쉽게 배우는 알고리즘 :관계 중심의 사고법, 문병로, 2018"
  },
  
  {
    "title": "백준 1068번 트리",
    "url": "/posts/0079_boj_1968/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 트리(tree), 깊이우선탐색(depth_first_search)",
    "date": "2022-05-13 22:42:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #트리 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1초      128 MB      문제트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #트리 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1초      128 MB      문제트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.예를 들어, 다음과 같은 트리가 있다고 하자.현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.이제 리프 노드의 개수는 1개이다.입력첫째 줄에 트리의 노드의 개수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에는 0번 노드부터 N-1번 노드까지, 각 노드의 부모가 주어진다. 만약 부모가 없다면 (루트) -1이 주어진다. 셋째 줄에는 지울 노드의 번호가 주어진다.출력첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.예제 입출력 1입력5-1 0 0 1 12출력2예제 입출력 2입력5-1 0 0 1 11출력1예제 입출력 3입력5-1 0 0 1 10출력0예제 입출력 4입력9-1 0 0 2 2 4 4 6 64출력2코드(파이썬)def dfs(node):    global cnt     if not tree[node]:        cnt += 1        return    else:        for c in tree[node]:            if c != delete_node:                dfs(c)n = int(input())tree_arr = list(map(int, input().split()))delete_node = int(input())tree = {i:list() for i in range(n)}cnt = 0root = 0for c, p in enumerate(tree_arr):    if p == -1:        root = c    elif c != delete_node:        tree[p].append(c)if root != delete_node:    dfs(root)print(cnt)특이사항  해결방식          투포인터를 이용해 왼쪽에서 오른쪽으로 진행      지금 범위의 값이 s보다 크거나 같다면 length를 최신화      지금 범위의 값이 s보다 작다면 right에 1을 더함      그렇지 않다면 left에 1을 더함      참고문헌-"
  },
  
  {
    "title": "백준 1806번 부분합",
    "url": "/posts/0078_boj_1806/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 투포인터(two_pointer)",
    "date": "2022-05-12 22:20:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #투포인터조건            시간 제한      메모리 제한                  0.5초      128 MB      문제10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #투포인터조건            시간 제한      메모리 제한                  0.5초      128 MB      문제10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.입력첫째 줄에 N (10 ≤ N &lt; 100,000)과 S (0 &lt; S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.출력첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.예제 입출력 1입력10 155 1 3 5 10 7 4 9 2 8출력2코드(파이썬)import sysn, s = map(int, sys.stdin.readline().split())nums = tuple(map(int, sys.stdin.readline().split()))left, right = 0, 0MAX_LEN = 100000001length = MAX_LENbetween = nums[0]while left &lt; n:    if between &gt;= s:        length = min(right - left + 1, length)            if between &lt; s and right &lt; n-1:        right += 1        between += nums[right]    else:        between -= nums[left]        left += 1        print(length if length &lt; MAX_LEN else 0)특이사항  해결방식          투포인터를 이용해 왼쪽에서 오른쪽으로 진행      지금 범위의 값이 s보다 크거나 같다면 length를 최신화      지금 범위의 값이 s보다 작다면 right에 1을 더함      그렇지 않다면 left에 1을 더함      참고문헌-"
  },
  
  {
    "title": "백준 1504번 특정한 최단 경로",
    "url": "/posts/0077_boj_1504/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra)",
    "date": "2022-05-11 22:34:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1초      256 MB      문제방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  1초      256 MB      문제방향성이 없는 그래프가 주어진다. 세준이는 1번 정점에서 N번 정점으로 최단 거리로 이동하려고 한다. 또한 세준이는 두 가지 조건을 만족하면서 이동하는 특정한 최단 경로를 구하고 싶은데, 그것은 바로 임의로 주어진 두 정점은 반드시 통과해야 한다는 것이다.세준이는 한번 이동했던 정점은 물론, 한번 이동했던 간선도 다시 이동할 수 있다. 하지만 반드시 최단 경로로 이동해야 한다는 사실에 주의하라. 1번 정점에서 N번 정점으로 이동할 때, 주어진 두 정점을 반드시 거치면서 최단 경로로 이동하는 프로그램을 작성하시오.입력첫째 줄에 정점의 개수 N과 간선의 개수 E가 주어진다. (2 ≤ N ≤ 800, 0 ≤ E ≤ 200,000) 둘째 줄부터 E개의 줄에 걸쳐서 세 개의 정수 a, b, c가 주어지는데, a번 정점에서 b번 정점까지 양방향 길이 존재하며, 그 거리가 c라는 뜻이다. (1 ≤ c ≤ 1,000) 다음 줄에는 반드시 거쳐야 하는 두 개의 서로 다른 정점 번호 v1과 v2가 주어진다. (v1 ≠ v2, v1 ≠ N, v2 ≠ 1) 임의의 두 정점 u와 v사이에는 간선이 최대 1개 존재한다.출력첫째 줄에 두 개의 정점을 지나는 최단 경로의 길이를 출력한다. 그러한 경로가 없을 때에는 -1을 출력한다.예제 입출력 1입력4 61 2 32 3 33 4 11 3 52 4 51 4 42 3출력7코드(파이썬)import heapqimport sysdef diji(start):    d = [MAX_DIST] * (n+1)    v = [1] + [0] * (n)    queue = [(0, start)]    d[start] = 0        while queue and 0 in v:        dist, node = heapq.heappop(queue)        v[node] = 1                for next_dist, next_node in edges[node]:            if next_dist+dist &lt; d[next_node] and v[next_node] == 0:                d[next_node] = next_dist+dist                heapq.heappush(queue, (next_dist+dist, next_node))                    return d                n, e = map(int, sys.stdin.readline().split())edges = {i:list() for i in range(1, n+1)}MAX_DIST = 1000 * 200001for _ in range(e):    n1, n2, d = map(int ,sys.stdin.readline().split())    edges[n1].append((d, n2))    edges[n2].append((d, n1))wp1, wp2 = map(int, sys.stdin.readline().split())    between_wp = diji(wp1)[wp2]path = [0, 0]for start in [1, n]:    d = diji(start)        path[0] += d[wp1] if start == 1 else d[wp2]    path[1] += d[wp2] if start == 1 else d[wp1]if between_wp == MAX_DIST or max(path) &gt;= MAX_DIST:    print(-1)else:    print(between_wp + min(path))특이사항  해결방식          [a - 경유지1 - 경유지2 - b] 와 [b - 경유지1 - 경유지2 - a]의 경로를 비교      각 점들 간의 경로는 다익스트라를 이용해 계산      참고문헌-"
  },
  
  {
    "title": "백준 1027번 고층 건물",
    "url": "/posts/0076_boj_1027/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 기하학(geometry), 브루트포스(bruteforce), 수학(math)",
    "date": "2022-05-10 23:14:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #수학 #브루트포스 알고리즘 #기하학조건            시간 제한      메모리 제한                  2초      128 MB      문제세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #수학 #브루트포스 알고리즘 #기하학조건            시간 제한      메모리 제한                  2초      128 MB      문제세준시에는 고층 빌딩이 많다. 세준시의 서민 김지민은 가장 많은 고층 빌딩이 보이는 고층 빌딩을 찾으려고 한다. 빌딩은 총 N개가 있는데, 빌딩은 선분으로 나타낸다. i번째 빌딩 (1부터 시작)은 (i,0)부터 (i,높이)의 선분으로 나타낼 수 있다. 고층 빌딩 A에서 다른 고층 빌딩 B가 볼 수 있는 빌딩이 되려면, 두 지붕을 잇는 선분이 A와 B를 제외한 다른 고층 빌딩을 지나거나 접하지 않아야 한다. 가장 많은 고층 빌딩이 보이는 빌딩을 구하고, 거기서 보이는 빌딩의 수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 빌딩의 수 N이 주어진다. N은 50보다 작거나 같은 자연수이다. 둘째 줄에 1번 빌딩부터 그 높이가 주어진다. 높이는 1,000,000,000보다 작거나 같은 자연수이다.출력첫째 줄에 문제의 정답을 출력한다.예제 입출력 1입력151 5 3 2 6 3 2 6 4 2 5 7 3 1 5출력7예제 입출력 2입력110출력0예제 입출력 3입력45 5 5 5출력2예제 입출력 4입력51 2 7 3 2출력4예제 입출력 5입력101000000000 999999999 999999998 999999997 999999996 1 2 3 4 5출력6코드(파이썬)n = int(input())buildings = list(map(int, input().split()))link = {i:list() for i in range(n)}for i in range(n):    g = -1000000000    highest = 1000000001        for j in range(i+1, n):        now_g = (buildings[j]-buildings[i]) / (j-i)        line = g * (j-i) + buildings[i]                if buildings[j] &gt; line:            g = now_g            link[i].append(j)            link[j].append(i)            highest = buildings[j]        elif g &lt; now_g &lt; 0 and highest &gt; line:            g = now_g            link[i].append(j)            link[j].append(i)        print(max([len(v) for v in link.values()]))특이사항  각 지점에서 오른쪽에 있는 모든 지점을 확인하는 단순한 방식  내 코드(30,840KB, 68ms)에 비해 우수한 코드(바로가기, 30,840KB, 68ms)와 비교                  N=int(input(\"\"))numL=list(map(int,input(\"\").split()))height_L=[0]*Nfor i in range(N-1):    max_angle=0    for j in range(i+1,N):        angle=(numL[j]-numL[i])/(j-i)        if j==i+1 or angle&gt;max_angle:            max_angle=angle            height_L[i]+=1            height_L[j]+=1print(max(height_L))                    최고 높이 확인                  기존: link에 각 요소를 저장하고 그 길이를 통해 확인          개선: height_L 리스트에 숫자를 저장해 확인                    건물 보이는지 여부                  기존: 2가지 경우(높이가 더 높음 vs 높이가 더 낮음)로 나누어 해결          개선: 1가지 경우만으로 해결                    참고문헌-"
  },
  
  {
    "title": "백준 5639번 이진 검색 트리",
    "url": "/posts/0075_boj_5639/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 트리(tree), 재귀(recursion)",
    "date": "2022-05-06 20:51:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #트리 #재귀조건            시간 제한      메모리 제한                  1초      256 MB      문제이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #트리 #재귀조건            시간 제한      메모리 제한                  1초      256 MB      문제이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.입력트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 106보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.출력입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.예제 입출력 1입력50302452845985260출력52824453060529850코드(파이썬)import syssys.setrecursionlimit(10**5)def order(start, end):    if start &gt; end:        return    elif start == end:        print(preorder[start])        return        p = preorder[start]        right_val = 0    for num in preorder[start:]:        if num &gt; p:            right_val = num            break        if right_val:        right_index = preorder_index[right_val]    else:        right_index = start + 1            order(start+1, right_index-1)    order(right_index, end)    print(p)        preorder = [int(num) for num in sys.stdin.readlines()]preorder_index = [0] * (10**6 + 1)for i in range(len(preorder)):    preorder_index[preorder[i]] = iorder(0, len(preorder)-1)특이사항  내 코드(49,588KB, 1,480ms)에 비해 우수한 코드(바로가기, 39,800KB, 80ms)와 비교                  # Problem No.: 5639# Solver:      Jinmin Goh# Date:        20200421# URL: https://www.acmicpc.net/problem/5639import syssys.setrecursionlimit(10 ** 4 * 2)def postorder(nums: [int]) -&gt; None:    #print(nums)    def binarySearch(pFront: int, pRear: int) -&gt; None:        #print(\"start:\",pFront, pRear)        if pFront &gt; pRear:            return        head = nums[pFront]        if pFront == pRear:            print(head)            return        if head &gt; nums[pRear] or head &lt; nums[pFront + 1]:            binarySearch(pFront + 1, pRear)            print(head)            return                    pFront += 1        tempFront = pFront        tempRear = pRear        while tempFront + 1 &lt; tempRear:            tempMid = (tempFront + tempRear) // 2            if nums[tempMid] &gt; head:                tempRear = tempMid            else:                tempFront = tempMid        binarySearch(pFront, tempFront)        binarySearch(tempFront + 1, pRear)        print(head)    binarySearch(0, len(nums) - 1)def main():    nums = []    temp = sys.stdin.readline().strip()    while temp:        nums.append(int(temp))        temp = sys.stdin.readline().strip()    postorder(nums)    returnif __name__ == \"__main__\":    main()                    이진트리의 자식트리 탐색                  기존: 단순 반복문          개선: 이진탐색                    참고문헌-"
  },
  
  {
    "title": "백준 17144번 미세먼지 안녕!",
    "url": "/posts/0074_boj_17144/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 시뮬레이션(simulation)",
    "date": "2022-05-05 22:55:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  1초      512 MB      문제미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #구현 #시뮬레이션조건            시간 제한      메모리 제한                  1초      512 MB      문제미세먼지를 제거하기 위해 구사과는 공기청정기를 설치하려고 한다. 공기청정기의 성능을 테스트하기 위해 구사과는 집을 크기가 R×C인 격자판으로 나타냈고, 1×1 크기의 칸으로 나눴다. 구사과는 뛰어난 코딩 실력을 이용해 각 칸 (r, c)에 있는 미세먼지의 양을 실시간으로 모니터링하는 시스템을 개발했다. (r, c)는 r행 c열을 의미한다.공기청정기는 항상 1번 열에 설치되어 있고, 크기는 두 행을 차지한다. 공기청정기가 설치되어 있지 않은 칸에는 미세먼지가 있고, (r, c)에 있는 미세먼지의 양은 Ar,c이다.1초 동안 아래 적힌 일이 순서대로 일어난다.  미세먼지가 확산된다. 확산은 미세먼지가 있는 모든 칸에서 동시에 일어난다.          (r, c)에 있는 미세먼지는 인접한 네 방향으로 확산된다.      인접한 방향에 공기청정기가 있거나, 칸이 없으면 그 방향으로는 확산이 일어나지 않는다.      확산되는 양은 Ar,c/5이고 소수점은 버린다.      (r, c)에 남은 미세먼지의 양은 Ar,c - (Ar,c/5)×(확산된 방향의 개수) 이다.        공기청정기가 작동한다.          공기청정기에서는 바람이 나온다.      위쪽 공기청정기의 바람은 반시계방향으로 순환하고, 아래쪽 공기청정기의 바람은 시계방향으로 순환한다.      바람이 불면 미세먼지가 바람의 방향대로 모두 한 칸씩 이동한다.      공기청정기에서 부는 바람은 미세먼지가 없는 바람이고, 공기청정기로 들어간 미세먼지는 모두 정화된다.      다음은 확산의 예시이다.왼쪽과 오른쪽에 칸이 없기 때문에, 두 방향으로만 확산이 일어났다.인접한 네 방향으로 모두 확산이 일어난다.공기청정기가 있는 칸으로는 확산이 일어나지 않는다.공기청정기의 바람은 다음과 같은 방향으로 순환한다.방의 정보가 주어졌을 때, T초가 지난 후 구사과의 방에 남아있는 미세먼지의 양을 구해보자.입력첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.출력첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.예제 입출력 1입력7 8 10 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력188미세먼지의 확산이 일어나면 다음과 같은 상태가 된다.공기청정기가 작동한 이후 상태는 아래와 같다.예제 입출력 2입력7 8 20 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력188예제 입출력 3입력7 8 30 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력186예제 입출력 4입력7 8 40 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력178예제 입출력 5입력7 8 50 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력172예제 입출력 6입력7 8 200 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력71예제 입출력 7입력7 8 300 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력52예제 입출력 8입력7 8 500 0 0 0 0 0 0 90 0 0 0 3 0 0 8-1 0 5 0 0 0 22 0-1 8 0 0 0 0 0 00 0 0 0 0 10 43 00 0 5 0 15 0 0 00 0 40 0 0 0 20 0출력46코드(파이썬)import sysr, c, t = map(int, sys.stdin.readline().split())room = [list(map(int, sys.stdin.readline().split())) for _ in range(r)]dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]air_up, air_down = [i for i in range(r) if room[i][0]==-1]for _ in range(t):    tmp_room = [[0] * c for _ in range(r)]        for x in range(r):        for y in range(c):            if x in [air_up, air_down] and y == 0:                continue                        cnt = 0                        for i in range(4):                d_x = x + dx[i]                d_y = y + dy[i]                if d_x in [air_up, air_down] and d_y == 0:                    continue                if 0 &lt;= d_x &lt;= r-1 and 0 &lt;= d_y &lt;= c-1:                    cnt += 1                    tmp_room[x][y] += room[d_x][d_y] // 5                        tmp_room[x][y] += room[x][y] - (room[x][y] // 5) * cnt        # 상단 반시계    # 왼쪽    for del_c in range(air_up-1, 0, -1):        tmp_room[del_c][0] = tmp_room[del_c-1][0]    # 위쪽    for del_r in range(0, c-1):        tmp_room[0][del_r] = tmp_room[0][del_r+1]    # 오른쪽    for del_c in range(0, air_up, 1):        tmp_room[del_c][c-1] = tmp_room[del_c+1][c-1]    # 아래쪽    for del_r in range(c-1, 1, -1):        tmp_room[air_up][del_r] = tmp_room[air_up][del_r-1]    tmp_room[air_up][1] = 0    # 하단 시계    # 왼쪽    for del_c in range(air_down+1, r-1):        tmp_room[del_c][0] = tmp_room[del_c+1][0]    # 아래쪽    for del_r in range(0, c-1):        tmp_room[r-1][del_r] = tmp_room[r-1][del_r+1]    # 오른쪽    for del_c in range(r-1, air_down, -1):        tmp_room[del_c][c-1] = tmp_room[del_c-1][c-1]    # 위쪽    for del_r in range(c-1, 1, -1):        tmp_room[air_down][del_r] = tmp_room[air_down][del_r-1]    tmp_room[air_down][1] = 0        room = tmp_room    print(sum([sum(row) for row in room]))특이사항  문제의 조건에 따라 구현  같은 알고리즘이라도 현재 풀이는 pypy가 아닌 python3에서 시간초과가 발생하므로 시간복잡도를 줄여야 함참고문헌-"
  },
  
  {
    "title": "백준 2096번 최소비용 구하기",
    "url": "/posts/0073_boj_2096/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 슬라이딩 윈도우(sliding_window)",
    "date": "2022-05-04 22:53:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #다이나믹 프로그래밍 #슬라이딩 윈도우조건            시간 제한      메모리 제한                  1초      4 MB(JAVA: 256MB)      문제N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #다이나믹 프로그래밍 #슬라이딩 윈도우조건            시간 제한      메모리 제한                  1초      4 MB(JAVA: 256MB)      문제N줄에 0 이상 9 이하의 숫자가 세 개씩 적혀 있다. 내려가기 게임을 하고 있는데, 이 게임은 첫 줄에서 시작해서 마지막 줄에서 끝나게 되는 놀이이다.먼저 처음에 적혀 있는 세 개의 숫자 중에서 하나를 골라서 시작하게 된다. 그리고 다음 줄로 내려가는데, 다음 줄로 내려갈 때에는 다음과 같은 제약 조건이 있다. 바로 아래의 수로 넘어가거나, 아니면 바로 아래의 수와 붙어 있는 수로만 이동할 수 있다는 것이다. 이 제약 조건을 그림으로 나타내어 보면 다음과 같다.별표는 현재 위치이고, 그 아랫 줄의 파란 동그라미는 원룡이가 다음 줄로 내려갈 수 있는 위치이며, 빨간 가위표는 원룡이가 내려갈 수 없는 위치가 된다. 숫자표가 주어져 있을 때, 얻을 수 있는 최대 점수, 최소 점수를 구하는 프로그램을 작성하시오. 점수는 원룡이가 위치한 곳의 수의 합이다.입력첫째 줄에 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 숫자가 세 개씩 주어진다. 숫자는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 중의 하나가 된다.출력첫째 줄에 얻을 수 있는 최대 점수와 최소 점수를 띄어서 출력한다.예제 입출력 1입력31 2 34 5 64 9 0출력18 6예제 입출력 2입력30 0 00 0 00 0 0출력0 0코드(파이썬)import sysn = int(sys.stdin.readline())d_max = list(map(int, sys.stdin.readline().split()))d_min = d_max.copy()for _ in range(n-1):    new_d_max = list(map(int, sys.stdin.readline().split()))    new_d_min = new_d_max.copy()        new_d_max[0] += max(d_max[0], d_max[1])    new_d_max[1] += max(d_max)    new_d_max[2] += max(d_max[1], d_max[2])    new_d_min[0] += min(d_min[0], d_min[1])    new_d_min[1] += min(d_min)    new_d_min[2] += min(d_min[1], d_min[2])        d_max, d_min = new_d_max, new_d_min    print(max(d_max), min(d_min))특이사항  DP로 해결했으나 슬라이딩 윈도우 알고리즘으로도 해결할 수 있다고 함참고문헌-"
  },
  
  {
    "title": "백준 1916번 최소비용 구하기",
    "url": "/posts/0072_boj_1916/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra)",
    "date": "2022-05-03 22:07:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  0.5 초      128 MB      문제N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #다익스트라조건            시간 제한      메모리 제한                  0.5 초      128 MB      문제N개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 M개의 버스가 있다. 우리는 A번째 도시에서 B번째 도시까지 가는데 드는 버스 비용을 최소화 시키려고 한다. A번째 도시에서 B번째 도시까지 가는데 드는 최소비용을 출력하여라. 도시의 번호는 1부터 N까지이다.입력첫째 줄에 도시의 개수 N(1 ≤ N ≤ 1,000)이 주어지고 둘째 줄에는 버스의 개수 M(1 ≤ M ≤ 100,000)이 주어진다. 그리고 셋째 줄부터 M+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 그리고 그 다음에는 도착지의 도시 번호가 주어지고 또 그 버스 비용이 주어진다. 버스 비용은 0보다 크거나 같고, 100,000보다 작은 정수이다.그리고 M+3째 줄에는 우리가 구하고자 하는 구간 출발점의 도시번호와 도착점의 도시번호가 주어진다. 출발점에서 도착점을 갈 수 있는 경우만 입력으로 주어진다.출력첫째 줄에 출발 도시에서 도착 도시까지 가는데 드는 최소 비용을 출력한다.예제 입출력 1입력581 2 21 3 31 4 11 5 102 4 23 4 13 5 14 5 31 5출력4코드(파이썬)import heapqimport sys                n = int(sys.stdin.readline())m = int(sys.stdin.readline())edges = {i:list() for i in range(1, n+1)}d = [1000 * 200001] * (n+1)v = [1] + [0] * (n)for _ in range(m):    n1, n2, dist = map(int ,sys.stdin.readline().split())    edges[n1].append((dist, n2))start, end = map(int, sys.stdin.readline().split())queue = [(0, start)]d[start] = 0while queue and 0 in v:    dist, node = heapq.heappop(queue)    if v[node] == 0:        v[node] = 1            for next_dist, next_node in edges[node]:            if next_dist + dist &lt; d[next_node] and v[next_node] == 0:                d[next_node] = next_dist + dist                heapq.heappush(queue, (next_dist + dist, next_node))print(d[end])특이사항  다익스트라 기본 문제  내 코드(55,632KB, 376ms)에 비해 우수한 코드(바로가기, 55,880KB, 276ms)와 비교                  import sysimport heapqimport collectionsinput = sys.stdin.readlinen = int(input())m = int(input())graph = collections.defaultdict(list)for _ in range(m):    start, end, cost = map(int, input().split())    graph[start].append((cost, end))A, B = map(int, input().split())result = {}heap = [(0, A)]while heap:    cost, point = heapq.heappop(heap)    if point == B:        break    if point not in result:        result[point] = cost        for cost2, point2 in graph[point]:            heapq.heappush(heap, (cost + cost2, point2))print(cost)                    반복문(다음 노드 선택) 탈출                  기존: 다음 방문 노드 없거나 모든 노드를 순회했을 때          개선: 다음 방문 노드 없거나 목표인 노드를 방문했을 때                    참고문헌-"
  },
  
  {
    "title": "백준 2263번 트리의 순회",
    "url": "/posts/0071_boj_2263/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 트리(tree), 재귀(recursion)",
    "date": "2022-05-02 23:23:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold2관련 개념: #트리 #분할정복 #재귀조건            시간 제한      메모리 제한                  5 초      128 MB      문제n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때,...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold2관련 개념: #트리 #분할정복 #재귀조건            시간 제한      메모리 제한                  5 초      128 MB      문제n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.입력첫째 줄에 n(1 ≤ n ≤ 100,000)이 주어진다. 다음 줄에는 인오더를 나타내는 n개의 자연수가 주어지고, 그 다음 줄에는 같은 식으로 포스트오더가 주어진다.출력첫째 줄에 프리오더를 출력한다.예제 입출력 1입력31 2 31 3 2출력2 1 3코드(파이썬)import syssys.setrecursionlimit(100001)def check(in_start, in_end, post_start, post_end):    global result        root_value = postorder[post_end]    l_length = inorder.index(root_value) - in_start    result.append(root_value)        if l_length &gt; 1:        check(in_start, in_start+l_length-1, post_start, post_start+l_length-1)    elif l_length == 1:        result.append(inorder[in_start])            if in_start+l_length+1 &lt; in_end:        check(in_start+l_length+1, in_end, post_start+l_length, post_end-1)    elif in_start+l_length+1 == in_end:        result.append(inorder[in_end])    n = int(sys.stdin.readline())inorder = sys.stdin.readline().split()postorder = sys.stdin.readline().split()result = []check(0, n-1, 0, n-1)print(*result)특이사항  분할정복을 위해 구역을 나눠서 해결하는 것은 맞음  도저히 그 다음 아이디어가 생각나지 않아 pypy로 제출 후 풀이 확인  내 코드(331,124KB, 15,084ms)에 비해 우수한 코드(바로가기, 161,052KB, 332ms)와 비교                  from sys import stdin, setrecursionlimitsetrecursionlimit(10 ** 9)n = int(stdin.readline())inorder = list(map(int, stdin.readline().split()))postorder = list(map(int, stdin.readline().split()))inorder_index = [0] * (n + 1)for i in range(n):    inorder_index[inorder[i]] = ianswer = []def preorder(in_start, in_end, post_start, post_end):    if (in_start &gt; in_end) or (post_start &gt; post_end): return    parent = postorder[post_end]    answer.append(parent)    left = inorder_index[parent] - in_start    right = in_end - inorder_index[parent]    preorder(in_start, in_start + left - 1, post_start, post_start + left - 1)    preorder(in_end - right + 1, in_end, post_end - right, post_end - 1)preorder(0, n - 1, 0, n - 1)print(*answer)                    인덱스 확인                  기존: index 메서드 이용          개선: inorder_index 리스트를 생성해 inorder 인덱스 확인을 O(1)에 해결                    참고문헌-"
  },
  
  {
    "title": "백준 1013번 Contact",
    "url": "/posts/0070_boj_1013/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 문자열(string), 정규표현식(regular_expression)",
    "date": "2022-04-29 23:23:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #문자열 #정규표현식조건            시간 제한      메모리 제한                  2 초      512 MB      문제  “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #문자열 #정규표현식조건            시간 제한      메모리 제한                  2 초      512 MB      문제  “무한히 넓은 저 우주에 인류만이 홀로 존재한다면, 그건 정말 슬픈 일이 아닐까요”푸에르토리코 아레시보에 위치한 아레시보 전파망원경(Arecibo radio telescope)은 수십 년째 존재하지 않을 지도 모르는 외계 문명으로부터의 전파를 수신하기 위해 밤하늘을 바라보고 있다.이 망원경이 수집한 전파 속에서 자연적으로 발생하기 힘든 패턴들을 찾아내어, 그것을 증거로 외계 문명의 존재 여부를 가리려는 노력은 줄곧 이어져왔지만 아직까지도 그러한 패턴은 발견되지 않았다. 한국 천문학계의 자존심 김동혁 박사는 국내 기술로 이러한 탐사를 진행하기 위하여 다음의 전파 표기를 표준으로 삼았다.전파의 기본 단위는 { 0 , 1 } 두 가지로 구성되어있으며, x+ (  ) 는 임의의 개수(최소 1개) x의 반복으로 이루어진 전파의 집합을 나타낸다.(xyx)+ (  ) 는 괄호 내의 xyx의 반복으로 이루어진 전파의 집합을 뜻한다. 아래는 이해를 돕기 위한 예제이다.  1+ = { 1, 11, 111, 1111, 11111, … }  10+ = { 10, 100, 1000, 10000, 100000, … }  (01)+ = { 01, 0101, 010101, 01010101, 0101010101, … }  (1001)+ = { 1001, 10011001, 100110011001, … }  10+11 = { 1011, 10011, 100011, 1000011, 10000011, … }  (10+1)+ = { 101, 1001, 10001, 1011001, 1001101, 100011011000001, … }            반복을 의미하는 + 외에도 or 를 의미하는      기호가 있다. { x      y } 는 x 혹은 y 를 의미하는 것으로, { 0+      1+ } 는 { 0 , 1 , 00 , 11 , 000 , 111 , … } 의 집합을 의미한다. 아래는 두 기호를 복합적으로 사용한 예이다.                                    (100          11)+ = { 100 , 11 , 10011 , 11100 , 1110011100 , 100111111100100, … }                    최근 김동혁 박사는 아레시보 전파망원경에서 star Vega(직녀성) 으로부터 수신한 전파 기록의 일부를 조사하여 그 전파들의 패턴을 분석하여 아래와 같이 기록하였다.                              (100+1+          01)+                    김동혁 박사는 다양한 전파 기록 중에서 위의 패턴을 지니는 전파를 가려내는 프로그램을 필요로 한다. 이를 수행할 수 있는 프로그램을 작성하라.입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 전파를 표현하는, { 0, 1 }만으로 이루어진 문자열이 공백 없이 주어진다. 문자열 길이는 (1 ≤ N ≤ 200)의 범위를 갖는다.출력각 테스트 케이스에 대해 주어진 전파가 문제에서 제시한 패턴이면 “YES”를 그렇지 않은 경우는 “NO”를 출력한다. 출력 문자열은 모두 대문자로 구성되어 있다.예제 입출력 1입력3100101110110001001100010110001011001출력NONOYES코드(파이썬)import ret = int(input())for _ in range(t):    signal = re.fullmatch(\"(100+1+|01)+\", input())    print(\"YES\" if signal else \"NO\")특이사항  간단한 정규표현식 문제로 생각하고 풀이  다른 풀이로 DFA(Deterministic finite automaton, 결정적 유한 오토마타)가 있었음참고문헌-"
  },
  
  {
    "title": "백준 1865번 웜홀",
    "url": "/posts/0069_boj_1865/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 벨만-포드 알고리즘(bellman-ford)",
    "date": "2022-04-28 23:30:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #벨만-포드조건            시간 제한      메모리 제한                  2 초      128 MB      문제때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #벨만-포드조건            시간 제한      메모리 제한                  2 초      128 MB      문제때는 2020년, 백준이는 월드나라의 한 국민이다. 월드나라에는 N개의 지점이 있고 N개의 지점 사이에는 M개의 도로와 W개의 웜홀이 있다. (단 도로는 방향이 없으며 웜홀은 방향이 있다.) 웜홀은 시작 위치에서 도착 위치로 가는 하나의 경로인데, 특이하게도 도착을 하게 되면 시작을 하였을 때보다 시간이 뒤로 가게 된다. 웜홀 내에서는 시계가 거꾸로 간다고 생각하여도 좋다.시간 여행을 매우 좋아하는 백준이는 한 가지 궁금증에 빠졌다. 한 지점에서 출발을 하여서 시간여행을 하기 시작하여 다시 출발을 하였던 위치로 돌아왔을 때, 출발을 하였을 때보다 시간이 되돌아가 있는 경우가 있는지 없는지 궁금해졌다. 여러분은 백준이를 도와 이런 일이 가능한지 불가능한지 구하는 프로그램을 작성하여라.입력첫 번째 줄에는 테스트케이스의 개수 TC(1 ≤ TC ≤ 5)가 주어진다. 그리고 두 번째 줄부터 TC개의 테스트케이스가 차례로 주어지는데 각 테스트케이스의 첫 번째 줄에는 지점의 수 N(1 ≤ N ≤ 500), 도로의 개수 M(1 ≤ M ≤ 2500), 웜홀의 개수 W(1 ≤ W ≤ 200)이 주어진다. 그리고 두 번째 줄부터 M+1번째 줄에 도로의 정보가 주어지는데 각 도로의 정보는 S, E, T 세 정수로 주어진다. S와 E는 연결된 지점의 번호, T는 이 도로를 통해 이동하는데 걸리는 시간을 의미한다. 그리고 M+2번째 줄부터 M+W+1번째 줄까지 웜홀의 정보가 S, E, T 세 정수로 주어지는데 S는 시작 지점, E는 도착 지점, T는 줄어드는 시간을 의미한다. T는 10,000보다 작거나 같은 자연수 또는 0이다.두 지점을 연결하는 도로가 한 개보다 많을 수도 있다. 지점의 번호는 1부터 N까지 자연수로 중복 없이 매겨져 있다.출력TC개의 줄에 걸쳐서 만약에 시간이 줄어들면서 출발 위치로 돌아오는 것이 가능하면 YES, 불가능하면 NO를 출력한다.예제 입출력 1입력23 3 11 2 21 3 42 3 13 1 33 2 11 2 32 3 43 1 8출력NOYES코드(파이썬)import sysdef bf():    for i in range(1, n+1):        for s, e, weight in edges:            if d[s]+weight &lt; d[e]:                d[e] = d[s] + weight                if i == n:                    return True    return Falset = int(sys.stdin.readline())for _ in range(t):    n, m, w = map(int, sys.stdin.readline().split())    d = [2500 * 100000] * (n+1)    edges = list()        for _ in range(m):        s, e, weight = map(int, sys.stdin.readline().split())        edges.append([s, e, weight])        edges.append([e, s, weight])    for _ in range(w):        s, e, weight = map(int, sys.stdin.readline().split())        edges.append([s, e, -weight])            print(\"YES\" if bf() else \"NO\")특이사항  플로이드-워셜 알고리즘으로 풀어보려 했으나 O(V3)으로 시간초과  풀이과정          벨만-포드를 모든 간선에 적용      만약 n-1번의 수행에도 d 배열을 갱신하게 된다면 음의 싸이클이 존재한다는 것으로 판별      참고문헌  문병로, 쉽게 배우는 알고리즘 :관계 중심의 사고법, 문병로, 2018"
  },
  
  {
    "title": "백준 2206번 벽 부수고 이동하기",
    "url": "/posts/0068_boj_2206/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-04-27 22:02:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      192 MB      문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      192 MB      문제N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.출력첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.예제 입출력 1입력6 4010011101000000001110000출력4 40111111111111110예제 입출력 2입력4 40111111111111110출력-1코드(파이썬)import sysfrom collections import dequen, m = map(int, sys.stdin.readline().split())maps = [tuple(map(int, tuple(sys.stdin.readline().rstrip()))) for _ in range(n)]v = [[[0 for _ in range(m)] for _ in range(n)] for _ in range(2)]dx = [0, 0, 1, -1]dy = [1, -1, 0, 0]queue = deque([(0, 0, True)])v[1][0][0] = 1result = -1while queue:    x, y, is_break = queue.popleft()    if x == n-1 and y == m-1:        result = v[is_break][x][y]        break    for i in range(4):        next_x, next_y = x + dx[i], y + dy[i]        if 0 &lt;= next_x &lt;= n-1 and 0 &lt;= next_y &lt;= m-1 and v[is_break][next_x][next_y] == 0:            if maps[next_x][next_y] == 0 and v[is_break][next_x][next_y] == 0:                queue.append([next_x, next_y, is_break])                v[is_break][next_x][next_y] = v[is_break][x][y] + 1            elif is_break and maps[next_x][next_y] == 1:                queue.append([next_x, next_y, False])                v[0][next_x][next_y] = v[is_break][x][y] + 1print(result)특이사항  BFS로 접근하는 것은 맞았으나, 3차원 방문 리스트를 사용한다는 점은 몰랐음  또한 방문 리스트에 지금까지의 길이를 저장하는 점 역시 몰랐음  알고리즘에 대한 정리 필요성을 느낌참고문헌  Nahwasa, “BFS 알고리즘 (너비 우선 탐색) - 배열 BFS, 그래프 BFS”, nahwasa.com, https://nahwasa.com/entry/BFS-알고리즘-너비-우선-탐색-배열-BFS-그래프-BFS"
  },
  
  {
    "title": "백준 1167번 트리의 지름",
    "url": "/posts/0067_boj_1167/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 트리(tree), 깊이우선탐색(depth_first_search)",
    "date": "2022-04-26 22:33:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #트리조건            시간 제한      메모리 제한                  2 초      256 MB      문제트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #트리조건            시간 제한      메모리 제한                  2 초      256 MB      문제트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.입력트리가 입력으로 주어진다. 먼저 첫 번째 줄에서는 트리의 정점의 개수 V가 주어지고 (2 ≤ V ≤ 100,000)둘째 줄부터 V개의 줄에 걸쳐 간선의 정보가 다음과 같이 주어진다. 정점 번호는 1부터 V까지 매겨져 있다.먼저 정점 번호가 주어지고, 이어서 연결된 간선의 정보를 의미하는 정수가 두 개씩 주어지는데, 하나는 정점번호, 다른 하나는 그 정점까지의 거리이다. 예를 들어 네 번째 줄의 경우 정점 3은 정점 1과 거리가 2인 간선으로 연결되어 있고, 정점 4와는 거리가 3인 간선으로 연결되어 있는 것을 보여준다. 각 줄의 마지막에는 -1이 입력으로 주어진다. 주어지는 거리는 모두 10,000 이하의 자연수이다.출력첫째 줄에 트리의 지름을 출력한다.예제 입출력 1입력51 3 2 -12 4 4 -13 1 2 4 3 -14 2 4 3 3 5 6 -15 4 6 -1출력11코드(파이썬)import sysdef dfs(node):    global result        if graph[node]:        max_1, max_2 = 0, 0                for c, d in graph[node]:            if not v[c]:                v[c] = True                tmp = dfs(c) + d                v[c] = False                            if tmp &gt; max_1:                    max_1, max_2 = tmp, max_1                elif tmp &gt; max_2:                    max_2 = tmp                       result = max(result, max_1 + max_2)                return max_1    else:        return 0    n = int(sys.stdin.readline())graph = [list() for _ in range(n+1)]v = [False] * (n+1)result = -1s = 1for _ in range(n):    info = list(map(int, sys.stdin.readline().split()))        for i in range(1, len(info)-2, 2):        graph[info[0]].append((info[i], info[i+1]))v[1] = Truedfs(1)print(result)특이사항  DFS에서 자식 트리간 최장경로를 result에 저장하고 자식 트리 중 최장경로를 반환참고문헌-"
  },
  
  {
    "title": "백준 2110번 공유기 설치",
    "url": "/posts/0066_boj_1005/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다이나믹 프로그래밍(dynamic_programming), 위상 정렬(topological_sort)",
    "date": "2022-04-25 21:12:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #다이나믹 프로그래밍 #위상 정렬조건            시간 제한      메모리 제한                  1 초      512 MB      문제서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Constr...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #그래프이론 #다이나믹 프로그래밍 #위상 정렬조건            시간 제한      메모리 제한                  1 초      512 MB      문제서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.위의 예시를 보자.이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. 1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작할수 있다. (동시에 진행이 가능하다) 그리고 4번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료되어야지만 4번건물의 건설을 시작할수 있다.따라서 4번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요된다. 그리고 2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다. 3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요된다.프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성해주자.입력첫째 줄에는 테스트케이스의 개수 T가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. 첫째 줄에 건물의 개수 N과 건물간의 건설순서 규칙의 총 개수 K이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다)둘째 줄에는 각 건물당 건설에 걸리는 시간 D1, D2, …, DN이 공백을 사이로 주어진다. 셋째 줄부터 K+2줄까지 건설순서 X Y가 주어진다. (이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능하다는 의미이다)마지막 줄에는 백준이가 승리하기 위해 건설해야 할 건물의 번호 W가 주어진다.출력건물 W를 건설완료 하는데 드는 최소 시간을 출력한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.건설순서는 모든 건물이 건설 가능하도록 주어진다.제한  2 ≤ N ≤ 1000  1 ≤ K ≤ 100,000  1 ≤ X, Y, W ≤ N  0 ≤ Di ≤ 100,000, Di는 정수예제 입출력 1입력24 410 1 100 101 21 32 43 448 810 20 1 5 8 7 1 431 21 32 42 53 65 76 77 87출력12039예제 입출력 2입력53 21 2 33 22 114 35 5 5 51 21 32 345 10100000 99999 99997 99994 999904 53 53 42 52 42 31 51 41 31 244 31 1 1 11 23 21 447 80 0 0 0 0 0 01 21 32 43 44 54 65 76 77출력6539999020코드(파이썬)from collections import dequeimport syst = int(sys.stdin.readline())tmp = list()for _ in range(t):    n, k = map(int, sys.stdin.readline().split())    d = list(map(int, sys.stdin.readline().split()))    graph = [[[], []] for _ in range(n)]    v = [0] * n    r = [-1] * n    for _ in range(k):        s, e = map(lambda x: int(x)-1, sys.stdin.readline().split())        graph[s][1].append(e)        graph[e][0].append(s)    next_buildings = deque([i for i in range(n) if not graph[i][0]])    for next_ in next_buildings:        r[next_] = d[next_]            target = int(sys.stdin.readline()) - 1            while next_buildings:        now = next_buildings.popleft()        v[now] = 1                for next_ in graph[now][1]:            r[next_] = max(r[next_], r[now] + d[next_])            graph[next_][0].remove(now)                        if next_ == target:                continue                        if not graph[next_][0] and next_ not in next_buildings and not v[next_]:                next_buildings.append(next_)                    print(r[target])특이사항  위상정렬 알고리즘이 기억나지 않아 BFS를 응용해서 풀이  내 코드(36,616KB, 2,164ms)에 비해 우수한 코드(바로가기, 36,512KB, 1,112ms)와 비교                  import syssys.setrecursionlimit(2**16)input = sys.stdin.readlineT = int(input())def get_minimum_time(w):    if visit[w] != -1: return visit[w]    if P[w] == []:        visit[w] = D[w]        return D[w]    maxv = max([ get_minimum_time(item) for item in P[w]])    visit[w] = maxv+D[w]    return visit[w]def testcase():    global edges, P, D, visit    N, K = map(int, input().split())    D = list(map(int, input().split()))    edges = [[] for _ in range(N)]    P = [[] for _ in range(N)]    visit = [ -1 ] * N    for _ in range(K):        a, b = map(int, input().split())        edges[a-1].append(b-1)        P[b-1].append(a-1)    W = int(input())    print(get_minimum_time(W-1))for _ in range(T):    testcase()                    자료구조                  기존: d(딜레이), v(방문확인), graph(부모노드, 자식노드), r(결과)          개선: D(딜레이), v(방문확인), edges(자식노드), P(부모노드)                    탐색 과정                  기존: 모든 시작 가능한 노드에서부터 출발해 목표 노드로          개선: 목표 노드 -&gt; 부모 노드 -&gt; … -&gt; 시작 가능한 노드 순으로 거꾸로 DFS 탐색                    참고문헌-"
  },
  
  {
    "title": "백준 2110번 공유기 설치",
    "url": "/posts/0065_boj_2210/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 이분탐색(binary_search), 매개변수 탐색(parametric_search)",
    "date": "2022-04-22 17:25:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #이분탐색 #매개변수 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.도현이는 언제 어디...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #이분탐색 #매개변수 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다.도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다.C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오.입력첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (0 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다.출력첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다.예제 입출력 1입력5 312849출력3코드(파이썬)import sysdef check(l):    now = routers[0]    result = False    cnt = 0    if n == 2:        result = True    else:        for r in routers[1:]:            if r - now &gt;= l:                now = r                cnt += 1                            if cnt == m-1:                result = True                break            return resultn, m = map(int, sys.stdin.readline().split())routers = sorted([int(sys.stdin.readline()) for _ in range(n)])nearest_max = min(routers[-1]-routers[0], ((routers[-1] + routers[0]) // (m-1))) + 1nearest_min = 1while nearest_min + 1 &lt; nearest_max:    mid = (nearest_max + nearest_min) // 2        if check(mid):        nearest_min = mid    else:        nearest_max = mid    print(nearest_min)특이사항  해결방법          유니온-파인드를 통해 도시들을 트리로 구분지음      출발지와 도착지의 트리 루트가 다르다면 다른 트리에 속하므로 도달할 수 없음        내 코드(40,132KB, 412ms)에 비해 우수한 코드(바로가기, 40,132KB, 316ms)와 비교                  import sysdef binary_search(house, n, start, end):    if start &gt; end:        return end            mid = (start + end) // 2    result = 1    len = house[0]    for i in house:        if len + mid &lt;= i:            len = i            result += 1    if result &gt;= n:        return binary_search(house, n, mid+1, end)    else:        return binary_search(house, n, start, mid-1)input = sys.stdin.readlinen, k = list(map(int, input().split()))house = sorted([int(input()) for i in range(n)])start, end = 1, house[-1] - house[0]print(binary_search(house, k, start, end))                    전체 로직은 유사함      모든 라우터를 확인하는 반복문만 차이가 나므로 해당 부분에서 차이가 발생하는 것으로 추정됨      참고문헌-"
  },
  
  {
    "title": "백준 1976번 여행 가자",
    "url": "/posts/0064_boj_1976/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 자료구조(data_structure), 분리 집합(disjoint_set)",
    "date": "2022-04-21 22:23:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #분리 집합 #자료구조조건            시간 제한      메모리 제한                  2 초      128 MB      문제동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #분리 집합 #자료구조조건            시간 제한      메모리 제한                  2 초      128 MB      문제동혁이는 친구들과 함께 여행을 가려고 한다. 한국에는 도시가 N개 있고 임의의 두 도시 사이에 길이 있을 수도, 없을 수도 있다. 동혁이의 여행 일정이 주어졌을 때, 이 여행 경로가 가능한 것인지 알아보자. 물론 중간에 다른 도시를 경유해서 여행을 할 수도 있다. 예를 들어 도시가 5개 있고, A-B, B-C, A-D, B-D, E-A의 길이 있고, 동혁이의 여행 계획이 E C B C D 라면 E-A-B-C-B-C-B-D라는 여행경로를 통해 목적을 달성할 수 있다.도시들의 개수와 도시들 간의 연결 여부가 주어져 있고, 동혁이의 여행 계획에 속한 도시들이 순서대로 주어졌을 때 가능한지 여부를 판별하는 프로그램을 작성하시오. 같은 도시를 여러 번 방문하는 것도 가능하다.입력첫 줄에 도시의 수 N이 주어진다. N은 200이하이다. 둘째 줄에 여행 계획에 속한 도시들의 수 M이 주어진다. M은 1000이하이다. 다음 N개의 줄에는 N개의 정수가 주어진다. i번째 줄의 j번째 수는 i번 도시와 j번 도시의 연결 정보를 의미한다. 1이면 연결된 것이고 0이면 연결이 되지 않은 것이다. A와 B가 연결되었으면 B와 A도 연결되어 있다. 마지막 줄에는 여행 계획이 주어진다. 도시의 번호는 1부터 N까지 차례대로 매겨져 있다.출력첫 줄에 가능하면 YES 불가능하면 NO를 출력한다.예제 입출력 1입력330 1 01 0 10 1 01 2 3출력YES코드(파이썬)def find(city):    return city if city == cities[city] else find(cities[city])def union(c1, c2):    r1 = find(c1)    r2 = find(c2)                if r1 != r2:        if r1 &gt; r2:            r1, r2 = r2, r1        cities[r2] = r1n = int(input())m = int(input())loads = [list(map(int, input().split())) for _ in range(n)]target = tuple(map(int, input().split()))cities = [i for i in range(n+1)]r = \"YES\"for x in range(n):    for y in range(x, n):        if loads[x][y]:            union(x+1, y+1)for i in range(1, m):    if find(target[i-1]) != find(target[i]):        r = \"NO\"        break    print(r)특이사항  해결방법          유니온-파인드를 통해 도시들을 트리로 구분지음      출발지와 도착지의 트리 루트가 다르다면 다른 트리에 속하므로 도달할 수 없음      참고문헌-"
  },
  
  {
    "title": "백준 2343번 기타 레슨",
    "url": "/posts/0063_boj_2343/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 이분탐색(binary_search), 매개변수 탐색(parametric_search)",
    "date": "2022-04-20 22:23:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #이분탐색 #매개변수 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #이분탐색 #매개변수 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제강토는 자신의 기타 강의 동영상을 블루레이로 만들어 판매하려고 한다. 블루레이에는 총 N개의 강의가 들어가는데, 블루레이를 녹화할 때, 강의의 순서가 바뀌면 안 된다. 순서가 뒤바뀌는 경우에는 강의의 흐름이 끊겨, 학생들이 대혼란에 빠질 수 있기 때문이다. 즉, i번 강의와 j번 강의를 같은 블루레이에 녹화하려면 i와 j 사이의 모든 강의도 같은 블루레이에 녹화해야 한다.강토는 이 블루레이가 얼마나 팔릴지 아직 알 수 없기 때문에, 블루레이의 개수를 가급적 줄이려고 한다. 오랜 고민 끝에 강토는 M개의 블루레이에 모든 기타 강의 동영상을 녹화하기로 했다. 이때, 블루레이의 크기(녹화 가능한 길이)를 최소로 하려고 한다. 단, M개의 블루레이는 모두 같은 크기이어야 한다.강토의 각 강의의 길이가 분 단위(자연수)로 주어진다. 이때, 가능한 블루레이의 크기 중 최소를 구하는 프로그램을 작성하시오.입력첫째 줄에 강의의 수 N (1 ≤ N ≤ 100,000)과 M (1 ≤ M ≤ N)이 주어진다. 다음 줄에는 강토의 기타 강의의 길이가 강의 순서대로 분 단위로(자연수)로 주어진다. 각 강의의 길이는 10,000분을 넘지 않는다.출력첫째 줄에 가능한 블루레이 크기중 최소를 출력한다.예제 입출력 1입력9 31 2 3 4 5 6 7 8 9출력17힌트강의는 총 9개이고, 블루레이는 총 3개 가지고 있다.1번 블루레이에 1, 2, 3, 4, 5, 2번 블루레이에 6, 7, 3번 블루레이에 8, 9 를 넣으면 각 블루레이의 크기는 15, 13, 17이 된다. 블루레이의 크기는 모두 같아야 하기 때문에, 블루레이의 크기는 17이 된다. 17보다 더 작은 크기를 가지는 블루레이를 만들 수 없다.코드(파이썬)import sysdef check(minute):    tmp = 0    cnt = 1        for num in nums:        if tmp + num &lt;= minute:            tmp += num        elif num &lt;= minute:            tmp = num            cnt += 1        else:            break        return True if cnt &lt;= m and minute &gt;= nums[-1] else Falsen, m = map(int, sys.stdin.readline().split())nums = tuple(map(int, sys.stdin.readline().split()))start, end = max(nums)-1, sum(nums)while start + 1 &lt; end:    mid = (start + end) // 2        if check(mid):        end = mid    else:        start = midprint(end)특이사항  매개변수 탐색이라는 알고리즘을 처음 사용          이분탐색과 유사하게 특정 값을 찾음      중요한 것은 1. 탐색 시작과 끝 값의 설정 그리고 2. 결정 함수      최솟값을 찾는다면 [F, …, F, T, T, …, T]의 결정 함수 배열을 가지게 되므로 탐색 종료 후 end      최댓값을 찾는다면 [T, …, T, F, F, …, F]의 결정 함수 배열을 가지게 되므로 탐색 종료 후 start      참고문헌  Anna Jeong, “[Algorithm] Binary Search와 Parametric Search”, Anna’s Analysis, https://annajeong.github.io/algorithm/parametric/  guswns3371, “이진 탐색 &amp; 매개 변수 탐색”, hjoon.log, https://velog.io/@guswns3371/이진-탐색-매개-변수-탐색"
  },
  
  {
    "title": "백준 10830번 행렬 제곱",
    "url": "/posts/0062_boj_10830/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 분할 정복을 이용한 거듭제곱(power_using_divide_and_conquer), 선형대수학(linear_algebra), 수학(math)",
    "date": "2022-04-19 21:31:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #수학 #분할 정복 #분할 정복을 이용한 거듭제곱 #선형대수학조건            시간 제한      메모리 제한                  1 초      256 MB      문제크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #수학 #분할 정복 #분할 정복을 이용한 거듭제곱 #선형대수학조건            시간 제한      메모리 제한                  1 초      256 MB      문제크기가 N*N인 행렬 A가 주어진다. 이때, A의 B제곱을 구하는 프로그램을 작성하시오. 수가 매우 커질 수 있으니, A^B의 각 원소를 1,000으로 나눈 나머지를 출력한다.입력첫째 줄에 행렬의 크기 N과 B가 주어진다. (2 ≤ N ≤  5, 1 ≤ B ≤ 100,000,000,000)둘째 줄부터 N개의 줄에 행렬의 각 원소가 주어진다. 행렬의 각 원소는 1,000보다 작거나 같은 자연수 또는 0이다.출력첫째 줄부터 N개의 줄에 걸쳐 행렬 A를 B제곱한 결과를 출력한다.예제 입출력 1입력2 51 23 4출력69 558337 406예제 입출력 2입력3 31 2 34 5 67 8 9출력468 576 68462 305 548656 34 412예제 입출력 3입력5 101 0 0 0 11 0 0 0 11 0 0 0 11 0 0 0 11 0 0 0 1출력512 0 0 0 512512 0 0 0 512512 0 0 0 512512 0 0 0 512512 0 0 0 512코드(파이썬)def daq(b):    if b in memo:        return memo[b]    else:        tmp1 = daq(b//2)        tmp2 = daq(b//2 + 1) if b%2 else memo[b//2]             r = [[0] * N for _ in range(N)]        for x in range(N):            for y in range(N):                r[x][y] = sum([a*b for a, b in zip(tmp1[x], [tmp2[i][y] for i in range(N)])]) % 1000        memo[b] = r                return rN, B = map(int, input().split())arr = [list(map(lambda x:int(x) % 1000, input().split())) for _ in range(N)]memo = {1:arr}for line in daq(B):    print(*line)특이사항  입력, 출력조건을 명확하게 확인할 필요가 있음참고문헌-"
  },
  
  {
    "title": "백준 1987번 알파벳",
    "url": "/posts/0061_boj_1987/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search), 백트래킹(backtracking)",
    "date": "2022-04-18 21:29:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념:  #그래프이론 #그래프탐색 #깊이 우선 탐색 #백트래킹조건            시간 제한      메모리 제한                  2 초      256 MB      문제세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념:  #그래프이론 #그래프탐색 #깊이 우선 탐색 #백트래킹조건            시간 제한      메모리 제한                  2 초      256 MB      문제세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.입력첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.출력첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.예제 입출력 1입력2 4CAABADCB출력3예제 입출력 2입력3 6HFDFFBAJHGDHDGAGEH출력6예제 입출력 3입력5 5IEFCJFHFKCFFALFHFGCFHMCHH출력10코드(파이썬)r, c = map(int, input().split())board = [list(input()) for _ in range(r)]candidate = set([(0, 0, board[0][0])])result = 1d = {(x, y): [(x+dx, y+dy) for dx, dy in ((0, 1), (0, -1), (1, 0), (-1, 0)) if 0&lt;=x+dx&lt;=r-1 and 0&lt;=y+dy&lt;=c-1]\\     for y in range(c) for x in range(r)}while candidate:    x, y, s = candidate.pop()        for n_x, n_y in d[(x, y)]:        if board[n_x][n_y] not in s:            result = max(result, len(s + board[n_x][n_y]))            candidate.add((n_x, n_y, s + board[n_x][n_y]))print(result)특이사항  DFS로 풀어보려했으나 20여일의 시도 끝에 포기하고 BFS로 풀이  다음 좌표를 정할 때 d 리스트를 미리 생성해 처리하는 방법을 이용해 1000ms 정도의 이득을 볼 수 있었음참고문헌-"
  },
  
  {
    "title": "백준 11404번 플로이드",
    "url": "/posts/0060_boj_11404/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 플로이드-워셜 알고리즘(floyd_warshall_algorithm)",
    "date": "2022-04-14 22:47:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      256 MB      문제n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      256 MB      문제n(2 ≤ n ≤ 100)개의 도시가 있다. 그리고 한 도시에서 출발하여 다른 도시에 도착하는 m(1 ≤ m ≤ 100,000)개의 버스가 있다. 각 버스는 한 번 사용할 때 필요한 비용이 있다.모든 도시의 쌍 (A, B)에 대해서 도시 A에서 B로 가는데 필요한 비용의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 도시의 개수 n이 주어지고 둘째 줄에는 버스의 개수 m이 주어진다. 그리고 셋째 줄부터 m+2줄까지 다음과 같은 버스의 정보가 주어진다. 먼저 처음에는 그 버스의 출발 도시의 번호가 주어진다. 버스의 정보는 버스의 시작 도시 a, 도착 도시 b, 한 번 타는데 필요한 비용 c로 이루어져 있다. 시작 도시와 도착 도시가 같은 경우는 없다. 비용은 100,000보다 작거나 같은 자연수이다.시작 도시와 도착 도시를 연결하는 노선은 하나가 아닐 수 있다.출력n개의 줄을 출력해야 한다. i번째 줄에 출력하는 j번째 숫자는 도시 i에서 j로 가는데 필요한 최소 비용이다. 만약, i에서 j로 갈 수 없는 경우에는 그 자리에 0을 출력한다.예제 입출력 1입력5141 2 21 3 31 4 11 5 102 4 23 4 13 5 14 5 33 5 103 1 81 4 25 1 73 4 25 2 4출력0 2 3 1 412 0 15 2 58 5 0 1 110 7 13 0 37 4 10 6 0코드(파이썬)import sysn = int(sys.stdin.readline())m = int(sys.stdin.readline())inf = 10000001graph = [[inf] * n for _ in range(n)]for i in range(n):    graph[i][i] = 0for _ in range(m):    s, e, w = map(int, sys.stdin.readline().split())    graph[s-1][e-1] = min(graph[s-1][e-1] , w)for m in range(n):    for s in range(n):        for e in range(n):            graph[s][e] = min(graph[s][e], graph[s][m]+graph[m][e])for line in graph:    sys.stdout.write(\" \".join([str(i) if i != inf else \"0\" for i in line]) + \"\\n\")특이사항  모든 정점의 최단경로가 필요하므로 다익스트라 알고리즘 대신 플로이드-워셜 알고리즘 사용  inf 값이 작아 오류 발생 -&gt; max_distance = float(\"inf\") 사용참고문헌-"
  },
  
  {
    "title": "R 기초 - 설치",
    "url": "/posts/2001_R_install/",
    "categories": "Programming, R",
    "tags": "프로그래밍(programming), R(r), 기초(basic), 설치(install)",
    "date": "2022-04-13 23:16:00 +0900",
    





    
    "snippet": "개요안녕하세요, 오늘 주제는 프로그래밍 언어 R의 개요와 설치입니다.R이라는 언어에 대해 간략하게 알아보고 설치해보겠습니다.프로그래밍 언어 R의 개요R이란R은 프로그래밍 언어입니다.하지만 우리가 들어본 C, JAVA, Python과 R은 목적에서 차이를 보입니다.전자의 경우 범용성을 보입니다. 각각 특화된 분야는 다르지만 웹, 애플리케이션 등 다양한 ...",
    "content": "개요안녕하세요, 오늘 주제는 프로그래밍 언어 R의 개요와 설치입니다.R이라는 언어에 대해 간략하게 알아보고 설치해보겠습니다.프로그래밍 언어 R의 개요R이란R은 프로그래밍 언어입니다.하지만 우리가 들어본 C, JAVA, Python과 R은 목적에서 차이를 보입니다.전자의 경우 범용성을 보입니다. 각각 특화된 분야는 다르지만 웹, 애플리케이션 등 다양한 활용이 가능합니다.그에 반해 R은 통계 계산과 그래픽을 중점으로 개발된 언어입니다.R의 특성  인터프리터 언어(프로그래밍 언어의 소스코드를 바로 실행하는 언어)입니다.  변수들이 저장되는 환경이라는 데이터 타입이 있습니다.  통계 관련 패키지가 다수 개발되어 있습니다.  정적인 그래프(plot 패키지 등)와 인터렉티브한 그래프(ggplot2 패키지 등) 모두 지원합니다.  구글이나 네이버의 지도를 활용할 수 있습니다.(ggmap 패키지 등)  데이터 마이닝, 빅데이터 프로세싱에 유용합니다.R과 R Studio의 설치설치 환경 및 기준 버전  운영체제: Windows 10  R: 4.1.3  RStudio: 2022.02.1+461설치 과정  R을 설치합니다.          R 프로젝트 페이지에 접속합니다.      왼쪽 메뉴에서 Download 항목의 CRAN을 클릭합니다.      다운로드할 위치를 클릭합니다. 여기서는 지리적으로 가까운 Korea의 cran.seoul.go.kr/을 클릭하겠습니다.      운영체제에 맞는 버전을 클릭합니다. 여기서는 Download R for Windows를 클릭하겠습니다.      여러 Subdirectory 중 base를 클릭합니다.      Download를 클릭합니다.      다운로드한 설치 파일을 실행합니다.      시작버튼을 누르고 R을 실행해봅니다. 여기서는 간단하게 print(\"Hello, 안녕하세요!\") 를 실행해보겠습니다.        R Studio를 설치합니다.          R Studio 페이지에 접속합니다.      위쪽 메뉴에서 Products - Open Soruce 항목의 RStudio를 클릭합니다.      RStuido Desktop 버전을 클릭한 뒤 Open Source Edition을 클릭합니다.      RStudio Desktop 버전의 Download를 클릭합니다.      운영체제에 맞는 버전을 클릭합니다. 여기서는 Wiondows 10 버전을 클릭하겠습니다.      다운로드한 설치 파일을 실행합니다.      시작버튼을 누르고 R Studio를 실행해봅니다.      왼쪽 아래의 Console 창에서 print(\"Hello, 안녕하세요!\") 를 실행해봅니다.      R Studio 설치 이유R 스튜디오는 R의 통합 개발 환경(IDE, Integrated Development Environment)를 지원합니다. IDE는 코딩, 디버그, 컴파일, 배포 등 프로그램 개발에 필요한 작업을 모두 제공합니다. 따라서 R의 기본 응용프로그램 대신 R 스튜디오를 설치해서 사용합니다.참고문헌  오세종, 신현석, 난생처음 R 코딩 &amp; 데이터 분석, 한빛아카데미, 2021"
  },
  
  {
    "title": "백준 14938번 서강그라운드",
    "url": "/posts/0059_boj_14938/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra), 플로이드-워셜 알고리즘(floyd_warshall_algorithm)",
    "date": "2022-04-12 23:04:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #다익스트라 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      128 MB      문제예은이는 요즘 가장 인기가 있는 게임 서강그라운드를 즐기고 있다. 서강그라운드는 여러 지역중 하나의 지역에 낙하산을 타고 낙하하여...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #다익스트라 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      128 MB      문제예은이는 요즘 가장 인기가 있는 게임 서강그라운드를 즐기고 있다. 서강그라운드는 여러 지역중 하나의 지역에 낙하산을 타고 낙하하여, 그 지역에 떨어져 있는 아이템들을 이용해 서바이벌을 하는 게임이다. 서강그라운드에서 1등을 하면 보상으로 치킨을 주는데, 예은이는 단 한번도 치킨을 먹을 수가 없었다. 자신이 치킨을 못 먹는 이유는 실력 때문이 아니라 아이템 운이 없어서라고 생각한 예은이는 낙하산에서 떨어질 때 각 지역에 아이템 들이 몇 개 있는지 알려주는 프로그램을 개발을 하였지만 어디로 낙하해야 자신의 수색 범위 내에서 가장 많은 아이템을 얻을 수 있는지 알 수 없었다.각 지역은 일정한 길이 l (1 ≤ l ≤ 15)의 길로 다른 지역과 연결되어 있고 이 길은 양방향 통행이 가능하다. 예은이는 낙하한 지역을 중심으로 거리가 수색 범위 m (1 ≤ m ≤ 15) 이내의 모든 지역의 아이템을 습득 가능하다고 할 때, 예은이가 얻을 수 있는 아이템의 최대 개수를 알려주자.주어진 필드가 위의 그림과 같고, 예은이의 수색범위가 4라고 하자. ( 원 밖의 숫자는 지역 번호, 안의 숫자는 아이템 수, 선 위의 숫자는 거리를 의미한다) 예은이가 2번 지역에 떨어지게 되면 1번,2번(자기 지역), 3번, 5번 지역에 도달할 수 있다. (4번 지역의 경우 가는 거리가 3 + 5 = 8 &gt; 4(수색범위) 이므로 4번 지역의 아이템을 얻을 수 없다.) 이렇게 되면 예은이는 23개의 아이템을 얻을 수 있고, 이는 위의 필드에서 예은이가 얻을 수 있는 아이템의 최대 개수이다.입력첫째 줄에는 지역의 개수 n (1 ≤ n ≤ 100)과 예은이의 수색범위 m (1 ≤ m ≤ 15), 길의 개수 r (1 ≤ r ≤ 100)이 주어진다.둘째 줄에는 n개의 숫자가 차례대로  각 구역에 있는 아이템의 수 t (1 ≤ t ≤ 30)를 알려준다.세 번째 줄부터 r+2번째 줄 까지 길 양 끝에 존재하는 지역의 번호 a, b, 그리고 길의 길이 l (1 ≤ l ≤ 15)가 주어진다.출력예은이가 얻을 수 있는 최대 아이템 개수를 출력한다.예제 입출력 1입력5 5 45 7 8 2 31 4 55 2 43 2 31 2 3출력23코드(파이썬)import heapqimport sysn, m, r = map(int, sys.stdin.readline().split())field = [0] + list(map(int, sys.stdin.readline().split()))graph = {i:[] for i in range(1, n+1)}result = -1# 그래프 생성for _ in range(r):    s, e, w = map(int, sys.stdin.readline().split())    graph[s].append((e, w))    graph[e].append((s, w))    # 정점 별로 다익스트라for start in range(1, n+1):    visited = [False for _ in range(n + 1)]    d = [0] + [16 for _ in range(n)]    heap = [(0, start)]        while heap:        w, node = heapq.heappop(heap)                if w &gt; m:            break        elif not visited[node]:            d[node] = w            visited[node] = True                        for node2, w2 in graph[node]:                heapq.heappush(heap, (w+w2, node2))            result = max(result, sum([field[i] for i in range(1, n+1) if 0 &lt;= d[i] &lt;= m]))    print(result)특이사항  풀이과정          정점 별로 다익스트라 수행      다른 정점까지의 최단경로가 수색범위보다 작은 값들의 아이템들을 result에 저장      참고문헌-"
  },
  
  {
    "title": "백준 1967번 트리의 지름",
    "url": "/posts/0058_boj_1967/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 트리(tree), 깊이우선탐색(depth_first_search)",
    "date": "2022-04-11 21:11:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #트리조건            시간 제한      메모리 제한                  2 초      128 MB      문제트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #트리조건            시간 제한      메모리 제한                  2 초      128 MB      문제트리(tree)는 사이클이 없는 무방향 그래프이다. 트리에서는 어떤 두 노드를 선택해도 둘 사이에 경로가 항상 하나만 존재하게 된다. 트리에서 어떤 두 노드를 선택해서 양쪽으로 쫙 당길 때, 가장 길게 늘어나는 경우가 있을 것이다. 이럴 때 트리의 모든 노드들은 이 두 노드를 지름의 끝 점으로 하는 원 안에 들어가게 된다.이런 두 노드 사이의 경로의 길이를 트리의 지름이라고 한다. 정확히 정의하자면 트리에 존재하는 모든 경로들 중에서 가장 긴 것의 길이를 말한다.입력으로 루트가 있는 트리를 가중치가 있는 간선들로 줄 때, 트리의 지름을 구해서 출력하는 프로그램을 작성하시오. 아래와 같은 트리가 주어진다면 트리의 지름은 45가 된다.트리의 노드는 1부터 n까지 번호가 매겨져 있다.입력파일의 첫 번째 줄은 노드의 개수 n(1 ≤ n ≤ 10,000)이다. 둘째 줄부터 n-1개의 줄에 각 간선에 대한 정보가 들어온다. 간선에 대한 정보는 세 개의 정수로 이루어져 있다. 첫 번째 정수는 간선이 연결하는 두 노드 중 부모 노드의 번호를 나타내고, 두 번째 정수는 자식 노드를, 세 번째 정수는 간선의 가중치를 나타낸다. 간선에 대한 정보는 부모 노드의 번호가 작은 것이 먼저 입력되고, 부모 노드의 번호가 같으면 자식 노드의 번호가 작은 것이 먼저 입력된다. 루트 노드의 번호는 항상 1이라고 가정하며, 간선의 가중치는 100보다 크지 않은 양의 정수이다.출력첫째 줄에 트리의 지름을 출력한다.예제 입출력 1입력121 2 31 3 22 4 53 5 113 6 94 7 14 8 75 9 155 10 46 11 66 12 10출력45코드(파이썬)import sysfrom collections import defaultdictdef check(node):    global result    candidate = [0, 0]        for c, w in tree[node]:        if c in tree:            w += check(c)                if w &gt; candidate[0]:            candidate[1] = candidate[0]            candidate[0] = w        elif w &gt; candidate[1]:            candidate[1] = w                result = max(sum(candidate), result)    return candidate[0]    sys.setrecursionlimit(100000)n = int(sys.stdin.readline())tree = defaultdict(list)result = 0for i in range(n-1):    p, c, w = map(int, sys.stdin.readline().split())    tree[p].append([c, w])check(1)print(result)특이사항  풀이과정          {부모노드: [(자식노드, 가중치), (자식노드, 가중치), …], …} 형태의 tree 딕셔너리 생성      현재노드에서 자식노드 중 가중치가 가장 큰 값 2개 선택      현재노드에서 가장 가중치가 큰 값과 result를 비교해 더 큰 값을 result에 저장      현재노드에서 가장 가중치가 큰 값을 반환      참고문헌-"
  },
  
  {
    "title": "백준 1647번 도시 분할 계획",
    "url": "/posts/0057_boj_2123/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 최소 신장 트리(minimum_spanning_tree)",
    "date": "2022-04-08 16:50:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #최소 스패닝 트리조건            시간 제한      메모리 제한                  2 초      256 MB      문제동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #최소 스패닝 트리조건            시간 제한      메모리 제한                  2 초      256 MB      문제동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그러다가 평화로운 마을에 가게 되었는데, 그곳에서는 알 수 없는 일이 벌어지고 있었다.마을은 N개의 집과 그 집들을 연결하는 M개의 길로 이루어져 있다. 길은 어느 방향으로든지 다닐 수 있는 편리한 길이다. 그리고 각 길마다 길을 유지하는데 드는 유지비가 있다.마을의 이장은 마을을 두 개의 분리된 마을로 분할할 계획을 가지고 있다. 마을이 너무 커서 혼자서는 관리할 수 없기 때문이다. 마을을 분할할 때는 각 분리된 마을 안에 집들이 서로 연결되도록 분할해야 한다. 각 분리된 마을 안에 있는 임의의 두 집 사이에 경로가 항상 존재해야 한다는 뜻이다. 마을에는 집이 하나 이상 있어야 한다.그렇게 마을의 이장은 계획을 세우다가 마을 안에 길이 너무 많다는 생각을 하게 되었다. 일단 분리된 두 마을 사이에 있는 길들은 필요가 없으므로 없앨 수 있다. 그리고 각 분리된 마을 안에서도 임의의 두 집 사이에 경로가 항상 존재하게 하면서 길을 더 없앨 수 있다. 마을의 이장은 위 조건을 만족하도록 길들을 모두 없애고 나머지 길의 유지비의 합을 최소로 하고 싶다. 이것을 구하는 프로그램을 작성하시오.입력첫째 줄에 집의 개수 N, 길의 개수 M이 주어진다. N은 2이상 100,000이하인 정수이고, M은 1이상 1,000,000이하인 정수이다. 그 다음 줄부터 M줄에 걸쳐 길의 정보가 A B C 세 개의 정수로 주어지는데 A번 집과 B번 집을 연결하는 길의 유지비가 C (1 ≤ C ≤ 1,000)라는 뜻이다.출력첫째 줄에 없애고 남은 길 유지비의 합의 최솟값을 출력한다.예제 입출력 1입력7 121 2 31 3 23 2 12 5 23 4 47 3 65 1 51 6 26 4 16 5 34 5 36 7 4출력8코드(파이썬)import sysdef find(x):    return x if p[x] == x else find(p[x])n, m = map(int, sys.stdin.readline().split())edges = list()p = dict()result = 0cnt = 0for _ in range(m):    s, e, d = map(int, sys.stdin.readline().split())    edges.append((d, s, e))    p[s] = s    p[e] = e    edges.sort(key=lambda e:-e[0])    while cnt &lt; n-2:    d, s, e = edges.pop()    r1 = find(s)    r2 = find(e)                if r1 != r2:        cnt += 1        result += d                if r1 &lt; r2:            p[r2] = p[r1]        else:            p[r1] = p[r2]            print(result)특이사항  최소 스패닝 트리(최소 신장 트리) 문제  여기서는 크루스칼 알고리즘을 사용          모든 간선을 거리를 오름차순으로 정렬      가장 거리가 작은 간선을 가져옴      각 간선이 속한 트리가 다르다면 두 트리를 합침      모든 정점을 합칠 때까지 반복      트리의 표현은 배열을 활용했으며 Union, Find 메서드를 적용        프림 알고리즘을 사용했으나 시간 초과          프림 알고리즘 시간복잡도: $O(n) = E log V $      크루스칼 알고리즘 시간복잡도: $O(n) = E log E $      이 문제는 정점의 개수에 비해 간선의 개수가 비교적 적으므로 크루스칼 알고리즘이 적합      참고문헌  문병로, 쉽게 배우는 알고리즘 :관계 중심의 사고법, 문병로, 2018"
  },
  
  {
    "title": "백준 1197번 최소 스패닝 트리",
    "url": "/posts/0056_boj_1197/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 최소 신장 트리(minimum_spanning_tree)",
    "date": "2022-04-07 22:50:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [[클릭](https://www.acmicpc.net/problem/1197]난이도: Gold4관련 개념: #그래프이론 #최소 스패닝 트리조건            시간 제한      메모리 제한                  1 초      128 MB      문제그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그...",
    "content": "정보문제 바로가기 [[클릭](https://www.acmicpc.net/problem/1197]난이도: Gold4관련 개념: #그래프이론 #최소 스패닝 트리조건            시간 제한      메모리 제한                  1 초      128 MB      문제그래프가 주어졌을 때, 그 그래프의 최소 스패닝 트리를 구하는 프로그램을 작성하시오.최소 스패닝 트리는, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리를 말한다.입력첫째 줄에 정점의 개수 V(1 ≤ V ≤ 10,000)와 간선의 개수 E(1 ≤ E ≤ 100,000)가 주어진다. 다음 E개의 줄에는 각 간선에 대한 정보를 나타내는 세 정수 A, B, C가 주어진다. 이는 A번 정점과 B번 정점이 가중치 C인 간선으로 연결되어 있다는 의미이다. C는 음수일 수도 있으며, 절댓값이 1,000,000을 넘지 않는다.그래프의 정점은 1번부터 V번까지 번호가 매겨져 있고, 임의의 두 정점 사이에 경로가 있다. 최소 스패닝 트리의 가중치가 -2,147,483,648보다 크거나 같고, 2,147,483,647보다 작거나 같은 데이터만 입력으로 주어진다.출력첫째 줄에 최소 스패닝 트리의 가중치를 출력한다.예제 입출력 1입력3 31 2 12 3 21 3 3출력3코드(파이썬)import sysimport heapqfrom collections import defaultdictv, e = map(int, sys.stdin.readline().split())graph = defaultdict(list)dist = list()result = 0for _ in range(e):    n1, n2, d = map(int, sys.stdin.readline().split())    graph[n1].append((d, n2))    graph[n2].append((d, n1))not_visited = [False] + [True for _ in range(v)]heapq.heappush(dist, (0, n1))for _ in range(v):    while dist:        d_tmp, now = heapq.heappop(dist)        if not_visited[now]:            min_dist = d_tmp            break        result += min_dist    not_visited[now] = False    for new_node in graph[now]:        heapq.heappush(dist, new_node)        print(result)특이사항  최소 스패닝 트리(최소 신장 트리) 문제  여기서는 프림 알고리즘을 사용          dist 힙에서 방문하지 않은 최소 거리 노드 pop      해당 노드에서 갈 수 있는 노드를 거리 순으로 dist 힙에 저장      모든 노드를 방문할 때까지 반복      참고문헌-"
  },
  
  {
    "title": "백준 11048번 이동하기",
    "url": "/posts/0055_boj_11048/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-04-06 22:50:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제준규는 N×M 크기의 미로에 갇혀있다. 미로는 1×1크기의 방으로 나누어져 있고, 각 방에는 사탕이 놓여져 있다. 미로의 가장 왼쪽 윗 방은 (1, 1)이고, 가장 오른쪽 아랫 방은 (N, M)이다.준규는 현재 (1, 1)에 있고, (N, M)으로 이동하려고 한다. 준규가 (r, c)에 있으면, (r+1, c), (r, c+1), (r+1, c+1)로 이동할 수 있고, 각 방을 방문할 때마다 방에 놓여져있는 사탕을 모두 가져갈 수 있다. 또, 미로 밖으로 나갈 수는 없다.준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수의 최댓값을 구하시오.입력첫째 줄에 미로의 크기 N, M이 주어진다. (1 ≤ N, M ≤ 1,000)둘째 줄부터 N개 줄에는 총 M개의 숫자가 주어지며, r번째 줄의 c번째 수는 (r, c)에 놓여져 있는 사탕의 개수이다. 사탕의 개수는 0보다 크거나 같고, 100보다 작거나 같다.출력첫째 줄에 준규가 (N, M)으로 이동할 때, 가져올 수 있는 사탕 개수를 출력한다.예제 입출력 1입력3 41 2 3 40 0 0 59 8 7 6출력31예제 입출력 2입력3 31 0 00 1 00 0 1출력3예제 입출력 3입력4 31 2 36 5 47 8 912 11 10출력47코드(파이썬)import sysn, m = map(int, sys.stdin.readline().split())maze = [[0] * (m+1)] + ([[0] + list(map(int, sys.stdin.readline().split())) for _ in range(n)])for i in range(1, n+1):    for j in range(1, m+1):        maze[i][j] += max(maze[i-1][j], maze[i][j-1])    print(maze[-1][-1])특이사항  DP 문제 연습참고문헌-"
  },
  
  {
    "title": "백준 1074번 Z",
    "url": "/posts/0054_boj_1074/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 재귀(recursion)",
    "date": "2022-04-05 23:07:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #분할 정복 #재귀조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      512 MB      문제한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #분할 정복 #재귀조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      512 MB      문제한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.N &gt; 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.다음 예는 22 × 22 크기의 배열을 방문한 순서이다.N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.다음은 N=3일 때의 예이다.입력첫째 줄에 정수 N, r, c가 주어진다.출력r행 c열을 몇 번째로 방문했는지 출력한다.제한  1 ≤ N ≤ 15  0 ≤ r, c &lt; 2N예제 입출력 1입력2 3 1출력11예제 입출력 2입력3 7 7출력63예제 입출력 3입력1 0 0출력0예제 입출력 4입력4 7 7출력63예제 입출력 5입력10 511 511출력262143예제 입출력 6입력10 512 512출력786432코드(파이썬)n, r, c = tuple(map(int, input().split()))r, c = r+1, c+1result = 0for i in range(n-1, -1, -1):    if r &gt; 2**i and c &gt; 2**i:        result += 3 * 2 ** (2 * i)        r -= 2**i        c -= 2**i    elif r &gt; 2**i:        result += 2 * 2 ** (2 * i)        r -= 2**i    elif c &gt; 2**i:        result += 2 ** (2 * i)        c -= 2**i    print(result)특이사항  해결 과정          현재 배열을 4등분      4등분한 배열 중 타겟의 구역을 r과 c 이용해 확인      result에 타켓이 속한 구역의 시작 지점을 더함      타겟이 속한 구역을 현재 배열로 처리하기 위해 r과 c 조정      n번 반복      참고문헌-"
  },
  
  {
    "title": "백준 13549번 숨바꼭질 3",
    "url": "/posts/0053_boj_13549/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 자료구조(data_structure), 너비우선탐색(breadth_first_search), 다익스트라(dijkstra), 0-1 너비우선탐색(0-1_breadth_first_search)",
    "date": "2022-04-04 21:32:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색 #다익스트라 #자료구조 #0-1 너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 10...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색 #다익스트라 #자료구조 #0-1 너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.출력수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.예제 입출력 1입력5 17출력2힌트수빈이가 5-10-9-18-17 순으로 가면 2초만에 동생을 찾을 수 있다.코드(파이썬)from collections import deques, e = map(int, input().split())graph = {i:[i-1, i+1] + ([i*2] if i*2 &lt; 100001 else []) for i in range(1, 100000)}graph[0] = [1]graph[100000] = [99999]visited = [0] * 100001result = 0if s &gt; e:    result = s - eelse:    queue = deque([s])    tmp = s*2    while 0 &lt; tmp &lt;= 100000:        visited[tmp] = 1        queue.append(tmp)        tmp *= 2                while queue:        if e in queue:            break                for _ in range(len(queue)):            for tmp in graph[queue.popleft()]:                if visited[tmp] == 0:                    visited[tmp] = 1                    queue.append(tmp)                    tmp *= 2                                        while 0 &lt; tmp &lt;= 100000:                        if visited[tmp] == 0:                            visited[tmp] = 1                            queue.append(tmp)                        tmp *= 2        result += 1    print(result)특이사항  BFS를 이용해 해결하였으나 최적화를 거치지 않아 메모리, 속도 측면에서 불리  내 코드(56,220KB, 188ms)에 비해 우수한 코드(바로가기, 30,864KB, 72ms)와 비교                  def F(N,K):    if N&gt;=K:return N-K    elif K==1:return 1    elif K%2:return min(F(N,K-1),F(N,K+1))+1    else:return min(K-N,F(N,K//2))N,K=map(int,input().split())print(F(N,K))                    BFS대신 DFS를 이용      간단하고 효율적인 풀이방식      참고문헌-"
  },
  
  {
    "title": "백준 11054번 가장 긴 바이토닉 부분 수열",
    "url": "/posts/0052_boj_11054/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-04-01 22:38:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제수열 S가 어떤 수 Sk를 기준으로 S1 &lt; S2 &lt; … Sk-1 &lt; Sk &gt; Sk+1 &gt; … SN-1 &gt; SN을 만...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제수열 S가 어떤 수 Sk를 기준으로 S1 &lt; S2 &lt; … Sk-1 &lt; Sk &gt; Sk+1 &gt; … SN-1 &gt; SN을 만족한다면, 그 수열을 바이토닉 수열이라고 한다.예를 들어, {10, 20, 30, 25, 20}과 {10, 20, 30, 40}, {50, 40, 25, 10} 은 바이토닉 수열이지만,  {1, 2, 3, 2, 1, 2, 3, 2, 1}과 {10, 20, 30, 40, 20, 30} 은 바이토닉 수열이 아니다.수열 A가 주어졌을 때, 그 수열의 부분 수열 중 바이토닉 수열이면서 가장 긴 수열의 길이를 구하는 프로그램을 작성하시오.입력첫째 줄에 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ Ai ≤ 1,000)출력첫째 줄에 수열 A의 부분 수열 중에서 가장 긴 바이토닉 수열의 길이를 출력한다.예제 입출력 1입력101 5 2 1 4 3 4 5 2 1출력7힌트예제의 경우 {1 5 2 1 4 3 4 5 2 1}이 가장 긴 바이토닉 부분 수열이다.코드(파이썬)n = int(input())array = list(map(int, input().split()))dp = [1]dp2 = [1]for i, num in enumerate(array[1:], 1):    dp.append(max([dp[j] if array[j] &lt; num else 0 for j in range(i)])+1)array = array[::-1]for i, num in enumerate(array[1:], 1):    dp2.append(max([dp2[j] if array[j] &lt; num else 0 for j in range(i)])+1)print(max([dp[i]+dp2[n-i-1] for i in range(n)]) - 1)특이사항  풀이방법          이전에 학습한 LIS 알고리즘을 사용함      주어진 숫자 리스트를 시작에서 차례대로 가장 긴 증가 부분수열을 dp 리스트에 저장      주어진 숫자 리스트를 끝에서 거꾸로 가장 긴 증가 부분수열을 dp2 리스트에 저장      dp2 리스트를 뒤집으면 해당 숫자에서 가장 긴 감소 부분수열을 얻을 수 있음      dp1과 뒤집은 dp2를 더한 값 중 최대 값에서 해당 숫자가 2번 포함되어있으므로 1을 빼면 가장 긴 바이토닉 부분 수열 계산 완료        내 코드(30,864KB, 172ms)에 비해 우수한 코드(바로가기, 152,408KB, 1,212ms)와 비교                  from collections import dequen = int(input())A = list(map(int, input().split()))result1 = []result2 = deque()dp1 = [0] * 1001dp2 = [0] * 1001for i in A:    tmp = max(dp1[:i]) + 1    dp1[i] = tmp    result1.append(tmp)for i in A[::-1]:    tmp2 = max(dp2[:i]) + 1    dp2[i] = tmp2    result2.appendleft(tmp2)sol = 0for i in range(len(result1)):    sol = max(sol, result1[i] + result2[i])print(sol - 1)                    동일한 풀이이지만 기존보다 간단한 구현이 보임      최적화하는 방법을 더 공부할 필요성이 있음      참고문헌-"
  },
  
  {
    "title": "백준 17298번 오큰수",
    "url": "/posts/0051_boj_17298/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 스택(stack)",
    "date": "2022-03-31 22:12:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #스택조건            시간 제한      메모리 제한                  1 초      512 MB      문제크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #스택조건            시간 제한      메모리 제한                  1 초      512 MB      문제크기가 N인 수열 A = A1, A2, …, AN이 있다. 수열의 각 원소 Ai에 대해서 오큰수 NGE(i)를 구하려고 한다. Ai의 오큰수는 오른쪽에 있으면서 Ai보다 큰 수 중에서 가장 왼쪽에 있는 수를 의미한다. 그러한 수가 없는 경우에 오큰수는 -1이다.예를 들어, A = [3, 5, 2, 7]인 경우 NGE(1) = 5, NGE(2) = 7, NGE(3) = 7, NGE(4) = -1이다. A = [9, 5, 4, 8]인 경우에는 NGE(1) = -1, NGE(2) = 8, NGE(3) = 8, NGE(4) = -1이다.입력첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000,000)이 주어진다. 둘째 줄에 수열 A의 원소 A1, A2, …, AN (1 ≤ Ai ≤ 1,000,000)이 주어진다.출력총 N개의 수 NGE(1), NGE(2), …, NGE(N)을 공백으로 구분해 출력한다.예제 입출력 1입력43 5 2 7출력5 7 7 -1예제 입출력 2입력49 5 4 8출력-1 8 8 -1코드(파이썬)import sysn = int(sys.stdin.readline())nums = list(map(int, sys.stdin.readline().split()))stack = [(0, nums[0])]for i, num in enumerate(nums[1:], 1):    if num &gt; stack[-1][1]:        while stack and stack[-1][1] &lt; num:            nums[stack.pop()[0]] = num        stack.append((i, num))for i, _ in stack:    nums[i] = -1print(*nums)특이사항  풀이방법          스택에 숫자와 그 인덱스를 저장      지금 숫자가 스택의 마지막 숫자보다 작다면 스택에 추가      크다면 스택에서 인덱스를 꺼내 nums를 업데이트      아직 스택에 남은 숫자가 있다면 오큰수가 없는 숫자이므로 그 인덱스의 nums를 -1로 업데이트      nums 출력        내 코드(189,960KB, 1,320ms)에 비해 우수한 코드(바로가기, 152,408KB, 1,212ms)와 비교                  N = int(input())array =list(map(int,input().split()))result = [-1]*Nstack=[]for i in reversed(range(N)):    while stack and stack[-1] &lt;= array[i]:        stack.pop()    if not stack:        result[i] = -1    else:        result[i] = stack[-1]    stack.append(array[i])        print(*result)                    입력 숫자 반복                  기존: 1부터 시작          개선: n부터 시작                    결과 저장                  기존: nums 업데이트          개선: r 리스트에 저장                    스택에 저장하는 값                  기존: 모든 숫자          개선: 마지막 삽입 숫자보다 작은 숫자                    참고문헌-"
  },
  
  {
    "title": "백준 10844번 쉬운 계단 수",
    "url": "/posts/0050_boj_10844/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-30 23:01:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제45656이란 수를 보자.이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.N이 주어질 때, 길이가 N인 계단 수가 총 몇...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제45656이란 수를 보자.이 수는 인접한 모든 자리의 차이가 1이다. 이런 수를 계단 수라고 한다.N이 주어질 때, 길이가 N인 계단 수가 총 몇 개 있는지 구해보자. 0으로 시작하는 수는 계단수가 아니다.입력첫째 줄에 N이 주어진다. N은 1보다 크거나 같고, 100보다 작거나 같은 자연수이다.출력첫째 줄에 정답을 1,000,000,000으로 나눈 나머지를 출력한다.예제 입출력 1입력1출력9예제 입출력 2입력2출력17코드(파이썬)n = int(input())dp = [0] + [1]*9remainder = 1000000000for _ in range(n-1):    tmp = dp.copy()        dp[0] = tmp[1]    for i in range(1, 9):        dp[i] = (tmp[i-1] + tmp[i+1]) % remainder    dp[9] = tmp[8]print(sum(dp) % remainder)특이사항  간단한 DP 문제참고문헌-"
  },
  
  {
    "title": "백준 2565번 전깃줄",
    "url": "/posts/0049_boj_2565/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-29 22:56:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      128 MB      문제두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      128 MB      문제두 전봇대 A와 B 사이에 하나 둘씩 전깃줄을 추가하다 보니 전깃줄이 서로 교차하는 경우가 발생하였다. 합선의 위험이 있어 이들 중 몇 개의 전깃줄을 없애 전깃줄이 교차하지 않도록 만들려고 한다.예를 들어, &lt; 그림 1 &gt;과 같이 전깃줄이 연결되어 있는 경우 A의 1번 위치와 B의 8번 위치를 잇는 전깃줄, A의 3번 위치와 B의 9번 위치를 잇는 전깃줄, A의 4번 위치와 B의 1번 위치를 잇는 전깃줄을 없애면 남아있는 모든 전깃줄이 서로 교차하지 않게 된다.&lt; 그림 1 &gt;전깃줄이 전봇대에 연결되는 위치는 전봇대 위에서부터 차례대로 번호가 매겨진다. 전깃줄의 개수와 전깃줄들이 두 전봇대에 연결되는 위치의 번호가 주어질 때, 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에는 두 전봇대 사이의 전깃줄의 개수가 주어진다. 전깃줄의 개수는 100 이하의 자연수이다. 둘째 줄부터 한 줄에 하나씩 전깃줄이 A전봇대와 연결되는 위치의 번호와 B전봇대와 연결되는 위치의 번호가 차례로 주어진다. 위치의 번호는 500 이하의 자연수이고, 같은 위치에 두 개 이상의 전깃줄이 연결될 수 없다.출력첫째 줄에 남아있는 모든 전깃줄이 서로 교차하지 않게 하기 위해 없애야 하는 전깃줄의 최소 개수를 출력한다.예제 입출력 1입력81 83 92 24 16 410 109 77 6출력3코드(파이썬)import sysn = int(sys.stdin.readline())lines = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]rights = [0] + [r for _, r in sorted(lines)]dp = [0] * (len(rights))for i in range(1, len(rights)):    dp[i] = max([dp[t] for t in range(i) if rights[t] &lt; rights[i]]) + 1print(n - max(dp))특이사항  LIS 알고리즘을 공부해 적용          dp 배열에 최장 증가 부분 문자열을 저장      dp의 i번째는                  rights 리스트의 i까지 중 rights[i]보다 작은 인덱스 j 탐색(이어붙일 수 있는 문자열)          dp의 j 중 가장 큰 값(이어붙일 수 있는 문자열 중 가장 긴 문자열)에 1을 더해 저장                    참고문헌-"
  },
  
  {
    "title": "백준 11052번 카드 구매하기",
    "url": "/posts/0048_boj_11052/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-28 22:56:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제요즘 민규네 동네에서는 스타트링크에서 만든 PS카드를 모으는 것이 유행이다.PS카드는 PS(Problem Solving)분야에서 유명한 사람들의 아이디와 얼굴이 적혀있는 카드이다. 각각의 카드에는 등급을 나타내는 색이 칠해져 있고, 다음과 같이 8가지가 있다.  전설카드  레드카드  오렌지카드  퍼플카드  블루카드  청록카드  그린카드  그레이카드카드는 카드팩의 형태로만 구매할 수 있고, 카드팩의 종류는 카드 1개가 포함된 카드팩, 카드 2개가 포함된 카드팩, … 카드 N개가 포함된 카드팩과 같이 총 N가지가 존재한다.민규는 카드의 개수가 적은 팩이더라도 가격이 비싸면 높은 등급의 카드가 많이 들어있을 것이라는 미신을 믿고 있다. 따라서, 민규는 돈을 최대한 많이 지불해서 카드 N개 구매하려고 한다. 카드가 i개 포함된 카드팩의 가격은 Pi원이다.예를 들어, 카드팩이 총 4가지 종류가 있고, P1 = 1, P2 = 5, P3 = 6, P4 = 7인 경우에 민규가 카드 4개를 갖기 위해 지불해야 하는 금액의 최댓값은 10원이다. 2개 들어있는 카드팩을 2번 사면 된다.P1 = 5, P2 = 2, P3 = 8, P4 = 10인 경우에는 카드가 1개 들어있는 카드팩을 4번 사면 20원이고, 이 경우가 민규가 지불해야 하는 금액의 최댓값이다.마지막으로, P1 = 3, P2 = 5, P3 = 15, P4 = 16인 경우에는 3개 들어있는 카드팩과 1개 들어있는 카드팩을 구매해 18원을 지불하는 것이 최댓값이다.카드 팩의 가격이 주어졌을 때, N개의 카드를 구매하기 위해 민규가 지불해야 하는 금액의 최댓값을 구하는 프로그램을 작성하시오. N개보다 많은 개수의 카드를 산 다음, 나머지 카드를 버려서 N개를 만드는 것은 불가능하다. 즉, 구매한 카드팩에 포함되어 있는 카드 개수의 합은 N과 같아야 한다.입력첫째 줄에 민규가 구매하려고 하는 카드의 개수 N이 주어진다. (1 ≤ N ≤ 1,000)둘째 줄에는 Pi가 P1부터 PN까지 순서대로 주어진다. (1 ≤ Pi ≤ 10,000)출력첫째 줄에 민규가 카드 N개를 갖기 위해 지불해야 하는 금액의 최댓값을 출력한다.예제 입출력 1입력41 5 6 7출력10예제 입출력 2입력510 9 8 7 6출력50예제 입출력 3입력101 1 2 3 5 8 13 21 34 55출력55예제 입출력 4입력105 10 11 12 13 30 35 40 45 47출력50예제 입출력 5입력45 2 8 10출력20예제 입출력 6입력43 5 15 16출력18코드(파이썬)import sysn = int(sys.stdin.readline())cards = list(map(int, sys.stdin.readline().split()))result = 0for i in range(1, n):    cards[i] = max(cards[i], max([cards[j]+cards[i-j-1] for j in range(i//2+1)]))    print(cards[-1])특이사항  DP로 해결한 문제          cards[i]의 최댓값은 다음 값들 중 하나                  cards[i]          cards[0]+cards[i-1], cards[1]+cards[i-2], …, cards[j]+cards[i-j-1]                      반례가 떠오르지 않아 질문게시판을 이용 -&gt; 최대한 이용하지 않는 방향으로          반례1                              61 5 6 1 1 1&gt;&gt; 15                                          반례2                              121 1 6 8 11 1 1&gt;&gt; 14                                          참고문헌-"
  },
  
  {
    "title": "백준 9663번 N-Queen",
    "url": "/posts/0047_boj_9663/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 브루트포스(bruteforce), 백트래킹(backtracking)",
    "date": "2022-03-24 22:16:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #브루트포스 알고리즘 #백트래킹조건            시간 제한      메모리 제한                  10 초      128 MB      문제N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.N이 주어졌을 때, 퀸을 놓는 방법의...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #브루트포스 알고리즘 #백트래킹조건            시간 제한      메모리 제한                  10 초      128 MB      문제N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)출력첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.예제 입출력 1입력8출력92코드(파이썬)def back_track(row):    global cnt        if row == n:        cnt += 1        return    visited = set(queen)    for i in range(row):        if queen[i] - row + i &gt;= 0:            visited.add(queen[i] - row + i)                    if queen[i] + row - i &lt;= n-1:            visited.add(queen[i] + row - i)        for next_ in range(n):        if next_ not in visited:            queen[row] = next_            back_track(row+1)            queen[row] = -1n = int(input())queen = [-1 for _ in range(n)]cnt = 0for start in range(n):    queen[0] = start    back_track(1)    queen[0] = -1print(cnt)특이사항  퀸의 상태를 queen 리스트에 저장(queen[1] = 3 &lt;-&gt; (2,4) 위치에 퀸)  queen 리스트를 이용해 현재 행에서 갈 수 없는 열을 visited 리스트에 저장  이후에는 DFS 반복참고문헌-"
  },
  
  {
    "title": "백준 16953번 A → B",
    "url": "/posts/0046_boj_16953/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그리디 알고리즘(greedy_algorithm), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-03-23 22:06:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그리디 알고리즘 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.  2를 곱한다.  1을 수의 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그리디 알고리즘 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  2 초      512 MB      문제정수 A를 B로 바꾸려고 한다. 가능한 연산은 다음과 같은 두 가지이다.  2를 곱한다.  1을 수의 가장 오른쪽에 추가한다.A를 B로 바꾸는데 필요한 연산의 최솟값을 구해보자.입력첫째 줄에 A, B (1 ≤ A &lt; B ≤ 109)가 주어진다.출력A를 B로 바꾸는데 필요한 연산의 최솟값에 1을 더한 값을 출력한다. 만들 수 없는 경우에는 -1을 출력한다.예제 입출력 1입력2 162출력52 → 4 → 8 → 81 → 162예제 입출력 2입력4 42출력-1예제 입출력 3입력100 40021출력5100 → 200 → 2001 → 4002 → 40021코드(파이썬)a, b = map(int, input().split())cnt = 1result = -1while ((b%10 == 1) or (b%2 == 0)) and b &gt; 0:    if a == b:        result = cnt        break        b //= 2 if b%2 == 0 else 10        cnt += 1if a == b:    result = cnt    print(result)특이사항  b에서부터 거꾸로 출발하는 경우, 선택지가 1개로 고정되어 보다 단순한 풀이 가능참고문헌-"
  },
  
  {
    "title": "백준 9935번 문자열 폭발",
    "url": "/posts/0045_boj_9935/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 문자열(string), 스택(stack)",
    "date": "2022-03-22 22:01:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #문자열 #스택조건            시간 제한      메모리 제한                  1 초      256 MB      문제상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.폭발은 다음과...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #자료구조 #문자열 #스택조건            시간 제한      메모리 제한                  1 초      256 MB      문제상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.폭발은 다음과 같은 과정으로 진행된다.문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 “FRULA”를 출력한다.폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.입력첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, …, 9로만 이루어져 있다.출력첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.예제 입출력 1입력mirkovC4nizCC44C4출력mirkovniz예제 입출력 2입력12ab112ab2ab12ab출력FRULA코드(파이썬)import sysline = sys.stdin.readline().rstrip()explosion = sys.stdin.readline().rstrip()stack = list()if len(explosion) &gt; 1:    line = list(line)        for index, ch in enumerate(line):        if ch == explosion[0]:            stack.append([1, [index]])        elif stack and ch == explosion[stack[-1][0]]:            if ch == explosion[-1]:                _, blank = stack.pop()                                line[index] = ''                for j in blank:                    line[j] = ''                            else:                stack[-1][0] += 1                stack[-1][1].append(index)        else:            stack = list()                result = ''.join(line)else:    result = line.replace(explosion, '')sys.stdout.write(result if result else \"FRULA\")특이사항  다른 코드에 비해 3~4배 가량 메모리, 시간을 더욱 차지함  내 코드(177,928KB, 1,184ms)에 비해 우수한 코드(바로가기, 42,044KB, 292ms)와 비교                  def main():     string = input()    # 전체 문자열    bomb = input()      # 폭발 문자열        lastChar = bomb[-1] # 폭발 문자열의 마지막 글자    stack = []    length = len(bomb)  # 폭발 문자열의 길이        for char in string:        stack.append(char)        if char == lastChar and ''.join(stack[-length:]) == bomb:            del stack[-length:]        answer = ''.join(stack)        if answer == '':        print(\"FRULA\")    else:        print(answer)        if __name__ == '__main__':    main()                    스택에 저장하는 값                  기존: 다음 확인할 폭발 문자열 인덱스, 폭발 문자열과 일치하는 원래 문자열의 글자 인덱스          개선: 원래 문자열의 모든 문자                    스택 초기화                  기존: 폭발 문자열과 일치하지 않을 때          개선: 지금 글자가 폭발 문자열의 마지막 글자이면서 stack에 저장된 문자열이 폭발 문자열과 일치할 때                    참고문헌-"
  },
  
  {
    "title": "백준 9251번 LCS",
    "url": "/posts/0044_boj_9251/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-21 22:52:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.입력첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.출력첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.예제 입출력 1입력ACAYKPCAPCAK출력4코드(파이썬)import sysline1 = sys.stdin.readline().rstrip()line2 = sys.stdin.readline().rstrip()if len(line1) &gt; len(line2):    line1, line2 = line2, line1dp = [0 for _ in range(len(line2)+1)]for ch1 in line1:    tmp = dp.copy()        for j, ch2 in enumerate(line2, 1):        if ch1 == ch2:            tmp[j] = dp[j-1] + 1        else:            tmp[j] = max(dp[j], tmp[j-1])    dp = tmpprint(dp[-1])특이사항  DP로 해결할 수 있는 문제 중 하나  두 문자열이 같을 떄 값을 갱신하는 방식에서 헤매어 다음 참고문헌을 통해 학습참고문헌  emplam27, “[알고리즘] 그림으로 알아보는 LCS 알고리즘 - Longest Common Substring와 Longest Common Subsequence”, emplam27.log, https://velog.io/@emplam27/알고리즘-그림으로-알아보는-LCS-알고리즘-Longest-Common-Substring와-Longest-Common-Subsequence"
  },
  
  {
    "title": "백준 9465번 Stickers",
    "url": "/posts/0043_boj_9465/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-18 20:38:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제상근이의 여동생 상냥이는 문방구에서 스티커 2n개를 구매했다. 스티커는 그림 (a)와 같이 2행 n열로 배치되어 있다. 상냥이는 스티커를 이용해 책상을 꾸미려고 한다.상냥이가 구매한 스티커의 품질은 매우 좋지 않다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커는 모두 찢어져서 사용할 수 없게 된다. 즉, 뗀 스티커의 왼쪽, 오른쪽, 위, 아래에 있는 스티커는 사용할 수 없게 된다.모든 스티커를 붙일 수 없게된 상냥이는 각 스티커에 점수를 매기고, 점수의 합이 최대가 되게 스티커를 떼어내려고 한다. 먼저, 그림 (b)와 같이 각 스티커에 점수를 매겼다. 상냥이가 뗄 수 있는 스티커의 점수의 최댓값을 구하는 프로그램을 작성하시오. 즉, 2n개의 스티커 중에서 점수의 합이 최대가 되면서 서로 변을 공유 하지 않는 스티커 집합을 구해야 한다.위의 그림의 경우에 점수가 50, 50, 100, 60인 스티커를 고르면, 점수는 260이 되고 이 것이 최대 점수이다. 가장 높은 점수를 가지는 두 스티커 (100과 70)은 변을 공유하기 때문에, 동시에 뗄 수 없다.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스의 첫째 줄에는 n (1 ≤ n ≤ 100,000)이 주어진다. 다음 두 줄에는 n개의 정수가 주어지며, 각 정수는 그 위치에 해당하는 스티커의 점수이다. 연속하는 두 정수 사이에는 빈 칸이 하나 있다. 점수는 0보다 크거나 같고, 100보다 작거나 같은 정수이다.출력각 테스트 케이스 마다, 2n개의 스티커 중에서 두 변을 공유하지 않는 스티커 점수의 최댓값을 출력한다.예제 입출력 1입력2550 10 100 20 4030 50 70 10 60710 30 10 50 100 20 4020 40 30 50 60 20 80출력260290코드(파이썬)import systc = int(sys.stdin.readline())for _ in range(tc):    result = 0    n = int(sys.stdin.readline())    stickers = [list(map(int, sys.stdin.readline().split())) for _ in range(2)]        if n == 1:        result = max(stickers[0][0], stickers[1][0])    elif n == 2:        result = max(stickers[0][0]+stickers[1][1], stickers[1][0]+stickers[0][1])    else:        stickers[0][1] += stickers[1][0]        stickers[1][1] += stickers[0][0]        for i in range(2, n):            stickers[0][i] += max(stickers[1][i-2], stickers[1][i-1])            stickers[1][i] += max(stickers[0][i-2], stickers[0][i-1])                result = max(stickers[0][-1], stickers[1][-1])        print(result)특이사항  2개의 리스트를 이용한 간단한 DP 문제  내 코드(47,104KB, 924ms)에 비해 우수한 코드(바로가기, 39,880KB, 872ms)와 비교                  import sysN = int(input())for _ in range(N):    s = []    M = int(input())    for _ in range(2):        s.append(list(map(int, sys.stdin.readline().split())))    if M == 1:        print(*max(s))        continue    s[0][1] += s[1][0]    s[1][1] += s[0][0]    for i in range(2, M):        s[1][i] += max(s[0][i - 2], s[0][i - 1])        s[0][i] += max(s[1][i - 2], s[1][i - 1])    print(max(s[0][-1], s[1][-1]))                    전체적인 구조가 동일한 것으로 보았을 때, if~elif~else 문이 영향을 미쳤을 가능성이 있으나 명확하게 판단 불가      참고문헌-"
  },
  
  {
    "title": "백준 1339번 단어 수학",
    "url": "/posts/0042_boj_1339/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 그리디 알고리즘(greedy_algorithm), 브루트포스(bruteforce)",
    "date": "2022-03-17 22:22:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그리디 알고리즘 #브루트포스조건            시간 제한      메모리 제한                  2 초      256 MB      문제민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그리디 알고리즘 #브루트포스조건            시간 제한      메모리 제한                  2 초      256 MB      문제민식이는 수학학원에서 단어 수학 문제를 푸는 숙제를 받았다.단어 수학 문제는 N개의 단어로 이루어져 있으며, 각 단어는 알파벳 대문자로만 이루어져 있다. 이때, 각 알파벳 대문자를 0부터 9까지의 숫자 중 하나로 바꿔서 N개의 수를 합하는 문제이다. 같은 알파벳은 같은 숫자로 바꿔야 하며, 두 개 이상의 알파벳이 같은 숫자로 바뀌어지면 안 된다.예를 들어, GCF + ACDEB를 계산한다고 할 때, A = 9, B = 4, C = 8, D = 6, E = 5, F = 3, G = 7로 결정한다면, 두 수의 합은 99437이 되어서 최대가 될 것이다.N개의 단어가 주어졌을 때, 그 수의 합을 최대로 만드는 프로그램을 작성하시오.입력첫째 줄에 단어의 개수 N(1 ≤ N ≤ 10)이 주어진다. 둘째 줄부터 N개의 줄에 단어가 한 줄에 하나씩 주어진다. 단어는 알파벳 대문자로만 이루어져있다. 모든 단어에 포함되어 있는 알파벳은 최대 10개이고, 수의 최대 길이는 8이다. 서로 다른 문자는 서로 다른 숫자를 나타낸다.출력첫째 줄에 주어진 단어의 합의 최댓값을 출력한다.예제 입출력 1입력2AAAAAA출력1998예제 입출력 2입력2GCFACDEB출력99437예제 입출력 3입력10ABCDEFGHIJ출력45예제 입출력 4입력2ABBA출력187코드(파이썬)change = dict()num = 9n = int(input())lines = [list(input().rstrip()) for _ in range(n)]tmp_sum = {k:0 for k in sum(lines, [])}for line in lines:    for i in range(len(line)):        tmp_sum[line[i]] += 10**(len(line)-i-1)for ch, _ in sorted(tmp_sum.items(), key=lambda x: -x[1]):    change[ch] = str(num)    num -= 1print(sum([int(''.join([change[ch] for ch in line])) for line in lines]))특이사항  풀이과정          lines 리스트에 각 단어를 저장함      tmp_sum 딕셔너리에 각 단어를 키로 초기화      단어의 각 문자를 자릿수만큼 곱해서 tmp_sum 딕셔너리에 저장      tmp_sum 딕셔너리를 value(문자의 우선순위)별로 정렬한 다음 change 딕셔너리에 9, 8, 7, … 순서대로 저장      lines 리스트의 각 단어를 change 딕셔너리를 이용해 숫자로 변환하고 이를 더함      참고문헌-"
  },
  
  {
    "title": "백준 11000번 강의실 배정",
    "url": "/posts/0041_boj_11000/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 다이나믹 프로그래밍(dynamic_programming), 정렬(sorting), 우선순위큐(priority_queue)",
    "date": "2022-03-16 22:24:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #자료구조 #다이나믹 프로그래밍 #정렬 #우선순위큐조건            시간 제한      메모리 제한                  1 초      256 MB      문제수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #자료구조 #다이나믹 프로그래밍 #정렬 #우선순위큐조건            시간 제한      메모리 제한                  1 초      256 MB      문제수강신청의 마스터 김종혜 선생님에게 새로운 과제가 주어졌다.김종혜 선생님한테는 Si에 시작해서 Ti에 끝나는 N개의 수업이 주어지는데, 최소의 강의실을 사용해서 모든 수업을 가능하게 해야 한다.참고로, 수업이 끝난 직후에 다음 수업을 시작할 수 있다. (즉, Ti ≤ Sj 일 경우 i 수업과 j 수업은 같이 들을 수 있다.)수강신청 대충한 게 찔리면, 선생님을 도와드리자!입력첫 번째 줄에 N이 주어진다. (1 ≤ N ≤ 200,000)이후 N개의 줄에 Si, Ti가 주어진다. (0 ≤ Si &lt; Ti ≤ 109)출력강의실의 개수를 출력하라.예제 입출력 1입력31 32 43 5출력2코드(파이썬)import sysimport heapqn = int(sys.stdin.readline())lectures = sorted([tuple(map(int, sys.stdin.readline().split())) for _ in range(n)])dp = [lectures[0][1]]for s, t in lectures[1:]:    if s &gt;= dp[0]:        heapq.heappop(dp)        heapq.heappush(dp, t)    else:        heapq.heappush(dp, t)print(len(dp))특이사항  풀이과정          강의를 시작시각 순서로 정렬      dp 힙에 첫 강의의 종료시각 저장      현재강의 시작시각 s와 dp 힙의 가장 작은 종료시각 비교                  s가 더 크다면 종료 이후 시작 가능하므로 dp 힙에서 가장 작은 종료시각 제거 후 현재강의 종료시각을 dp 힙에 저장          s가 더 작다면 dp 힙에 추가                      강의를 (가) 시작시각 순서로 오름차순 정렬 vs (나) 종료시각 순서로 오름차순 정렬          예제 데이터        41 21 42 64 5                          (가)                  정렬 직후 강의 리스트: [(1,2) (1,4) (2,6) (4,5)]          진행 중 dp 힙 변화: [2] -&gt; [2, 4] -&gt; [4, 6] -&gt; [5, 6]                    (나)                  정렬 직후 강의 리스트: [(1,2) (1,4) (4,5) (2,6)]          진행 중 dp 힙 변화: [2] -&gt; [2, 4] -&gt; [4, 5] -&gt; [4, 5, 6]                    종료시각 순서로 정렬하는 경우 (나)와 같은 상황이 발생함      참고문헌-"
  },
  
  {
    "title": "백준 2527번 직사각형",
    "url": "/posts/0040_boj_2527/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 기하학(geometry), 많은 조건 분기(many_conditional_branches)",
    "date": "2022-03-15 22:45:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #기하학 #많은 조건 분기조건            시간 제한      메모리 제한                  1 초      128 MB      문제2차원 격자공간에 두 개의 꼭짓점 좌표로 표현되는 직사각형이 있다. 직사각형은 아래와 같이 왼쪽 아래 꼭짓점 좌표 (x, y)와 오른...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #기하학 #많은 조건 분기조건            시간 제한      메모리 제한                  1 초      128 MB      문제2차원 격자공간에 두 개의 꼭짓점 좌표로 표현되는 직사각형이 있다. 직사각형은 아래와 같이 왼쪽 아래 꼭짓점 좌표 (x, y)와 오른쪽 위 꼭짓점 좌표 (p, q)로 주어진다.이 문제에서 모든 직사각형은 두 꼭짓점의 좌표를 나타내는 4개의 정수 x y p q 로 표현된다. 단 항상 x&lt;p, y&lt;q 이다. 예를 들어 위 그림에 제시된 직사각형이라면 아래와 같이 표현된다.3 2 9 8두 개의 직사각형은 그 겹치는 부분의 특성에 따라 다음 4가지 경우로 분류될 수 있다.먼저 두 직사각형의 겹치는 부분이 직사각형인 경우이다. 아래 그림(a)는 공통부분이 직사각형인 경우의 3가지 예를 보여준다,그림 (a)또는 겹치는 부분이 아래 그림 (b)와 같이 선분이 될 수도 있고, 그림 (c)와 같이 점도 될 수 있다.그림 (b)그림 (c)마지막으로 아래 그림 (d)와 같이 공통부분 없이 두 직사각형이 완전히 분리된 경우도 있다.그림 (d)여러분은 두 직사각형의 겹치는 부분이 직사각형인지, 선분인지, 점인지, 아니면 전혀 없는 지를 판별해서 해당되는 코드 문자를 출력해야 한다.            공통부분의 특성      코드 문자                  직사각형      a              선분      b              점      c              공통부분이 없음      d      입력4개의 줄로 이루어져 있다. 각 줄에는 8개의 정수가 하나의 공백을 두고 나타나는데, 첫 4개의 정수는 첫 번째 직사각형을, 나머지 4개의 정수는 두 번째 직사각형을 각각 나타낸다. 단 입력 직사각형의 좌표 값은 1이상 50,000 이하의 정수로 제한된다.출력4개의 각 줄에 주어진 두 직사각형의 공통부분을 조사해서 해당하는 코드 문자를 출력파일의 첫 4개의 줄에 각각 차례대로 출력해야 한다.예제 입출력 1입력3 10 50 60 100 100 200 30045 50 600 600 400 450 500 54311 120 120 230 50 40 60 44035 56 67 90 67 80 500 600출력daab코드(파이썬)for _ in range(4):    line = list(map(int, input().split()))    rects = list()    for i in range(2):        x1, y1, x2, y2 = line[i*4:(i+1)*4]        rects.append([(x1, y1), (x1, y2), (x2, y2), (x2, y1)])            # 아예 벗어난 경우    if (rects[0][0][0] &gt; rects[1][2][0]) or (rects[0][2][0] &lt; rects[1][0][0]) or\\       (rects[0][0][1] &gt; rects[1][2][1]) or (rects[0][2][1] &lt; rects[1][0][1]):        result = 'd'    # 점으로 만나는 경우    elif (rects[0][0] == rects[1][2]) or (rects[0][1] == rects[1][3]) or\\         (rects[0][2] == rects[1][0]) or (rects[0][3] == rects[1][1]):        result = 'c'    # 선분으로 만나는 경우    elif (rects[0][2][0] == rects[1][0][0] or rects[0][0][0] == rects[1][2][0]) and (rects[0][2][1] &gt; rects[1][0][1] or rects[0][0][1] &lt; rects[1][2][1]) or\\         (rects[0][2][1] == rects[1][0][1] or rects[0][0][1] == rects[1][2][1]) and (rects[0][2][0] &gt; rects[1][0][0] or rects[0][0][0] &lt; rects[1][2][0]):        result = 'b'    else:        result = 'a'        print(result)특이사항  좌표를 rects의 3차원 리스트로 저장해서 코드만 늘어나는 결과를 보임  내 코드(30,860KB, 68ms)에 비해 우수한 코드(바로가기, 30,864KB, 68ms)와 비교                  for tc in range(4):  x1, y1, p1, q1, x2, y2, p2, q2 = map(int, input().split())  sl = max(x1, x2)  sr = min(p1, p2)  sb = max(y1, y2)  st = min(q1, q2)  if sl == sr and sb == st:      print('c')  elif (sl == sr and sb &lt; st) or (sb == st and sl &lt; sr):      print('b')  elif sl &lt; sr and sb &lt; st:      print('a')  else:      print('d')                    결과적으로 같은 기능을 수행하지만 훨씬 간결한 모습을 확인할 수 있음      참고문헌-"
  },
  
  {
    "title": "백준 11444번 피보나치 수 6",
    "url": "/posts/0039_boj_11444/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 분할 정복을 이용한 거듭제곱(power_using_divide_and_conquer)",
    "date": "2022-03-14 21:56:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold2관련 개념: #수학 #분할 정복을 이용한 거듭제곱조건            시간 제한      메모리 제한                  1 초      256 MB      문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold2관련 개념: #수학 #분할 정복을 이용한 거듭제곱조건            시간 제한      메모리 제한                  1 초      256 MB      문제피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.n=17일때 까지 피보나치 수를 써보면 다음과 같다.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 n이 주어진다. n은 1,000,000,000,000,000,000보다 작거나 같은 자연수이다.출력첫째 줄에 n번째 피보나치 수를 1,000,000,007으로 나눈 나머지를 출력한다.예제 입출력 1입력1000출력517691607코드(파이썬)def dq(num):    if num not in fibo:        if num % 2:            fibo[num] = ((dq(num//2+1) ** 2) % 1000000007 + (dq(num//2) ** 2) % 1000000007) % 1000000007        else:            fibo[num] = ((dq(num//2+1)) * dq(num//2) % 1000000007 + (fibo[num//2] * dq(num//2 - 1)) % 1000000007) % 1000000007    return fibo[num]n = int(input())fibo = {0:0, 1:1, 2:1}print(dq(n))특이사항  분할을 통해 해결          규칙을 파악하기 위해 몇 가지 피보나치 수열 계산                  num이 2로 나눠질 때 » fibo(n) = fibo(n/2 + 1) * fibo(n/2 + 1) + fibo(n/2) * fibo(n/2)          num이 2로 나눠지지 않을 때 » fibo(n) = fibo(n/2 + 1) * fibo(n/2) + fibo(n/2) * fibo(n/2 - 1)                    점화식을 구했으므로 그대로 함수 작성      참고문헌-"
  },
  
  {
    "title": "백준 11660번 구간 합 구하기 5",
    "url": "/posts/0038_boj_11660/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 누적합(prefix_sum)",
    "date": "2022-03-11 19:08:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍 #누적합조건            시간 제한      메모리 제한                  1 초      256 MB      문제N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍 #누적합조건            시간 제한      메모리 제한                  1 초      256 MB      문제N×N개의 수가 N×N 크기의 표에 채워져 있다. (x1, y1)부터 (x2, y2)까지 합을 구하는 프로그램을 작성하시오. (x, y)는 x행 y열을 의미한다.예를 들어, N = 4이고, 표가 아래와 같이 채워져 있는 경우를 살펴보자.1\t2\t3\t42\t3\t4\t53\t4\t5\t64\t5\t6\t7여기서 (2, 2)부터 (3, 4)까지 합을 구하면 3+4+5+4+5+6 = 27이고, (4, 4)부터 (4, 4)까지 합을 구하면 7이다.표에 채워져 있는 수와 합을 구하는 연산이 주어졌을 때, 이를 처리하는 프로그램을 작성하시오.입력첫째 줄에 표의 크기 N과 합을 구해야 하는 횟수 M이 주어진다. (1 ≤ N ≤ 1024, 1 ≤ M ≤ 100,000) 둘째 줄부터 N개의 줄에는 표에 채워져 있는 수가 1행부터 차례대로 주어진다. 다음 M개의 줄에는 네 개의 정수 x1, y1, x2, y2 가 주어지며, (x1, y1)부터 (x2, y2)의 합을 구해 출력해야 한다. 표에 채워져 있는 수는 1,000보다 작거나 같은 자연수이다. (x1 ≤ x2, y1 ≤ y2)출력총 M줄에 걸쳐 (x1, y1)부터 (x2, y2)까지 합을 구해 출력한다.예제 입출력 1입력4 31 2 3 42 3 4 53 4 5 64 5 6 72 2 3 43 4 3 41 1 4 4출력27664예제 입출력 2입력2 41 23 41 1 1 11 2 1 22 1 2 12 2 2 2출력1234코드(파이썬)import sysn, m = map(int, sys.stdin.readline().split())table = [list(map(int, sys.stdin.readline().split())) for _ in range(n)]# 가로 누적합for line in range(n):    for y in range(n-1):        table[line][y+1] += table[line][y]# 가로 누적합을 더해 전체 누적합for line in range(1, n):    table[line][0] += table[line-1][0]    for y in range(1, n):        table[line][y] += table[line-1][y]        for _ in range(m):    x1, y1, x2, y2 = map(lambda x: int(x)-1, sys.stdin.readline().split())        dup = table[x1-1][y1-1] if x1 != 0 and y1 != 0 else 0    up = table[x1-1][y2] if x1 != 0 else 0    left = table[x2][y1-1] if y1 != 0 else 0    r = table[x2][y2] - up - left + dup            print(r)특이사항  구간 합에 대한 문제          행별로 누적합 계산      행별로 계산한 누적합을 더해 (1,1)에서 해당 좌표까지의 누적합 계산            (3,3)~(5,5)합 = (5,5)누적합 - (2,5)누적합 - (5,2)누적합 + (2,2)누적합        내 코드(71,520KB, 1,272ms)에 비해 우수한 코드(바로가기, 70,888KB, 868ms)와 비교                  import sysfrom itertools import accumulateif __name__ == '__main__':    n, m = map(int, sys.stdin.readline().split())    arr = [[0] * (n+1)]    for _ in range(n):        arr.append([0] + list(accumulate(map(int, sys.stdin.readline().split()))))    for i in range(1, n+1):        for j in range(1, len(arr[0])):            arr[i][j] += arr[i-1][j]    for _ in range(m):        x1, y1, x2, y2 = map(int, sys.stdin.readline().split())        ans = arr[x2][y2] - arr[x2][y1-1] - arr[x1-1][y2] + arr[x1-1][y1-1]        print(ans)                          itertools의 accumulate 함수 사용          로직 동일                    참고문헌-"
  },
  
  {
    "title": "백준 1753번 최단경로",
    "url": "/posts/0037_boj_1753/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 다익스트라(dijkstra)",
    "date": "2022-03-10 22:03:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 #다익스트라조건            시간 제한      메모리 제한                  1 초      256 MB      문제방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 #다익스트라조건            시간 제한      메모리 제한                  1 초      256 MB      문제방향그래프가 주어지면 주어진 시작점에서 다른 모든 정점으로의 최단 경로를 구하는 프로그램을 작성하시오. 단, 모든 간선의 가중치는 10 이하의 자연수이다.입력첫째 줄에 정점의 개수 V와 간선의 개수 E가 주어진다. (1 ≤ V ≤ 20,000, 1 ≤ E ≤ 300,000) 모든 정점에는 1부터 V까지 번호가 매겨져 있다고 가정한다. 둘째 줄에는 시작 정점의 번호 K(1 ≤ K ≤ V)가 주어진다. 셋째 줄부터 E개의 줄에 걸쳐 각 간선을 나타내는 세 개의 정수 (u, v, w)가 순서대로 주어진다. 이는 u에서 v로 가는 가중치 w인 간선이 존재한다는 뜻이다. u와 v는 서로 다르며 w는 10 이하의 자연수이다. 서로 다른 두 정점 사이에 여러 개의 간선이 존재할 수도 있음에 유의한다.출력첫째 줄부터 V개의 줄에 걸쳐, i번째 줄에 i번 정점으로의 최단 경로의 경로값을 출력한다. 시작점 자신은 0으로 출력하고, 경로가 존재하지 않는 경우에는 INF를 출력하면 된다.예제 입출력 1입력5 615 1 11 2 21 3 32 3 42 4 53 4 6출력0237INF코드(파이썬)import sysimport heapqv, e = map(int, sys.stdin.readline().split())start = int(sys.stdin.readline())inf = 3000001visited = set()graph = dict()d = [[inf, node] for node in range(1, v+1)]d[start-1][0] = 0queue = [d[start-1]]for _ in range(e):    n1, n2, w = map(int, sys.stdin.readline().split())    if n1 in graph:        if n2 in graph[n1]:            graph[n1][n2] = min(w, graph[n1][n2])        else:            graph[n1][n2] = w    else:        graph[n1] = {n2: w}        while queue:    mid_weight, mid = heapq.heappop(queue)    visited.add(mid)    if mid in graph:        for end, weight in graph[mid].items():            if end not in visited and d[end-1][0] &gt; mid_weight + weight:                d[end-1][0] = mid_weight + weight                heapq.heappush(queue, (mid_weight + weight, end))d.sort(key=lambda x: x[1])sys.stdout.write('\\n'.join(['INF' if w == inf else str(w) for w, _ in d]))특이사항  이론만 배운 다익스트라 알고리즘의 첫 번째 실전 문제          방문 정점 저장      시작정점으로부터 최단거리를 저장할 리스트 d 생성      리스트 d의 시작정점은 0, 나머지 정점은 적절한 INF으로 초기화      다음 방문지를 (거리, 노드) 순으로 저장할 힙 queue 선언      queue에서 pop해 mid_weight와 mid에 저장      mid 노드에서 갈 수 있는 노드가 존재한다면 -&gt; 그 노드 중 weight값을 업데이트할 노드가 있다면 -&gt; 리스트 d 업데이트, queue에 저장      참고문헌  문병로, 쉽게 배우는 알고리즘 :관계 중심의 사고법, 문병로, 2018"
  },
  
  {
    "title": "백준 1932번 정수 삼각형",
    "url": "/posts/0036_boj_1932/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-03-09 21:19:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  2 초      128 MB      문제        7      3   8    8   1   0  2   7   4   44   5   2   6   5위 그림은 크기가 5인 정수 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  2 초      128 MB      문제        7      3   8    8   1   0  2   7   4   44   5   2   6   5위 그림은 크기가 5인 정수 삼각형의 한 모습이다.맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.입력첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.출력첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.예제 입출력 1입력573 88 1 02 7 4 44 5 2 6 5출력30코드(파이썬)import sysn = int(sys.stdin.readline())dp = [int(sys.stdin.readline())] + [0 for _ in range(n-1)]for i in range(2, n+1):    nums = list(map(int, sys.stdin.readline().split()))    tmp = dp.copy()        tmp[0] += nums[0]    for j in range(1, i-1):        tmp[j] = max(dp[j-1:j+1]) + nums[j]    tmp[i-1] = dp[i-2] + nums[i-1]    dp = tmp    print(max(dp))특이사항  간단한 DP 문제참고문헌-"
  },
  
  {
    "title": "백준 1991번 트리 순회",
    "url": "/posts/0035_boj_1991/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 트리(tree), 순회(order)",
    "date": "2022-03-08 22:22:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #트리 #순회조건            시간 제한      메모리 제한                  2 초      128 MB      문제이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder trav...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #트리 #순회조건            시간 제한      메모리 제한                  2 초      128 MB      문제이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.예를 들어 위와 같은 이진 트리가 입력되면,  전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)  중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)  후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)입력첫째 줄에는 이진 트리의 노드의 개수 N(1 ≤ N ≤ 26)이 주어진다. 둘째 줄부터 N개의 줄에 걸쳐 각 노드와 그의 왼쪽 자식 노드, 오른쪽 자식 노드가 주어진다. 노드의 이름은 A부터 차례대로 알파벳 대문자로 매겨지며, 항상 A가 루트 노드가 된다. 자식 노드가 없는 경우에는 .으로 표현한다.출력첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.예제 입출력 1입력7A B CB D .C E FE . .F . GD . .G . .출력ABDCEFGDBAECFGDBEGFCA코드(파이썬)def preorder(parent):    if all(ch == '.' for ch in tree[parent]):        return parent    else:        result = ''        l, r = tree[parent]                result += parent        if l != '.':            result += preorder(l)        if r != '.':            result += preorder(r)                    return result    def inorder(parent):    if all(ch == '.' for ch in tree[parent]):        return parent    else:        result = ''        l, r = tree[parent]                if l != '.':            result += inorder(l)        result += parent        if r != '.':            result += inorder(r)                    return result    def postorder(parent):    if all(ch == '.' for ch in tree[parent]):        return parent    else:        result = ''        l, r = tree[parent]                if l != '.':            result += postorder(l)        if r != '.':            result += postorder(r)        result += parent                    return result        n = int(input())tree = dict()for p, l, r in [input().split() for _ in range(n)]:    tree[p] = (l, r)    print(preorder('A'))print(inorder('A'))print(postorder('A'))특이사항  간단한 트리 순회 문제참고문헌-"
  },
  
  {
    "title": "백준 1629번 곱셈",
    "url": "/posts/0034_boj_1629/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 분할 정복을 이용한 거듭제곱(power_using_divide_and_conquer)",
    "date": "2022-03-07 23:13:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #분할 정복을 이용한 거듭제곱조건            시간 제한      메모리 제한                  0.5 초 (추가 시간 없음)      128 MB      문제자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #분할 정복을 이용한 거듭제곱조건            시간 제한      메모리 제한                  0.5 초 (추가 시간 없음)      128 MB      문제자연수 A를 B번 곱한 수를 알고 싶다. 단 구하려는 수가 매우 커질 수 있으므로 이를 C로 나눈 나머지를 구하는 프로그램을 작성하시오.입력첫째 줄에 A, B, C가 빈 칸을 사이에 두고 순서대로 주어진다. A, B, C는 모두 2,147,483,647 이하의 자연수이다.출력첫째 줄에 A를 B번 곱한 수를 C로 나눈 나머지를 출력한다.예제 입출력 1입력10 11 12출력4코드(파이썬)def dfs(quotient):    if quotient in memo:        return memo[quotient]    else:        if quotient%2 == 0:            r = (dfs(quotient//2)**2) % c        else:            r = (dfs(quotient//2)*dfs(quotient//2 + 1)) % c                memo[quotient] = r                return ra, b, c = map(int, input().split())memo = {1:a%c}print(dfs(b))특이사항  분할 정복을 이용해 문제의 b 값을 2로 나눠가면서 풀이참고문헌-"
  },
  
  {
    "title": "백준 11729번 최대 힙",
    "url": "/posts/0033_boj_11279/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 우선순위큐(priority_queue)",
    "date": "2022-03-04 23:06:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #자료구조 #우선순위큐조건            시간 제한      메모리 제한                  1 초 (추가 시간 없음)      256 MB      문제널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.  배열...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #자료구조 #우선순위큐조건            시간 제한      메모리 제한                  1 초 (추가 시간 없음)      256 MB      문제널리 잘 알려진 자료구조 중 최대 힙이 있다. 최대 힙을 이용하여 다음과 같은 연산을 지원하는 프로그램을 작성하시오.  배열에 자연수 x를 넣는다.  배열에서 가장 큰 값을 출력하고, 그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.입력첫째 줄에 연산의 개수 N(1 ≤ N ≤ 100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 자연수라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 가장 큰 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 자연수는 231보다 작다.출력입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 가장 큰 값을 출력하라고 한 경우에는 0을 출력하면 된다.예제 입출력 1입력130120032100000출력02132100특이사항  heapq 모듈을 사용한 최대힙  solved.ac 기준 class3 모두 풀이참고문헌-"
  },
  
  {
    "title": "백준 17626번 Four Squares",
    "url": "/posts/0032_boj_17626/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 브루트포스(bruteforce)",
    "date": "2022-03-03 21:49:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver4관련 개념: #다이나믹 프로그래밍, #브루트포스조건            시간 제한      메모리 제한                  0.5 초 (추가 시간 없음)      512 MB      문제라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 어떤...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver4관련 개념: #다이나믹 프로그래밍, #브루트포스조건            시간 제한      메모리 제한                  0.5 초 (추가 시간 없음)      512 MB      문제라그랑주는 1770년에 모든 자연수는 넷 혹은 그 이하의 제곱수의 합으로 표현할 수 있다고 증명하였다. 어떤 자연수는 복수의 방법으로 표현된다. 예를 들면, 26은 52과 12의 합이다; 또한 42 + 32 + 12으로 표현할 수도 있다. 역사적으로 암산의 명수들에게 공통적으로 주어지는 문제가 바로 자연수를 넷 혹은 그 이하의 제곱수 합으로 나타내라는 것이었다. 1900년대 초반에 한 암산가가 15663 = 1252 + 62 + 12 + 12라는 해를 구하는데 8초가 걸렸다는 보고가 있다. 좀 더 어려운 문제에 대해서는 56초가 걸렸다: 11339 = 1052 + 152 + 82 + 52.자연수 n이 주어질 때, n을 최소 개수의 제곱수 합으로 표현하는 컴퓨터 프로그램을 작성하시오.입력입력은 표준입력을 사용한다. 입력은 자연수 n을 포함하는 한 줄로 구성된다. 여기서, 1 ≤ n ≤ 50,000 이다.출력출력은 표준출력을 사용한다. 합이 n과 같게 되는 제곱수들의 최소 개수를 한 줄에 출력한다.예제 입출력 1입력25출력1예제 입출력 2입력26출력2예제 입출력 3입력11339출력3예제 입출력 4입력34567출력4코드(파이썬)n = int(input())pows = [i**2 for i in range(int(n**0.5), 0, -1)]r = 4if n in pows:    r = 1else:    pows2 = {i+j for i in pows for j in pows if i+j &lt;= n}        if n in pows2:        r = 2    elif n in {i+j for i in pows for j in pows2 if i+j &lt;= n}:        r = 3print(r)특이사항  브루트포스라고 생각해서 풀이했으나, 다이나믹 프로그래밍으로도 해결할 수 있는 문제  내 코드(34,452KB, 400ms)에 비해 우수한 코드(바로가기, 30,864KB, 92ms)와 비교                  N = int(input())def get_cnt(N):    root = int(N ** 0.5)    if root == N ** 0.5:        return 1            for i in range(1, int(root)+1):        remain = (N - (i**2)) ** 0.5        if remain == int(remain):            return 2    for i in range(1, int(root)+1):        temp = (N - (i**2)) ** 0.5        for j in range(1, int(temp)+1):            temp2 = (N - (i**2) - (j**2)) ** 0.5            if temp2 == int(temp2):                return 3    return 4print(get_cnt(N))                    풀이 과정                  기존: 제곱수를 저장하고 이를 3번 중복해 더해서 비교          개선: 기존 숫자에서 제곱수를 빼서 비교                    참고문헌-"
  },
  
  {
    "title": "백준 5525번 IOIOI (IOIOI)",
    "url": "/posts/0031_boj_5525/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 문자열(string)",
    "date": "2022-03-02 21:10:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #문자열조건            시간 제한      메모리 제한                  1 초      256 MB      문제N+1개의 I와 N개의 O로 이루어져 있으면, I와 O이 교대로 나오는 문자열을 PN이라고 한다.  P1 IOI  P2 IOIOI  P3 IOIOIOI  PN...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #문자열조건            시간 제한      메모리 제한                  1 초      256 MB      문제N+1개의 I와 N개의 O로 이루어져 있으면, I와 O이 교대로 나오는 문자열을 PN이라고 한다.  P1 IOI  P2 IOIOI  P3 IOIOIOI  PN IOIOI…OI (O가 N개)I와 O로만 이루어진 문자열 S와 정수 N이 주어졌을 때, S안에 PN이 몇 군데 포함되어 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. 둘째 줄에는 S의 길이 M이 주어지며, 셋째 줄에 S가 주어진다.출력S에 PN이 몇 군데 포함되어 있는지 출력한다.제한  1 ≤ N ≤ 1,000,000  2N+1 ≤ M ≤ 1,000,000  S는 I와 O로만 이루어져 있다.채점 및 기타 정보  예제는 채점하지 않는다.예제 입출력 1입력113OOIOIOIOIIOII출력4해설  OOIOIOIOIIOII  OOIOIOIOIIOII  OOIOIOIOIIOII  OOIOIOIOIIOII예제 입출력 2입력213OOIOIOIOIIOII출력2해설  OOIOIOIOIIOII  OOIOIOIOIIOII코드(파이썬)import sysdef getPI(base):    pi = [0 for _ in range(len(base))]    j = 0    for i in range(1, len(pi)):        if base[i] == base[j]:            j += 1            pi[i] = j        else:            while base[i] != base[j] and j &gt; 0:                j = pi[j-1]    return pidef kmp(base, target):    pi = getPI(target)    j = 0    result = 0        for i in range(len(base)):        if base[i] == target[j]:            if j == n * 2:                result += 1                j = pi[j]            else:                j += 1        else:            while base[i] != target[j] and j &gt; 0:                j = pi[j-1]                        if base[i] == target[j]:                j += 1    return result        n = int(sys.stdin.readline())m = int(sys.stdin.readline())base = sys.stdin.readline().rstrip('\\n')target = (\"IO\" * n) + \"I\"print(kmp(base, target))특이사항  KMP 알고리즘 설명 및 그림을 보고 직접 구현했지만 그만큼 효율성 떨어지는 결과를 보임          찾고 싶은 문자열의 접두사-접미사 리스트 생성      원래 문자열에서 순서대로 글자 1개와 찾고 싶은 문자열을 비교                  찾고 싶은 문자열과 일치한다면 결과에 1을 더함          찾고 싶은 문자열과 다르다면 접두사-접미사 리스트를 이용해 찾고 싶은 문자열의 가장 가까운 글자까지 이동                      내 코드(57,796KB, 368ms)에 비해 우수한 코드(바로가기, 32,816KB, 84ms)와 비교                  import sysdef main():    k = int(sys.stdin.readline())-1    _ = int(sys.stdin.readline())    strings = [len(i)-1 for i in sys.stdin.readline().strip().replace(\"IO\", \"X\").replace(\"XI\",\"XXO\").replace(\"I\",\"O\").split(\"O\") if i != \"\"]    ans = 0    for i in strings:        ans += i-k if i &gt; k else 0    print(ans)if __name__ == \"__main__\":    main()                    탐색 과정                  기존: KMP 알고리즘 사용          개선: 입력 문자열 → ‘IO’를 ‘X’로 변환 → ‘XI’를 ‘XXO’로 변환 → ‘I’를 ‘O’로 변환 → ‘O’를 기준으로 나눠 리스트 생성 = i→ i의 길이에 1을 뺸 값을 strings 리스트에 저장(IOI가 겹쳐진 갯수 = X의 개수(i의 길이)-1) → k보다 큰 i에 한해 i-k를 결과에 저장                    참고문헌  멍멍멍, “KMP : 문자열 검색 알고리즘”, bowbowbow, https://bowbowbow.tistory.com/6  injae Kim, “KMP 문자열 탐색 알고리즘이 동작하는 구체적인 원리”, Injae’s devlog, https://injae-kim.github.io/dev/2020/07/23/all-about-kmp-algorithm.html"
  },
  
  {
    "title": "백준 11725번 트리의 부모 찾기",
    "url": "/posts/0030_boj_11725/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search), 너비우선탐색(breadth_first_search), 트리(tree)",
    "date": "2022-03-01 21:50:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #너비 우선 탐색 #트리조건            시간 제한      메모리 제한                  1 초      256 MB      문제루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그래프이론 #그래프탐색 #깊이 우선 탐색 #너비 우선 탐색 #트리조건            시간 제한      메모리 제한                  1 초      256 MB      문제루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.입력첫째 줄에 노드의 개수 N (2 ≤ N ≤ 100,000)이 주어진다. 둘째 줄부터 N-1개의 줄에 트리 상에서 연결된 두 정점이 주어진다.출력첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.예제 입출력 1입력71 66 33 54 12 44 7출력461314예제 입출력 2입력121 21 32 43 53 64 74 85 95 106 116 12출력11233445566코드(파이썬)import sysgraph = dict()tree = dict()queue = [1]visited = set()n = int(sys.stdin.readline())for line in sys.stdin.readlines():    s, e = map(int, line.split())        if s in graph:        graph[s].append(e)    else:        graph[s] = [e]    if e in graph:        graph[e].append(s)    else:        graph[e] = [s]while queue:    for _ in range(len(queue)):                i = queue.pop()                if i not in visited:            queue.extend(graph[i])            visited.add(i)                        for v in graph[i]:                graph[v].remove(i)                tree[v] = isys.stdout.write('\\n'.join([str(tree[i]) for i in range(2, n+1)]))특이사항  자식이 키이고 부모를 값으로 하는 tree 딕셔너리 이용  내 코드(77,044KB, 404ms)에 비해 우수한 코드(바로가기, 49,356KB, 344ms)와 비교                  # 11725 트리의 부모 찾기from sys import stdin as sinput = s.readlinen = int(input())connection = [[] for _ in range(n + 1)]for _ in range(n - 1):    x, y = map(int, input().split())    connection[x].append(y)    connection[y].append(x)parents = [0] * (n + 1)visited = [False] * (n + 1)visited[1] = Truestart = [1]while start:    new_start = []    for now in start:        for can_go in connection[now]:            if not visited[can_go]:                parents[can_go] = now                visited[can_go] = True                new_start.append(can_go)    start = new_startfor i in parents[2:]:    print(i)                    트리 생성                  기존: graph 딕셔너리에 저장 뒤 이를 이용하여 tree 딕셔너리 작성          개선: connection 리스트에 저장 뒤 이를 이용하여 parents 리스트 작성                    방문 여부                  기존: 셋          개선: 리스트                      동일한 기존 코드에서 리스트와 셋을 비교한 결과                                                            구분                  메모리                  시간                                                                              리스트                  71,172ms                  416ms                                                  셋                  77,044ms                  404ms                                                              차후 풀이에서는 리스트 사용할 것                    참고문헌-"
  },
  
  {
    "title": "백준 11403번 경로 찾기",
    "url": "/posts/0029_boj_11403/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 플로이드-워셜 알고리즘(floyd_warshall_algorithm)",
    "date": "2022-02-28 21:11:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프이론 #그래프탐색 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      256 MB      문제가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프이론 #그래프탐색 #플로이드-워셜조건            시간 제한      메모리 제한                  1 초      256 MB      문제가중치 없는 방향 그래프 G가 주어졌을 때, 모든 정점 (i, j)에 대해서, i에서 j로 가는 경로가 있는지 없는지 구하는 프로그램을 작성하시오.입력첫째 줄에 정점의 개수 N (1 ≤ N ≤ 100)이 주어진다. 둘째 줄부터 N개 줄에는 그래프의 인접 행렬이 주어진다. i번째 줄의 j번째 숫자가 1인 경우에는 i에서 j로 가는 간선이 존재한다는 뜻이고, 0인 경우는 없다는 뜻이다. i번째 줄의 i번째 숫자는 항상 0이다.출력총 N개의 줄에 걸쳐서 문제의 정답을 인접행렬 형식으로 출력한다. 정점 i에서 j로 가는 경로가 있으면 i번째 줄의 j번째 숫자를 1로, 없으면 0으로 출력해야 한다.예제 입출력 1입력30 1 00 0 11 0 0출력1 1 11 1 11 1 1예제 입출력 2입력70 0 0 1 0 0 00 0 0 0 0 0 10 0 0 0 0 0 00 0 0 0 1 1 01 0 0 0 0 0 00 0 0 0 0 0 10 0 1 0 0 0 0출력1 0 1 1 1 1 10 0 1 0 0 0 10 0 0 0 0 0 01 0 1 1 1 1 11 0 1 1 1 1 10 0 1 0 0 0 10 0 1 0 0 0 0코드(파이썬)import sysn = int(sys.stdin.readline())graph = [list(map(int, line.split())) for line in sys.stdin.readlines()]for m in range(n):    for s in range(n):        for e in range(n):            graph[s][e] |= graph[s][m] &amp; graph[m][e]            for line in graph:    sys.stdout.write(' '.join(map(str, line)) + '\\n')특이사항  플로이드-워셜 알고리즘 기초 문제  내 코드(30,864KB, 384ms)에 비해 우수한 코드(바로가기, 32,404KB, 104ms)와 비교                  from sys import stdinfrom collections import dequedef bfs(n):    queue = deque([n])    while queue:        k = queue.popleft()        for i in adjacent_list[k]:            if not visited_list[i]:                queue.append(i)                visited_list[i] = Truen = int(stdin.readline())adjacent_matrix = [list(map(int, stdin.readline().split())) for _ in range(n)]adjacent_list = [[] for _ in range(n)]for i in range(n):    for j in range(n):        if adjacent_matrix[i][j] == 1:            adjacent_list[i].append(j)for i in range(n):    visited_list = [False] * n    bfs(i)    for j in range(n):        if visited_list[j]:            print(1, end=' ')        else:            print(0, end=' ')    print()                    그래프 갱신 방법                  기존: 플로이드-워셜 알고리즘          개선: bfs 이용해 각 노드마다 계산                    참고문헌-"
  },
  
  {
    "title": "백준 16236번 아기상어",
    "url": "/posts/0028_boj_16236/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search), 시뮬레이션(simulation)",
    "date": "2022-02-25 21:15:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #구현 #그래프이론 #그래프탐색 #너비 우선 탐색 #시뮬레이션조건            시간 제한      메모리 제한                  2 초      512 MB      문제N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold3관련 개념: #구현 #그래프이론 #그래프탐색 #너비 우선 탐색 #시뮬레이션조건            시간 제한      메모리 제한                  2 초      512 MB      문제N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.  더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.  먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.  먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.  거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.          거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.      아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.      아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.입력첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.  0: 빈 칸  1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기  9: 아기 상어의 위치아기 상어는 공간에 한 마리 있다.출력첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.예제 입출력 1입력30 0 00 0 00 9 0출력0예제 입출력 2입력30 0 10 0 00 9 0출력3예제 입출력 3입력44 3 2 10 0 0 00 0 9 01 2 3 4출력14예제 입출력 4입력65 4 3 2 3 44 3 2 3 4 53 2 9 5 6 62 1 2 3 4 53 2 1 6 5 46 6 6 6 6 6출력60예제 입출력 5입력66 0 6 0 6 10 0 0 0 0 22 3 4 5 6 60 0 0 0 0 20 2 0 0 0 03 9 3 0 0 1출력48예제 입출력 6입력61 1 1 1 1 12 2 6 2 2 32 2 5 2 2 32 2 2 4 6 30 0 0 0 0 60 0 0 0 0 9출력39코드(파이썬)from collections import dequedef bfs(start):    global size, eat        queue = deque([start])    tmp_r = list()    v = {start}    cnt = 0        while queue:        cnt += 1                for _ in range(len(queue)):            loc = queue.popleft()                        for d_x, d_y in ((-1,0), (0,-1), (0,1), (1,0)):                n_x, n_y = (loc[0]+d_x, loc[1]+d_y)                                if -1 &lt; n_x &lt; n and -1 &lt; n_y &lt; n and (n_x, n_y) not in v:                    if 0 &lt; fishbowl[n_x][n_y] &lt; size:                        tmp_r.append((n_x, n_y))                    elif fishbowl[n_x][n_y] == 0 or fishbowl[n_x][n_y] == size:                        v.add((n_x, n_y))                        queue.append((n_x, n_y))                if tmp_r:            tmp_r.sort()            t_x, t_y = tmp_r[0]            fishbowl[t_x][t_y] = 0            eat += 1                        if eat == size:                size += 1                eat = 0                            return cnt, (t_x, t_y)            return -1, startn = int(input())fishbowl = [list(map(int, input().split())) for _ in range(n)]size = 2eat = 0result = 0for i in range(n):    for j in range(n):        if fishbowl[i][j] == 9:            start = (i, j)            break        if any([any(0 &lt; i &lt; size for i in line) for line in fishbowl]):    fishbowl[start[0]][start[1]] = 0    while True:        tmp, start = bfs(start)        if tmp == -1:            break        else:            result += tmp    print(result)특이사항  BFS로 해결할 수 있는 문제          9(아기상어 위치)가 있는 지점을 start에 저장      현재 어항에 먹을 수 있는 물고기가 있다면 bfs 반복                  먹을 수 있는 물고기가 없다면, -1과 시작 좌표 반환          먹을 수 있는 물고기가 있따면, 현재 위치에서 가장 가깝고 먹을 수 있는 물고기를 tmp_r에 저장          tmp_r에 저장된 물고기 위치 중 가장 위쪽이면서 왼쪽에 해당하는 물고기까지의 거리와 물고기 좌표 반환                      내 코드(32,504KB, 88ms)와 다른 코드들을 비교한 결과, 비슷한 알고리즘의 구현 형태만 달라 따로 코드는 적지 않겠음참고문헌-"
  },
  
  {
    "title": "백준 14500번 테트로미노",
    "url": "/posts/0027_boj_14500/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 브루트포스(bruteforce)",
    "date": "2022-02-24 21:43:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #브루트포스조건            시간 제한      메모리 제한                  2 초      512 MB      문제폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.정사각형은 서로 겹치면 안 된다.도형은 모두 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #브루트포스조건            시간 제한      메모리 제한                  2 초      512 MB      문제폴리오미노란 크기가 1×1인 정사각형을 여러 개 이어서 붙인 도형이며, 다음과 같은 조건을 만족해야 한다.정사각형은 서로 겹치면 안 된다.도형은 모두 연결되어 있어야 한다.정사각형의 변끼리 연결되어 있어야 한다. 즉, 꼭짓점과 꼭짓점만 맞닿아 있으면 안 된다.정사각형 4개를 이어 붙인 폴리오미노는 테트로미노라고 하며, 다음과 같은 5가지가 있다.아름이는 크기가 N×M인 종이 위에 테트로미노 하나를 놓으려고 한다. 종이는 1×1 크기의 칸으로 나누어져 있으며, 각각의 칸에는 정수가 하나 쓰여 있다.테트로미노 하나를 적절히 놓아서 테트로미노가 놓인 칸에 쓰여 있는 수들의 합을 최대로 하는 프로그램을 작성하시오.테트로미노는 반드시 한 정사각형이 정확히 하나의 칸을 포함하도록 놓아야 하며, 회전이나 대칭을 시켜도 된다.입력첫째 줄에 종이의 세로 크기 N과 가로 크기 M이 주어진다. (4 ≤ N, M ≤ 500)둘째 줄부터 N개의 줄에 종이에 쓰여 있는 수가 주어진다. i번째 줄의 j번째 수는 위에서부터 i번째 칸, 왼쪽에서부터 j번째 칸에 쓰여 있는 수이다. 입력으로 주어지는 수는 1,000을 넘지 않는 자연수이다.출력첫째 줄에 테트로미노가 놓인 칸에 쓰인 수들의 합의 최댓값을 출력한다.예제 입출력 1입력5 51 2 3 4 55 4 3 2 12 3 4 5 66 5 4 3 21 2 1 2 1출력19예제 입출력 2입력4 51 2 3 4 51 2 3 4 51 2 3 4 51 2 3 4 5출력20예제 입출력 3입력4 101 2 1 2 1 2 1 2 1 22 1 2 1 2 1 2 1 2 11 2 1 2 1 2 1 2 1 22 1 2 1 2 1 2 1 2 1출력7코드(파이썬)import sysn, m = map(int, sys.stdin.readline().split())paper = [tuple(map(int, line.split(' '))) for line in sys.stdin.readlines()]result = 0tetro = {(1,4): ((0,0), (0,1), (0,2), (0,3)),         (2,2): ((0,0), (0,1), (1,0), (1,1)),         (2,3): (((0,0), (0,1), (0,2), (1,2)), ((0,0), (1,0), (1,1), (1,2)), ((0,0), (0,1), (0,2), (1,0)), ((0,2), (1,0), (1,1), (1,2)),                 ((0,0), (0,1), (0,2), (1,1)), ((0,1), (1,0), (1,1), (1,2)), ((0,1), (0,2), (1,0), (1,1)), ((0,0), (0,1), (1,1), (1,2))),         (3,2): (((0,0), (0,1), (1,0), (2,0)), ((0,1), (1,1), (2,0), (2,1)), ((0,0), (0,1), (1,1), (2,1)), ((0,0), (1,0), (2,0), (2,1)),                 ((0,0), (1,0), (1,1), (2,0)), ((0,1), (1,0), (1,1), (2,1)), ((0,1), (1,0), (1,1), (2,0)), ((0,0), (1,0), (1,1), (2,1))),         (4,1): ((0,0), (1,0), (2,0), (3,0))}for x, y in [(1,4), (2,2), (4,1)]:    for i in range(n-x+1):        for j in range(m-y+1):            result = max(sum([paper[i+tx][j+ty] for tx, ty in tetro[(x, y)]]), result)    for x, y in [(2,3), (3,2)]:    for i in range(n-x+1):        for j in range(m-y+1):            for points in tetro[(x, y)]:                result = max(sum([paper[i+tx][j+ty] for tx, ty in points]), result)print(result)특이사항  틀릴 것이라 생각해서 정리하지 않고 제출했으나 정답이었음  DFS로 해결하려 했으나 T자 블록을 구현하는데 실패  내 코드(36,516KB, 4,348ms)에 비해 우수한 코드(바로가기, 37,336KB, 256ms)와 비교                  import sysinput = sys.stdin.readlinedef dfs(r, c, idx, total):    global ans    if ans &gt;= total + max_val * (3 - idx):        return    if idx == 3:        ans = max(ans, total)        return    else:        for i in range(4):            nr = r + dr[i]            nc = c + dc[i]            if 0 &lt;= nr &lt; N and 0 &lt;= nc &lt; M and visit[nr][nc] == 0:                if idx == 1:                    visit[nr][nc] = 1                    dfs(r, c, idx + 1, total + arr[nr][nc])                    visit[nr][nc] = 0                visit[nr][nc] = 1                dfs(nr, nc, idx + 1, total + arr[nr][nc])                visit[nr][nc] = 0N, M = map(int, input().split())arr = [list(map(int, input().split())) for _ in range(N)]visit = [([0] * M) for _ in range(N)]dr = [-1, 0, 1, 0]dc = [0, 1, 0, -1]ans = 0max_val = max(map(max, arr))for r in range(N):    for c in range(M):        visit[r][c] = 1        dfs(r, c, 0, arr[r][c])        visit[r][c] = 0print(ans)                            구현방식                  기존: 브루트포스          개선: DFS                    T자 블록 처리                  기존: 실패          개선: DFS 1번 반복 후 처음 좌표에서 DFS를 시작하는 방법으로 해결                    참고문헌-"
  },
  
  {
    "title": "백준 6064번 카잉 달력",
    "url": "/posts/0026_boj_6064/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 정수론(number_theory), 중국인의 나머지 정리(chinese_remainder_theorem)",
    "date": "2022-02-22 15:43:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #정수론 #중국인의 나머지 정리조건            시간 제한      메모리 제한                  1 초      256 MB      문제최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #정수론 #중국인의 나머지 정리조건            시간 제한      메모리 제한                  1 초      256 MB      문제최근에 ICPC 탐사대는 남아메리카의 잉카 제국이 놀라운 문명을 지닌 카잉 제국을 토대로 하여 세워졌다는 사실을 발견했다. 카잉 제국의 백성들은 특이한 달력을 사용한 것으로 알려져 있다. 그들은 M과 N보다 작거나 같은 두 개의 자연수 x, y를 가지고 각 년도를 와 같은 형식으로 표현하였다. 그들은 이 세상의 시초에 해당하는 첫 번째 해를 &lt;1:1&gt;로 표현하고, 두 번째 해를 &lt;2:2&gt;로 표현하였다. 의 다음 해를 표현한 것을 &lt;x':y'&gt;이라고 하자. 만일 x &lt; M 이면 x' = x + 1이고, 그렇지 않으면 x' = 1이다. 같은 방식으로 만일 y &lt; N이면 y' = y + 1이고, 그렇지 않으면 y' = 1이다. 은 그들 달력의 마지막 해로서, 이 해에 세상의 종말이 도래한다는 예언이 전해 온다.예를 들어, M = 10 이고 N = 12라고 하자. 첫 번째 해는 &lt;1:1&gt;로 표현되고, 11번째 해는 &lt;1:11&gt;로 표현된다. &lt;3:1&gt;은 13번째 해를 나타내고, &lt;10:12&gt;는 마지막인 60번째 해를 나타낸다.네 개의 정수 M, N, x와 y가 주어질 때, 이 카잉 달력의 마지막 해라고 하면 는 몇 번째 해를 나타내는지 구하는 프로그램을 작성하라.입력입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 구성된다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터는 한 줄로 구성된다. 각 줄에는 네 개의 정수 M, N, x와 y가 주어진다. (1 ≤ M, N ≤ 40,000, 1 ≤ x ≤ M, 1 ≤ y ≤ N) 여기서 은 카잉 달력의 마지막 해를 나타낸다.출력출력은 표준 출력을 사용한다. 각 테스트 데이터에 대해, 정수 k를 한 줄에 출력한다. 여기서 k는 가 k번째 해를 나타내는 것을 의미한다. 만일 에 의해 표현되는 해가 없다면, 즉, 가 유효하지 않은 표현이면, -1을 출력한다.예제 입출력 1입력310 12 3 910 12 7 213 11 5 6출력33-183코드1(파이썬)import mathimport syst = int(sys.stdin.readline())for _ in range(t):    m, n, x, y = tuple(map(int, sys.stdin.readline().split()))    lcm = n * m // math.gcd(n, m)    x_set = set([i*m + x for i in range(lcm // m)])    y_set = set([i*n + y for i in range(lcm // n)])    intersection = x_set.intersection(y_set)        if intersection:        print(intersection.pop())    else:        print(-1)코드2(파이썬)import mathimport syst = int(sys.stdin.readline())for _ in range(t):    m, n, x, y = tuple(map(int, sys.stdin.readline().split()))    result = -1    # y = n인 경우 대비    y %= n    # x 자리에 위치하는 몫들의 최대치    x_quotient_max = n // math.gcd(n, m)        # 몫(q) * m + x = 원래 정수    # 원래 정수 % n = y    for q in range(x_quotient_max):        # 후보가 존재한다면        if (q*m + x) % n == y:            result = q*m + x            break        print(result)특이사항  코드1(45,564KB, 4,952ms)          입력받은 x, y를 나머지로 갖는 모든 숫자를 리스트에 저장      각 리스트에 공통 원소 탐색        코드2(32,976KB, 1,692ms)          입력받은 x를 나머지로 갖는 숫자 중 최댓값 탐색      몫을 반복하면서 입력받은 y를 나머지로 갖는 숫자 탐색        중국인의 나머지 정리를 활용하면 획기적인 메모리 및 수행시간 절약 가능  우수 코드1(https://www.acmicpc.net/source/37435910, 32976KB, 756ms)과의 비교                  import sysimport mathinput = sys.stdin.readlineTEST_CASE = int(input())def solveCal():    M, N, x, y = map(int, input().split())    lcm = int(M / math.gcd(M, N) * N)    if x == M:        x = 0    if y == N:        y = 0    for i in range(x, lcm, M):        if i == 0:            continue        if i % N == y:            return i    return -1def solution():    answer = []    for _ in range(TEST_CASE):        answer.append(str(solveCal()))    print(\"\\n\".join(answer))solution()                        코드2의 방식과 유사하지만, 반복문의 형태를 보다 단순화        우수 코드2(https://www.acmicpc.net/source/36946527, 29200KB, 68ms)와의 비교                  import sys# extended euclidean algorithmdef EEA(a,b):    s1,s2,t1,t2 = 1, 0, 0, 1    while b:        q = a//b        a,b = b,a-q*b        s1,s2 = s2,s1-q*s2        t1,t2 = t2,t1-q*t2    return a,s1,t1t= int(sys.stdin.readline().rstrip(\"\\n\"))for _ in range(t):    n,m,x,y = list(map(int,sys.stdin.readline().rstrip(\"\\n\").split(\" \")))    if m&gt;n:        x,y = y,x        n,m = m,n    g,a,b = EEA(n,m)    lcm = n*m//g    d = x-y    if d%g !=0:        print(\"-1\")    else:        K=x-d//g*a*n        print((K-1)%lcm+1)                    확장된 유클리드 호제법과 중국인 나머지 정리를 활용한 사례      수학 공부가 더 필요해보임…      참고문헌  joonas, “확장 유클리드 알고리즘으로 나머지 연산의 곱셈 역원 구하기”, Joonas’ Note, https://blog.joonas.io/25?category=722678"
  },
  
  {
    "title": "백준 9019번 DSLR",
    "url": "/posts/0025_boj_9019/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-02-21 22:31:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  6 초      256 MB      문제네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다. 이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold4관련 개념: #그래프이론 #그래프탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  6 초      256 MB      문제네 개의 명령어 D, S, L, R 을 이용하는 간단한 계산기가 있다. 이 계산기에는 레지스터가 하나 있는데, 이 레지스터에는 0 이상 10,000 미만의 십진수를 저장할 수 있다. 각 명령어는 이 레지스터에 저장된 n을 다음과 같이 변환한다. n의 네 자릿수를 d1, d2, d3, d4라고 하자(즉 n = ((d1 × 10 + d2) × 10 + d3) × 10 + d4라고 하자)  D: D 는 n을 두 배로 바꾼다. 결과 값이 9999 보다 큰 경우에는 10000 으로 나눈 나머지를 취한다. 그 결과 값(2n mod 10000)을 레지스터에 저장한다.  S: S 는 n에서 1 을 뺀 결과 n-1을 레지스터에 저장한다. n이 0 이라면 9999 가 대신 레지스터에 저장된다.  L: L 은 n의 각 자릿수를 왼편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d2, d3, d4, d1이 된다.  R: R 은 n의 각 자릿수를 오른편으로 회전시켜 그 결과를 레지스터에 저장한다. 이 연산이 끝나면 레지스터에 저장된 네 자릿수는 왼편부터 d4, d1, d2, d3이 된다.위에서 언급한 것처럼, L 과 R 명령어는 십진 자릿수를 가정하고 연산을 수행한다. 예를 들어서 n = 1234 라면 여기에 L 을 적용하면 2341 이 되고 R 을 적용하면 4123 이 된다.여러분이 작성할 프로그램은 주어진 서로 다른 두 정수 A와 B(A ≠ B)에 대하여 A를 B로 바꾸는 최소한의 명령어를 생성하는 프로그램이다. 예를 들어서 A = 1234, B = 3412 라면 다음과 같이 두 개의 명령어를 적용하면 A를 B로 변환할 수 있다.1234 →L 2341 →L 34121234 →R 4123 →R 3412따라서 여러분의 프로그램은 이 경우에 LL 이나 RR 을 출력해야 한다.n의 자릿수로 0 이 포함된 경우에 주의해야 한다. 예를 들어서 1000 에 L 을 적용하면 0001 이 되므로 결과는 1 이 된다. 그러나 R 을 적용하면 0100 이 되므로 결과는 100 이 된다.입력프로그램 입력은 T 개의 테스트 케이스로 구성된다. 테스트 케이스 개수 T 는 입력의 첫 줄에 주어진다. 각 테스트 케이스로는 두 개의 정수 A와 B(A ≠ B)가 공백으로 분리되어 차례로 주어지는데 A는 레지스터의 초기 값을 나타내고 B는 최종 값을 나타낸다. A 와 B는 모두 0 이상 10,000 미만이다.전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.출력A에서 B로 변환하기 위해 필요한 최소한의 명령어 나열을 출력한다. 가능한 명령어 나열이 여러가지면, 아무거나 출력한다.예제 입출력 1입력31234 34121000 11 16출력LLLDDDD코드(파이썬)import sysfrom collections import dequedef bfs(a, b):    queue = deque(next_[a])    v = {num for num, _ in queue}    if b in v:        for num, command in queue:            if num == b:                sys.stdout.write(command+\"\\n\")                return    else:        while True:            for _ in range(len(queue)):                n, c = queue.popleft()                                for num, command in next_[n]:                    if num not in v:                        if num == b:                            sys.stdout.write(c+command+\"\\n\")                            return                                                    v.add(num)                        queue.append((num, c+command))    n = int(sys.stdin.readline())next_ = dict()for i in range(10000):    tmp_i = f\"{i:04d}\"    next_[i] = [((i*2) % 10000, 'D'), (i-1 if i-1 &gt; -1 else 9999, 'S'), (int(tmp_i[1:]+tmp_i[0]), 'L'), (int(tmp_i[3]+tmp_i[:3]), 'R')]for _ in range(n):    a, b = map(int, sys.stdin.readline().split())        bfs(a, b)특이사항  BFS를 활용: (숫자, 탐색문자열)을 큐에 저장  아는 개념이었기에 난이도에 비해 쉽게 해결할 수 있었음  내 코드(228,964KB, 12,072ms)에 비해 우수한 코드(바로가기, 231,944KB, 4,804ms)와 비교                  import sysfrom collections import dequeT = int(sys.stdin.readline())results = []for t in range(T):    num, target = map(int, sys.stdin.readline().split())    visited = [False] * 10000    Q = deque()    Q.append(('', num))    visited[num] = True    while Q:        command, cur = Q.popleft()        if cur == target:            break        temp = (cur * 2) % 10000        if not visited[temp]:            visited[temp] = True            Q.append((command + 'D', temp))        if cur == 0:            temp = 9999        else:            temp = cur - 1        if not visited[temp]:            visited[temp] = True            Q.append((command + 'S', temp))        temp = (cur % 1000) * 10 + cur // 1000        if not visited[temp]:            visited[temp] = True            Q.append((command + 'L', temp))        temp = (cur % 10) * 1000 + cur // 10        if not visited[temp]:            visited[temp] = True            Q.append((command + \"R\", temp))    results.append(command)for e in results:    print(e)                          그래프 탐색 과정                          기존: 한 번에 연산 뒤 next_에 저장하고 필요할 때마다 접근              개선: 각각 연산                                          참고문헌-"
  },
  
  {
    "title": "백준 5430번 AC",
    "url": "/posts/0024_boj_5430/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 구현(implementation), 자료구조(data_structure), 문자열(string), 파싱(parsing), 덱(deque)",
    "date": "2022-02-18 17:46:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #자료구조 #문자열 #파싱 #덱조건            시간 제한      메모리 제한                  1 초      256 MB      문제선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #구현 #자료구조 #문자열 #파싱 #덱조건            시간 제한      메모리 제한                  1 초      256 MB      문제선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, “AB”는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, “RDD”는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.입력첫째 줄에 테스트 케이스의 개수 T가 주어진다. T는 최대 100이다.각 테스트 케이스의 첫째 줄에는 수행할 함수 p가 주어진다. p의 길이는 1보다 크거나 같고, 100,000보다 작거나 같다.다음 줄에는 배열에 들어있는 수의 개수 n이 주어진다. (0 ≤ n ≤ 100,000)다음 줄에는 [x1,…,xn]과 같은 형태로 배열에 들어있는 정수가 주어진다. (1 ≤ xi ≤ 100)전체 테스트 케이스에 주어지는 p의 길이의 합과 n의 합은 70만을 넘지 않는다.출력각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.예제 입출력 1입력4RDD4[1,2,3,4]DD1[42]RRD6[1,1,2,3,5,8]D0[]출력[2,1]error[1,2,3,5,8]error코드(파이썬)import sysfrom collections import dequet = int(sys.stdin.readline())for _ in range(t):    direction = 1    func = sys.stdin.readline().rstrip('\\n')    n = int(sys.stdin.readline())    nums = sys.stdin.readline().strip(\"[]\\n\")        if sum([1 for ch in func if ch == \"D\"]) &lt;= n:        if n:            nums = deque(tuple(map(int, nums.split(\",\"))))            for ch in func:                if ch == \"R\":                    direction *= -1                else:                    if direction &gt; 0:                        nums.popleft()                    else:                        nums.pop()                        if direction &lt; 0:                nums = list(nums)[::-1]        else:            nums = tuple()                    sys.stdout.write(\"[\"+\",\".join(map(str, nums))+\"]\\n\")    else:        sys.stdout.write(\"error\\n\")특이사항  배열 앞과 뒤에서 값을 제거하므로 deque 사용  내 코드(38,480KB, 316ms)에 비해 우수한 코드(바로가기, 40,528KB, 168ms)와 비교                  t = int(input())for _ in range(t):    p = input()    n = int(input())    arr = input()[1:-1].split(',')    p = p.replace('RR','')            r = 0    f, b = 0, 0            for i in p:        if i == 'R':            r += 1        elif i == 'D':            if r % 2 == 0:                f += 1            else:                b += 1            if f + b &lt;= n:        arr = arr[f:n-b]        if r % 2 == 1:            print('['+','.join(arr[::-1])+']')        else:            print('['+','.join(arr)+']')    else:        print('error')                          값 버리기 방식                          기존: 실제로 제거              개선: 값을 지우는 대신, 배열 인덱스 조정                                          참고문헌-"
  },
  
  {
    "title": "백준 11286번 절댓값 힙",
    "url": "/posts/0023_boj_11286/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 자료구조(data_structure), 우선순위큐(priority_queue)",
    "date": "2022-02-17 21:55:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #자료구조 #우선순위큐조건            시간 제한      메모리 제한                  1 초 (추가 시간 없음)      256 MB      문제절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.배열에 정수 x (x ≠ 0)를 넣는다.배열에서 절댓값이 가장 작은 값...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #자료구조 #우선순위큐조건            시간 제한      메모리 제한                  1 초 (추가 시간 없음)      256 MB      문제절댓값 힙은 다음과 같은 연산을 지원하는 자료구조이다.배열에 정수 x (x ≠ 0)를 넣는다.배열에서 절댓값이 가장 작은 값을 출력하고, 그 값을 배열에서 제거한다. 절댓값이 가장 작은 값이 여러개일 때는, 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.프로그램은 처음에 비어있는 배열에서 시작하게 된다.입력첫째 줄에 연산의 개수 N(1≤N≤100,000)이 주어진다. 다음 N개의 줄에는 연산에 대한 정보를 나타내는 정수 x가 주어진다. 만약 x가 0이 아니라면 배열에 x라는 값을 넣는(추가하는) 연산이고, x가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 경우이다. 입력되는 정수는 -231보다 크고, 231보다 작다.출력입력에서 0이 주어진 회수만큼 답을 출력한다. 만약 배열이 비어 있는 경우인데 절댓값이 가장 작은 값을 출력하라고 한 경우에는 0을 출력하면 된다.예제 입출력 1입력181-100011-1-12-20000000출력-110-1-111-220코드(파이썬)import sysimport heapqn = int(sys.stdin.readline())heap = list()for _ in range(n):    num = int(sys.stdin.readline())    if num:        heapq.heappush(heap, (abs(num), 1 if num &gt; 0 else -1))    else:        if heap:            r, sign = heapq.heappop(heap)            sys.stdout.write(str(r * sign)+'\\n')        else:            sys.stdout.write('0\\n')특이사항  내장모듈의 위대함을 알 수 있음  절대값과 원래 값의 부호를 한 번에 저장한 뒤 heap에 저장참고문헌-"
  },
  
  {
    "title": "백준 1107번 리모컨",
    "url": "/posts/0022_boj_1107/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 브루트포스(bruteforce)",
    "date": "2022-02-16 15:38:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #브루트포스조건            시간 제한      메모리 제한                  2 초      256 MB      문제수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.리모컨에는 버튼이 0부터 9까지 숫...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #브루트포스조건            시간 제한      메모리 제한                  2 초      256 MB      문제수빈이는 TV를 보고 있다. 수빈이는 채널을 돌리려고 했지만, 버튼을 너무 세게 누르는 바람에, 일부 숫자 버튼이 고장났다.리모컨에는 버튼이 0부터 9까지 숫자, +와 -가 있다. +를 누르면 현재 보고있는 채널에서 +1된 채널로 이동하고, -를 누르면 -1된 채널로 이동한다. 채널 0에서 -를 누른 경우에는 채널이 변하지 않고, 채널은 무한대 만큼 있다.수빈이가 지금 이동하려고 하는 채널은 N이다. 어떤 버튼이 고장났는지 주어졌을 때, 채널 N으로 이동하기 위해서 버튼을 최소 몇 번 눌러야하는지 구하는 프로그램을 작성하시오.수빈이가 지금 보고 있는 채널은 100번이다.입력첫째 줄에 수빈이가 이동하려고 하는 채널 N (0 ≤ N ≤ 500,000)이 주어진다.  둘째 줄에는 고장난 버튼의 개수 M (0 ≤ M ≤ 10)이 주어진다. 고장난 버튼이 있는 경우에는 셋째 줄에는 고장난 버튼이 주어지며, 같은 버튼이 여러 번 주어지는 경우는 없다.출력첫째 줄에 채널 N으로 이동하기 위해 버튼을 최소 몇 번 눌러야 하는지를 출력한다.예제 입출력 1입력545736 7 8출력6예제 입출력 2입력10050 1 2 3 4출력0예제 입출력 3입력50000080 2 3 4 6 7 8 9출력11117예제 입출력 4입력10031 0 5출력0예제 입출력 5입력141240출력5예제 입출력 6입력191 2 3 4 5 6 7 8 9출력2예제 입출력 7입력8000028 9출력2228코드(파이썬)def dfs(index, now_cnt, button):    r = now_cnt        # 1. 1234 vs 1234 원하는 길이 도달 (더 이상 탐색할 필요 없음)    if len(target) - len(stack) == 0:        r = min(r, abs(int(target) - int(''.join(map(str, stack)))) + len(str(int(''.join(map(str, stack))))))    # 2. 1234 vs 122ㅁ의 경우 (더 이상 탐색할 필요 없음)    elif  target[index-1] != button:        if stack[-1] &gt; int(target[index-1]):            etc = str(min(buttons))        else:            etc = str(max(buttons))                r = min(r, abs(int(target) - int(''.join(map(str, stack)) + etc * (len(target) - index))) + len(target))    # 3. 그 외    elif index &lt; len(target):        for b in get_next(target[min(index, len(target)-1)]):            stack.append(b)            r = dfs(index+1, r, str(b))            stack.pop()                return rdef get_next(num):    start = []        if type(num) == str:        num = int(num)        if len(buttons) &gt; 2:        if num in buttons:            near_button_index = buttons.index(num)        else:            tmp = sorted(buttons.copy() + [num])            near_button_index = tmp.index(num) if tmp.index(num) &lt; len(buttons) else 0                start.append(buttons[near_button_index])        start.append(buttons[near_button_index+1 if near_button_index+1 &lt; len(buttons) else 0])        start.append(buttons[near_button_index-1 if near_button_index+1 &gt; -1 else len(buttons)-1])    else:        start = buttons        return startstack = []start = []cnt2 = 0target = input().rstrip()m = int(input())wrong_buttons = tuple(map(int, input().split())) if m else tuple()buttons = [i for i in range(0, 10) if i not in  wrong_buttons]result = abs(100 - int(target))if buttons:    # 자릿수가 차이나는 채널을 따로 계산    digit_p1, digit_m1 = 5000000, 5000000    if len(target) &lt; 6:        if len(buttons) &gt; 1:                if buttons[0] == 0:                    digit_p1 = int(str(buttons[1]) + (\"0\" * len(target)))                else:                    digit_p1 = int(str(buttons[0]) * (len(target)+1))        else:            digit_p1 = int(str(buttons[0]) * (len(target) + 1))    if len(target) &gt; 1:        digit_m1 = int(str(buttons[-1]) * (len(target) - 1))    result = min(result, (abs(int(target) - digit_p1) + len(str(digit_p1))), (abs(int(target) - digit_m1) + len(str(digit_m1))))        # 자릿수가 동일한 채널 계산    start = get_next(target[0])        for button in start:        stack.append(button)        result = dfs(1, result, str(button))        stack.pop()print(result)특이사항  굳이 이렇게 풀어야할까 싶은 풀이로 해결          예시 입력:        500131 4 5                    1 누를 버튼이 없음 -&gt; 처음채널(100)에서 이동      2 누를 버튼이 있음                  2-1 원하는 채널과 자릿수가 다르면서 차이가 적은 채널 탐색 (예시: 5001, 3, 1 4 5라면 999, 20000)          2-2 원하는 채널과 자릿수가 같으면서 차이가 적은 채널 탐색 (예시: 5001, 3, 1 4 5라면 5002)          2-3 2-1과 2-2의 결과 중 가장 차이가 적은 채널의 버튼 누른 횟수 계산                      풀이의 최적화 필요 (손으로 낙서하듯 해결함)  일반적인 풀이                  import sysdest = int(sys.stdin.readline().rstrip())n = int(input())ans = abs(100 - dest)if n != 0:    broken = set(input().split())else:    broken = set()for i in range(1000001):    for N in str(i):        if N in broken:            break    else:        ans = min(ans, len(str(i)) + abs(i - dest))      print(ans)                    간단한 브루트포스 형태        문제에 반례가 많은 관계로 다음의 반례모음 링크를 참고하기 바람          반례모음1 [바로가기]      반례모음2 [바로가기]      참고문헌-"
  },
  
  {
    "title": "백준 15654번 N과 M (5)",
    "url": "/posts/0021_boj_15654/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 백트래킹(backtracking)",
    "date": "2022-02-15 21:57:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #백트래킹조건            시간 제한      메모리 제한                  1 초      512 MB      문제N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다. ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #백트래킹조건            시간 제한      메모리 제한                  1 초      512 MB      문제N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. N개의 자연수는 모두 다른 수이다.  N개의 자연수 중에서 M개를 고른 수열입력첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.수열은 사전 순으로 증가하는 순서로 출력해야 한다.예제 입출력 1입력3 14 5 2출력245예제 입출력 2입력4 29 8 7 1출력1 71 81 97 17 87 98 18 78 99 19 79 8예제 입출력 3입력4 41231 1232 1233 1234출력1231 1232 1233 12341231 1232 1234 12331231 1233 1232 12341231 1233 1234 12321231 1234 1232 12331231 1234 1233 12321232 1231 1233 12341232 1231 1234 12331232 1233 1231 12341232 1233 1234 12311232 1234 1231 12331232 1234 1233 12311233 1231 1232 12341233 1231 1234 12321233 1232 1231 12341233 1232 1234 12311233 1234 1231 12321233 1234 1232 12311234 1231 1232 12331234 1231 1233 12321234 1232 1231 12331234 1232 1233 12311234 1233 1231 12321234 1233 1232 1231코드(파이썬)import sysdef backtrack(length):    if length == m:        sys.stdout.write(' '.join(stack) + '\\n')        return        for next_ in nums:        if next_ not in stack:            stack.append(next_)            backtrack(length+1)            stack.pop()n, m = map(int, input().split())nums = tuple(map(str, sorted(map(int, input().split()))))stack = []for num in nums:    stack.append(num)    backtrack(1)    stack.pop()특이사항  백트래킹에 대한 개념이 희미해져 복습 차원에서 풀이  입출력과 제어문 관련 약간의 실험 진행          입력:        8 81 2 3 4 5 6 7 8                    sys.stdout.write: 약 7.74초 vs print: 약 9.32초      for문 + 컴프리헨션: 약 7.76초 vs for문 + if문: 약 7.55초        내 코드보다 빠른 해답은 모두 itertools의 permutations 사용참고문헌-"
  },
  
  {
    "title": "백준 11051번 이항 계수 2",
    "url": "/posts/0020_boj_11051/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-02-11 17:17:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #정수론 #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제자연수 $N$과 정수 $K$가 주어졌을 때 이항 계수 $\\binom{N}{K}$를 10,007로 나눈 나머지를 구하는 프로그램을 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #수학 #정수론 #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  1 초      256 MB      문제자연수 $N$과 정수 $K$가 주어졌을 때 이항 계수 $\\binom{N}{K}$를 10,007로 나눈 나머지를 구하는 프로그램을 작성하시오.입력첫째 줄에 $N$과 $K$가 주어진다. (1 ≤ $N$ ≤ 1,000, 0 ≤ $K$ ≤ $N$)출력$\\binom{N}{K}$를 10,007로 나눈 나머지를 출력한다.예제 입출력 1입력5 2출력10코드(파이썬)import syssys.setrecursionlimit(10**6)def pascal(n, k):    if (n, k) in combs:        return combs[(n, k)]    else:        result = (pascal(n-1, k-1) + pascal(n-1, k)) % 10007        combs[(n, k)] = result        combs[(n, n-k)] = result                return result        n, k = map(int, input().split())combs = dict(zip([(i, 0) for i in range(1, n+1)]+[(i, i) for i in range(1, n+1)], [1 for _ in range(1, n+1)]+[1 for _ in range(1, n+1)]))result = pascal(n, k)print(result)특이사항  파스칼의 삼각형을 이용했으나 다이나믹 프로그래밍을 통해 해결 가능  아직 다이나믹 프로그래밍에 대한 개념 부족  내 코드(71,244KB, 272ms)에 비해 우수한 코드(바로가기, 30,864KB, 68ms)와 비교                  n, k = map(int, input().split())if k==0 or k==n:    print(1)else:    if 2*k&gt;n:        k=n-k    dp=[1]*(k+1) # k번째 항 : nCk (0항~k항)    dp[1]=n    for i in range(2,k+1):        dp[i]=(dp[i-1]*(n+1-i))//i    print(dp[k]%10007)                    참고문헌-"
  },
  
  {
    "title": "백준 1149번 RGB거리",
    "url": "/posts/0019_boj_1149/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming)",
    "date": "2022-02-10 15:49:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      128 MB      문제RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.집은 빨강, 초록, ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #다이나믹 프로그래밍조건            시간 제한      메모리 제한                  0.5 초(추가 시간 없음)      128 MB      문제RGB거리에는 집이 N개 있다. 거리는 선분으로 나타낼 수 있고, 1번 집부터 N번 집이 순서대로 있다.집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다. 각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때, 아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.  1번 집의 색은 2번 집의 색과 같지 않아야 한다.  N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.  i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.입력첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다. 둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다. 집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.출력첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.예제 입출력 1입력326 40 8349 60 5713 89 99출력96예제 입출력 2입력31 100 100100 1 100100 100 1출력3예제 입출력 3입력31 100 100100 100 1001 100 100출력102예제 입출력 4630 19 564 77 6415 19 974 71 5790 86 8493 32 91출력208예제 입출력 5입력871 39 4432 83 5551 37 6389 29 10083 58 1165 13 1547 25 2960 66 19출력253코드(파이썬)n = int(input())now = dict(zip(['r', 'g', 'b'], map(int, input().split())))for _ in range(n-1):    tmp = dict(zip(['r', 'g', 'b'], map(int, input().split())))    tmp['r'] += min(now['g'], now['b'])    tmp['g'] += min(now['b'], now['r'])    tmp['b'] += min(now['r'], now['g'])        now = tmp    print(min(now.values()))특이사항  각각의 색을 선택할 때의 최솟값을 업데이트하는 방식  내 코드(30,864KB, 112ms)에 비해 우수한 코드(바로가기, 30,864KB, 68ms)와 비교                  import syssys.setrecursionlimit(10**7)n = int(sys.stdin.readline().strip())cost = []for i in range(n):    cost.append(list(map(int,sys.stdin.readline().strip().split())))        for i in range(1,n):    cost[i][0] = min(cost[i-1][1],cost[i-1][2]) + cost[i][0]    cost[i][1] = min(cost[i-1][0],cost[i-1][2]) + cost[i][1]    cost[i][2] = min(cost[i-1][0],cost[i-1][1]) + cost[i][2]        print(min(cost[n-1]))                          기존: 임시 dict을 생성하고 업데이트          개선: 전체 길이 만큼의 리스트 생성 후 업데이트                    참고문헌-"
  },
  
  {
    "title": "백준 2004번 조합 0의 개수",
    "url": "/posts/0018_boj_2004/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 재귀(recursion)",
    "date": "2022-02-09 17:03:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #수학 #정수론조건            시간 제한      메모리 제한                  2 초      128 MB      문제$n \\choose m$의 끝자리 $0$의 개수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 정수 $n$, $m$ ($0 \\le m \\le n \\le...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #수학 #정수론조건            시간 제한      메모리 제한                  2 초      128 MB      문제$n \\choose m$의 끝자리 $0$의 개수를 출력하는 프로그램을 작성하시오.입력첫째 줄에 정수 $n$, $m$ ($0 \\le m \\le n \\le 2,000,000,000$, $n \\ne 0$)이 들어온다.출력첫째 줄에 $n \\choose m$의 끝자리 $0$의 개수를 출력한다.예제 입출력 1입력25 12출력2코드(파이썬)def get_fatorial_decimal(num):    r = list()        for tmp in [2, 5]:        i = tmp        cnt = 0                while i &lt;= num:            cnt += num // i            i *= tmp                r.append(cnt)                return rn, m = map(int, input().split())result = get_fatorial_decimal(n)for two, five in [get_fatorial_decimal(i) for i in (m, n-m)]:    result = (result[0]-two, result[1]-five)print(min(result))특이사항  풀이과정          $n!$에서 소인수분해 시 2의 개수($n1$)와 5의 개수($n2$) 계산      $n! = 2^{n1} \\times 5^{n2} \\times …$      $m! = 2^{m1} \\times 5^{m2} \\times …$      $k! = 2^{k1} \\times 5^{k2} \\times … \\quad (k = n - m)$ 라고 할 때,      ${n \\choose {m}} \\ = \\frac{n!}{m! \\times k!} $ $\\qquad = \\frac{2^{n1} \\times 5^{n2} \\times …}{(2^{m1} \\times 5^{m2} \\times …) \\times (2^{k1} \\times 5^{k2} \\times …)} $ $\\qquad = 2^{n1-m1-k1} \\times 5^{n2-m2-k2} \\times … $ $\\qquad = 10^{min(n1-m1-k1, \\ n2-m2-k2)} \\times … $      따라서, $n \\choose m$의 0의 개수는 $n1-m1-k1$과 $n2-m2-k2$ 중 작은 수에 따라 결정      참고문헌-"
  },
  
  {
    "title": "백준 1780번 종이의 개수",
    "url": "/posts/0017_boj_1780/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 재귀(recursion)",
    "date": "2022-02-07 22:15:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #분할정복 #재귀조건            시간 제한      메모리 제한                  2 초      256 MB      문제N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #분할정복 #재귀조건            시간 제한      메모리 제한                  2 초      256 MB      문제N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.  만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.  (1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.입력첫째 줄에 N(1 ≤ N ≤ 37, N은 3k 꼴)이 주어진다. 다음 N개의 줄에는 N개의 정수로 행렬이 주어진다.출력첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.예제 입출력 1입력90 0 0 1 1 1 -1 -1 -10 0 0 1 1 1 -1 -1 -10 0 0 1 1 1 -1 -1 -11 1 1 0 0 0 0 0 01 1 1 0 0 0 0 0 01 1 1 0 0 0 0 0 00 1 -1 0 1 -1 0 1 -10 -1 1 0 1 -1 0 1 -10 1 -1 1 0 -1 0 1 -1출력101211코드(파이썬)import sysdef dnq(x, y, k):    start = paper[x][y]        # 해당 구역이 전부 같은 숫자라면    if all([all(i==start for i in line[y:y+k]) for line in paper[x:x+k]]):        result[start] += 1    # 해당 구역을 더 나눌 수 없다면    elif k==3:                for key in [paper[x+s_x][y+s_y] for s_x, s_y in sector]:            result[key] +=1    # 그 외    else:        k //= 3        for s_x, s_y in sector:            dnq(x + s_x*k, y + s_y*k, k)    n = int(sys.stdin.readline())paper = [list(map(int, line.split())) for line in sys.stdin.readlines()]sector = sum([[(sector_x, sector_y) for sector_y in range(3)] for sector_x in range(3)], [])result = {-1:0, 0:0, 1:0}dnq(0, 0, n)print(*result.values(), sep=\"\\n\")특이사항  내 코드(84,072KB, 4,316ms)에 비해 우수한 코드(바로가기, 68,804KB, 2,852ms)와 비교                  import sysdef recursion(n, s):    x, y = s    standard = paper[x][y]    temp = {-1 : 0, 0 : 0, 1 : 0}    flag, t_flag = True, True            for i in range(x, x + n):                for j in range(y, y + n):                        if paper[i][j] != standard:                t_flag = False                break        if not t_flag:            flag = False            break                    if flag:        d[standard] += 1        return    elif n &gt; 3:        num = n // 3        for i in range(3):            for j in range(3):                recursion(num, (x + num * i, y + num * j))    else:        for i in range(x, x + n):            for j in range(y, y + n):                            d[paper[i][j]] += 1        return                                        input = sys.stdin.readlineN = int(input())paper = [list(map(int, input().rstrip().split())) for _ in range(N)]d = {-1 : 0, 0 : 0, 1 : 0}recursion(N, (0, 0))print(d[-1], d[0], d[1], sep = '\\n')                    다음 구역 선택 시                  기존: sector 리스트 생성해서 사용          개선: 이중 반복문으로 사용                    구역이 한 가지 색으로만 이루어져있는지 확인 방법                  기존: all 함수 사용          개선: 각 위치를 확인하고 만약 t_flag 값이 False로 바뀌면 여러 색이 있다고 판단                    참고문헌-"
  },
  
  {
    "title": "백준 3036번 링",
    "url": "/posts/0016_boj_3036/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 정수론(number_theory), 유클리드 호제법(euclidean_algorithm)",
    "date": "2022-02-04 22:07:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #수학 #정수론 #유클리드 호제법조건            시간 제한      메모리 제한                  1 초      128 MB      문제상근이는 창고에서 링 N개를 발견했다. 상근이는 각각의 링이 앞에 있는 링과 뒤에 있는 링과 접하도록 바닥에 내려놓았다.상근이는 첫 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #수학 #정수론 #유클리드 호제법조건            시간 제한      메모리 제한                  1 초      128 MB      문제상근이는 창고에서 링 N개를 발견했다. 상근이는 각각의 링이 앞에 있는 링과 뒤에 있는 링과 접하도록 바닥에 내려놓았다.상근이는 첫 번째 링을 돌리기 시작했고, 나머지 링도 같이 돌아간다는 사실을 발견했다. 나머지 링은 첫 번째 링 보다 빠르게 돌아가기도 했고, 느리게 돌아가기도 했다. 이렇게 링을 돌리다 보니 첫 번째 링을 한 바퀴 돌리면, 나머지 링은 몇 바퀴 도는지 궁금해졌다.링의 반지름이 주어진다. 이때, 첫 번째 링을 한 바퀴 돌리면, 나머지 링은 몇 바퀴 돌아가는지 구하는 프로그램을 작성하시오.입력첫째 줄에 링의 개수 N이 주어진다. (3 ≤ N ≤ 100)다음 줄에는 링의 반지름이 상근이가 바닥에 놓은 순서대로 주어진다. 반지름은 1과 1000를 포함하는 사이의 자연수이다.출력출력은 총 N-1줄을 해야 한다. 첫 번째 링을 제외한 각각의 링에 대해서, 첫 번째 링을 한 바퀴 돌리면 그 링은 몇 바퀴 도는지 기약 분수 형태 A/B로 출력한다.예제 입출력 1입력38 4 2출력2/14/1예제 입출력 2입력412 3 8 4출력4/13/23/1예제 입출력 3입력4300 1 1 300출력300/1300/11/1코드(파이썬)def gcd(num1, num2):    if num1 &lt; num2:        num1, num2 = num2, num1            r = num1 % num2        while r:        num1 = num2        num2 = r        r = num1 % num2            return num2    n = int(input())rings = list(map(int, input().split()))first = rings.pop(0)for ring in rings:    g = gcd(first, ring)    print(f\"{first//g}/{ring//g}\")특이사항  유클리드 호제법 사용참고문헌  “유클리드_호제법”, 위키피디아, https://ko.wikipedia.org/wiki/유클리드_호제법"
  },
  
  {
    "title": "백준 7569번 토마토",
    "url": "/posts/0015_boj_7569/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-02-03 15:34:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      256 MB      문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      256 MB      문제철수의 토마토 농장에서는 토마토를 보관하는 큰 창고를 가지고 있다. 토마토는 아래의 그림과 같이 격자모양 상자의 칸에 하나씩 넣은 다음, 상자들을 수직으로 쌓아 올려서 창고에 보관한다.창고에 보관되는 토마토들 중에는 잘 익은 것도 있지만, 아직 익지 않은 토마토들도 있을 수 있다. 보관 후 하루가 지나면, 익은 토마토들의 인접한 곳에 있는 익지 않은 토마토들은 익은 토마토의 영향을 받아 익게 된다. 하나의 토마토에 인접한 곳은 위, 아래, 왼쪽, 오른쪽, 앞, 뒤 여섯 방향에 있는 토마토를 의미한다. 대각선 방향에 있는 토마토들에게는 영향을 주지 못하며, 토마토가 혼자 저절로 익는 경우는 없다고 가정한다. 철수는 창고에 보관된 토마토들이 며칠이 지나면 다 익게 되는지 그 최소 일수를 알고 싶어 한다.토마토를 창고에 보관하는 격자모양의 상자들의 크기와 익은 토마토들과 익지 않은 토마토들의 정보가 주어졌을 때, 며칠이 지나면 토마토들이 모두 익는지, 그 최소 일수를 구하는 프로그램을 작성하라. 단, 상자의 일부 칸에는 토마토가 들어있지 않을 수도 있다.입력첫 줄에는 상자의 크기를 나타내는 두 정수 M,N과 쌓아올려지는 상자의 수를 나타내는 H가 주어진다. M은 상자의 가로 칸의 수, N은 상자의 세로 칸의 수를 나타낸다. 단, 2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100 이다. 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지에 저장된 토마토들의 정보가 주어진다. 즉, 둘째 줄부터 N개의 줄에는 하나의 상자에 담긴 토마토의 정보가 주어진다. 각 줄에는 상자 가로줄에 들어있는 토마토들의 상태가 M개의 정수로 주어진다. 정수 1은 익은 토마토, 정수 0 은 익지 않은 토마토, 정수 -1은 토마토가 들어있지 않은 칸을 나타낸다. 이러한 N개의 줄이 H번 반복하여 주어진다.토마토가 하나 이상 있는 경우만 입력으로 주어진다.출력여러분은 토마토가 모두 익을 때까지 최소 며칠이 걸리는지를 계산해서 출력해야 한다. 만약, 저장될 때부터 모든 토마토가 익어있는 상태이면 0을 출력해야 하고, 토마토가 모두 익지는 못하는 상황이면 -1을 출력해야 한다.예제 입출력 1입력5 3 10 -1 0 0 0-1 -1 0 1 10 0 0 1 1출력-1예제 입출력 2입력5 3 20 0 0 0 00 0 0 0 00 0 0 0 00 0 0 0 00 0 1 0 00 0 0 0 0출력4예제 입출력 3입력4 3 21 1 1 11 1 1 11 1 1 11 1 1 1-1 -1 -1 -11 1 1 -1출력0코드(파이썬)import sysfrom collections import dequedef bfs(start):    queue = deque(start)    cnt = 0        while True:        for _ in range(len(queue)):            s_h, s_r, s_c = queue.popleft()                        for next_h, next_r, next_c in [(d_h+s_h, d_r+s_r, d_c+s_c) for d_h, d_r, d_c in directions]:                if 0 &lt;= next_h &lt;= h and 0 &lt;= next_r &lt; n and 0 &lt;= next_c &lt; m and\\                   containers[next_h][next_r][next_c] == 0:                    containers[next_h][next_r][next_c] = 1                    queue.append((next_h, next_r, next_c))                            if queue:            cnt += 1        else:            break                return cntdirections = [(1, 0, 0), (-1, 0, 0), (0, 1, 0), (0, -1, 0), (0, 0, 1), (0, 0, -1)]start = list()m, n, h = map(int, sys.stdin.readline().split())containers = [[list(map(int, sys.stdin.readline().split())) for _ in range(n)] for _ in range(h)]if False in [all(0 not in line for line in floor) for floor in containers]:    for h in range(h):        for r in range(n):            for c in range(m):                if containers[h][r][c] == 1:                    start.append((h, r, c))        days = bfs(start)    if True in [any(0 in line for line in floor) for floor in containers]:        days = -1else:    days = 0print(days)특이사항  3차원에서의 BFS를 사용한 문제          토마토 상태를 3차원 리스트에 저장      bfs 함수 내에서 큐 이용해 BFS 실행      처음 시작 토마토를 찾기 위해 3중 for문 사용      BFS 부분이 아니라 안 익은 토마토 확인 부분에서 시간 초과 발생 -&gt; all, any 함수 사용해 해결        내 코드(47,716KB, 2,972ms)에 비해 우수한 코드(바로가기, 56,680KB, 1,900ms)와 비교                  import sysinput = sys.stdin.readlinem, n, h = map(int, input().split())db = []load = []cnt = 0res = -1for i in range(h):    db.append([])    for j in range(n):        tmp = list(map(int, input().strip().split()))        db[i].append(tmp)        for k in range(m):            if tmp[k] == 1:                load.append((i, j, k))            elif tmp[k] == 0:                cnt += 1while load:    res += 1    tmp = []    for i, j, k in load:        if i &gt; 0 and db[i - 1][j][k] == 0:            db[i - 1][j][k] = 1            tmp.append((i - 1, j, k))        if j &gt; 0 and db[i][j - 1][k] == 0:            db[i][j - 1][k] = 1            tmp.append((i, j - 1, k))        if k &gt; 0 and db[i][j][k - 1] == 0:            db[i][j][k - 1] = 1            tmp.append((i, j, k - 1))        if i &lt; h - 1 and db[i + 1][j][k] == 0:            db[i + 1][j][k] = 1            tmp.append((i + 1, j, k))        if j &lt; n - 1 and db[i][j + 1][k] == 0:            db[i][j + 1][k] = 1            tmp.append((i, j + 1, k))        if k &lt; m - 1 and db[i][j][k + 1] == 0:            db[i][j][k + 1] = 1            tmp.append((i, j, k + 1))    cnt -= len(tmp)    load = tmpprint(-1 if cnt else res)                    토마토 창고 초기화 및 시작 토마토 지정                  기존: 초기화 및 시작 토마토 지정 분리          개선: 반복문 하나로 수행                    참고문헌  “내장함수”, Python 3.10.2 문서, https://docs.python.org/ko/3/library/functions.html  붕어사랑, “파이썬 any, all 활용하기”, 붕어사랑 티스토리, https://lucky516.tistory.com/25"
  },
  
  {
    "title": "백준 12865번 평범한 배낭",
    "url": "/posts/0014_boj_12865/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 다이나믹 프로그래밍(dynamic_programming), 배낭문제(knapsack_problem)",
    "date": "2022-01-28 17:28:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #배낭문제조건            시간 제한      메모리 제한                  2 초      512 MB      문제이 문제는 아주 평범한 배낭에 관한 문제이다.한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #다이나믹 프로그래밍 #배낭문제조건            시간 제한      메모리 제한                  2 초      512 MB      문제이 문제는 아주 평범한 배낭에 관한 문제이다.한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.입력첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.입력으로 주어지는 모든 수는 정수이다.출력한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.예제 입출력 1입력4 76 134 83 65 12출력14코드(파이썬)import sysn, k = map(int, sys.stdin.readline().split())items = sorted([tuple(map(int, line.split())) for line in sys.stdin.readlines()])memo = [[0 for _ in range(k+1)] for _ in range(n+1)]for item in range(n):    for w in range(1, k+1):        if items[item][0] &lt;= w:            memo[item+1][w] = max(memo[item][w-items[item][0]] + items[item][1], memo[item][w])        else:            memo[item+1][w] = memo[item][w]    print(memo[-1][-1])특이사항  DP를 사용한 문제          DP로 접근 시도      4일간 점화식 작성에 실패해서 관련 자료 참고        내 코드(416,216KB, 7,192ms)에 비해 우수한 코드(바로가기, 32,664KB, 1,328ms)와 비교                  # ver 3: dp by listN, K = map(int, input().split())stuffs = [tuple(map(int, input().split())) for _ in range(N)]stuffs.sort()dp = [0] * (K+1)dp[0] = 1for w, v in stuffs:    for i in range(K-w, -1, -1):        if dp[i]:            dp[i+w] = max(dp[i+w], dp[i]+v)print(max(dp)-1)                    자료구조                  기존: 2차원 리스트          개선: 1차원 리스트                    DP                  기존: 각 아이템 별 0 ~ 최대 무게까지의 모든 가치 계산          개선: 각 아이템 별 가치 계산                    참고문헌  huttzza, “[알고리즘] 0-1 Knapsack Problem”, 일어나자 흣쨔!, https://velog.io/@huttzza/알고리즘-0-1-Knapsack-Problem  메시에, “Dynamic Programming: 배낭 채우기 문제 (Knapsack Problem)”, 환상빛 별하늘: Reb∞t, https://gsmesie692.tistory.com/113"
  },
  
  {
    "title": "백준 11047번 동전 0",
    "url": "/posts/0013_boj_11047/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그리디 알고리즘(greedy_algorithm)",
    "date": "2022-01-27 17:19:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그리디알고리즘조건            시간 제한      메모리 제한                  1 초      256 MB      문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그리디알고리즘조건            시간 제한      메모리 제한                  1 초      256 MB      문제준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.입력첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)둘째 줄부터 N개의 줄에 동전의 가치 Ai가 오름차순으로 주어진다. (1 ≤ Ai ≤ 1,000,000, A1 = 1, i ≥ 2인 경우에 Ai는 Ai-1의 배수)출력첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.예제 입출력 1입력10 4200151050100500100050001000050000출력6예제 입출력 2입력10 4790151050100500100050001000050000출력12코드(파이썬)n, k = map(int, input().split())coins = list()coin_cnt = 0for _ in range(n):    coins.append(int(input()))for coin in coins[::-1]:    coin_cnt += k // coin    k %= coin    print(coin_cnt)특이사항  그리디 알고리즘 기초 문제참고문헌-"
  },
  
  {
    "title": "백준 1541번 잃어버린 괄호",
    "url": "/posts/0012_boj_1541/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 수학(math), 문자열(string), 그리디 알고리즘(greedy_algorithm), 파싱(parsing)",
    "date": "2022-01-26 15:18:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #수학 #문자열 #그리디알고리즘 #파싱조건            시간 제한      메모리 제한                  2 초      128 MB      문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #수학 #문자열 #그리디알고리즘 #파싱조건            시간 제한      메모리 제한                  2 초      128 MB      문제세준이는 양수와 +, -, 그리고 괄호를 가지고 식을 만들었다. 그리고 나서 세준이는 괄호를 모두 지웠다.그리고 나서 세준이는 괄호를 적절히 쳐서 이 식의 값을 최소로 만들려고 한다.괄호를 적절히 쳐서 이 식의 값을 최소로 만드는 프로그램을 작성하시오.입력첫째 줄에 식이 주어진다. 식은 ‘0’~‘9’, ‘+’, 그리고 ‘-’만으로 이루어져 있고, 가장 처음과 마지막 문자는 숫자이다. 그리고 연속해서 두 개 이상의 연산자가 나타나지 않고, 5자리보다 많이 연속되는 숫자는 없다. 수는 0으로 시작할 수 있다. 입력으로 주어지는 식의 길이는 50보다 작거나 같다.출력첫째 줄에 정답을 출력한다.예제 입출력 1입력55-50+40출력-35예제 입출력 2입력10+20+30+40출력100예제 입출력 3입력00009-00009출력0코드(파이썬)line = input().split('-')mid_sum = []for each in line:    tmp_num = ''    tmp_sum = 0        for ch in each:        if ch == '+':            tmp_sum += int(tmp_num)            tmp_num = ''        else:            tmp_num += ch    tmp_sum += int(tmp_num)        mid_sum.append(tmp_sum)result = mid_sum[0] - (sum(mid_sum[1:]) if len(mid_sum) &gt; 1 else 0)print(result)특이사항  미리 합을 계산하고, 그 값을 이용하는 방식 사용  내 코드(88,516KB, 420ms)에 비해 우수한 코드(바로가기, 33,800KB, 92ms)와 비교                  import syss = sys.stdin.readline().split('-')for i in s:    tmp = sum(list(map(int,i.split('+'))))    try:        res -= tmp    except:        res = tmpprint(res)                        ”-“를 기준으로 나누고, 나머지를 더한다는 과정 동일      문자열 파싱                  기존: tmp_num 이용해 각각          개선: map 이용해 한 번에                    참고문헌-"
  },
  
  {
    "title": "백준 11659번 구간 합 구하기 4",
    "url": "/posts/0011_boj_11659/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 누적합(prefix_sum)",
    "date": "2022-01-25 21:55:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #누적합조건            시간 제한      메모리 제한                  1 초      256 MB      문제수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.입력첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #누적합조건            시간 제한      메모리 제한                  1 초      256 MB      문제수 N개가 주어졌을 때, i번째 수부터 j번째 수까지 합을 구하는 프로그램을 작성하시오.입력첫째 줄에 수의 개수 N과 합을 구해야 하는 횟수 M이 주어진다. 둘째 줄에는 N개의 수가 주어진다. 수는 1,000보다 작거나 같은 자연수이다. 셋째 줄부터 M개의 줄에는 합을 구해야 하는 구간 i와 j가 주어진다.출력총 M개의 줄에 입력으로 주어진 i번째 수부터 j번째 수까지 합을 출력한다.제한  1 ≤ N ≤ 100,000  1 ≤ M ≤ 100,000  1 ≤ i ≤ j ≤ N예제 입출력 1입력5 35 4 3 2 11 32 45 5출력1291코드(파이썬)import sysn, m = map(int, sys.stdin.readline().split())nums = tuple(map(int, sys.stdin.readline().split()))nums_sum = [nums[-1]]for i in range(n-2, -1, -1):    nums_sum.append(nums_sum[n - i - 2] + nums[i])nums_sum = nums_sum[::-1]for s, e in [map(int, line.split()) for line in sys.stdin.readlines()]:    if e == n:        print(nums_sum[s-1])    else:        print(nums_sum[s-1] - nums_sum[e])특이사항  미리 합을 계산하고, 그 값을 이용하는 방식 사용  내 코드(88,516KB, 420ms)에 비해 우수한 코드(바로가기, 33,800KB, 92ms)와 비교                  import sysn, m =map(int,input().split())s = list(map(int, input().split()))ss =[0]for i in s:    ss.append(ss[-1]+i)for i in range(m):    a, b =map(int, sys.stdin.readline().split())    print(ss[b]-ss[a-1])                    동일한 개념      자료구조                  기존: 2개의 리스트          개선: 1개의 리스트                    합 계산                  기존: 2가지 경우로 나눠 계산          개선: 조건문 없이 바로 계산                    참고문헌  kim.svadoz, “개념-52-Prefix-Sum누적-합-구간-합”, programmer life guidance 101, https://coder-in-war.tistory.com/entry/개념-52-Prefix-Sum누적-합-구간-합  코딩무식자 전공생, “누적합(prefix sum)”, 코딩무식자 전공생, https://jow1025.tistory.com/47"
  },
  
  {
    "title": "백준 1992번 쿼드트리",
    "url": "/posts/0010_boj_1992/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 분할정복(divide_and_conquer), 재귀(recursion)",
    "date": "2022-01-24 21:02:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #분할정복 #재귀조건            시간 제한      메모리 제한                  2 초      128 MB      문제흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #분할정복 #재귀조건            시간 제한      메모리 제한                  2 초      128 MB      문제흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 “0”이 되고, 모두 1로만 되어 있으면 압축 결과는 “1”이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 “(0(0011)(0(0111)01)1)”로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.입력첫째 줄에는 영상의 크기를 나타내는 숫자 N 이 주어진다. N 은 언제나 2의 제곱수로 주어지며, 1 ≤ N ≤ 64의 범위를 가진다. 두 번째 줄부터는 길이 N의 문자열이 N개 들어온다. 각 문자열은 0 또는 1의 숫자로 이루어져 있으며, 영상의 각 점들을 나타낸다.출력영상을 압축한 결과를 출력한다.예제 입출력 1입력81111000011110000000111000001110011110000111100001111001111110011출력((110(0101))(0010)1(0001))코드(파이썬)import sysdef compress(now_loc, size):    quadrants = [(0, 0), (0, 1), (1, 0), (1, 1)]    result = ''        # 구역이 1개의 숫자로만 이루어진 경우    if len(set(sum([line[now_loc[1]:now_loc[1]+size] for line in video[now_loc[0]:now_loc[0]+size]], list()))) == 1:        result = video[now_loc[0]][now_loc[1]]    # 구역을 더 나눌 수 없는 경우    elif size == 2:        result =  '(' + ''.join([video[now_loc[0]+q[0]][now_loc[1]+q[1]] for q in quadrants]) + ')'    else:        for next_loc in [(now_loc[0] + size // 2 * q_x, now_loc[1] + size // 2 * q_y) for q_x, q_y in quadrants]:            result += compress(next_loc, size // 2)        result = '(' + result + ')'        return result    n = int(sys.stdin.readline())video = [list(line.rstrip('\\n')) for line in sys.stdin.readlines()]print(compress((0, 0), n))특이사항  분할정복을 활용했으나, 코드 정리가 이루어지지 않음참고문헌-"
  },
  
  {
    "title": "백준 1018번 체스판 다시 칠하기",
    "url": "/posts/0009_boj_1018/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 브루트포스(bruteforce)",
    "date": "2022-01-21 17:12:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #브루트포스조건            시간 제한      메모리 제한                  2 초      128 MB      문제지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver3관련 개념: #브루트포스조건            시간 제한      메모리 제한                  2 초      128 MB      문제지민이는 자신의 저택에서 MN개의 단위 정사각형으로 나누어져 있는 M*N 크기의 보드를 찾았다. 어떤 정사각형은 검은색으로 칠해져 있고, 나머지는 흰색으로 칠해져 있다. 지민이는 이 보드를 잘라서 8*8 크기의 체스판으로 만들려고 한다.체스판은 검은색과 흰색이 번갈아서 칠해져 있어야 한다. 구체적으로, 각 칸이 검은색과 흰색 중 하나로 색칠되어 있고, 변을 공유하는 두 개의 사각형은 다른 색으로 칠해져 있어야 한다. 따라서 이 정의를 따르면 체스판을 색칠하는 경우는 두 가지뿐이다. 하나는 맨 왼쪽 위 칸이 흰색인 경우, 하나는 검은색인 경우이다.보드가 체스판처럼 칠해져 있다는 보장이 없어서, 지민이는 8*8 크기의 체스판으로 잘라낸 후에 몇 개의 정사각형을 다시 칠해야겠다고 생각했다. 당연히 8*8 크기는 아무데서나 골라도 된다. 지민이가 다시 칠해야 하는 정사각형의 최소 개수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N과 M이 주어진다. N과 M은 8보다 크거나 같고, 50보다 작거나 같은 자연수이다. 둘째 줄부터 N개의 줄에는 보드의 각 행의 상태가 주어진다. B는 검은색이며, W는 흰색이다.출력첫째 줄에 지민이가 다시 칠해야 하는 정사각형 개수의 최솟값을 출력한다.예제 입출력 1입력8 8WBWBWBWBBWBWBWBWWBWBWBWBBWBBBWBWWBWBWBWBBWBWBWBWWBWBWBWBBWBWBWBW출력1예제 입출력 2입력10 13BBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBBBBBBBBBWBWBWBBBBBBBBBWBWBWWWWWWWWWWBWBWWWWWWWWWWBWB출력12코드(자바)import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStreamReader;import java.io.OutputStreamWriter;class Main{    public static void main(String[] args){        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));        // 처음 칸이 까만색, 흰색인 체스판을 나타내며 까만색(B)는 1, 흰색(W)은 0으로 표시        int black_first = 1;        int white_first = 0;        // 처음이 검은색, 흰색인 체스판을 만들기 위해 칠해야하는 개수        int black_count = 0;        int white_count = 0;        // 최종 개수        int total_count = 64;        int height, width;        String tmp_input;        String[] tmp;        int[][] input_array;        int now = 0;        try {            tmp = reader.readLine().split(\" \");            height = Integer.parseInt(tmp[0]);            width = Integer.parseInt(tmp[1]);            input_array = new int[height][width];            // B, W로 이루어진 입력 데이터를 1, 0으로 변환            for(int i = 0; i &lt; height; i++){                tmp_input = reader.readLine();                for(int j = 0; j &lt; width; j++){                    if(tmp_input.charAt(j) == 'B')                        input_array[i][j] = 1;                    else                        input_array[i][j] = 0;                }            }            // 확인할 8x8범위의 첫 번째 칸 지정            for(int y = 0; y &lt; height - 7; y++){                for(int x = 0; x &lt; width - 7; x++){                    black_count = 0;                    white_count = 0;                    // 확인할 8x8범위의 칸들                    for(int y2 = 0; y2 &lt; 8; y2++){                        for(int x2 = 0; x2 &lt; 8; x2++){                            now = input_array[y+y2][x+x2];                            // 현재 칸과 체스판의 해당 위치가 다르다면                            // 다시 칠해야하는 개수에 1을 더함                            if(black_first != now)                                black_count++;                            if(white_first != now)                                white_count++;                            // 체스판의 다음 칸으로 이동(색 변경)                            black_first = black_first ^ 1;                            white_first = white_first ^ 1;                        }                        // 체스판에서 다음 줄로 넘어가는 경우                        // 색이 유지되므로 다시 변경해서 색 유지                        black_first = black_first ^ 1;                        white_first = white_first ^ 1;                    }                    total_count = Math.min(total_count, Math.min(black_count, white_count));                }            }            writer.write(total_count + \"\\n\");            writer.flush();            writer.close();        }catch (Exception e){            e.printStackTrace();        }    }}코드(파이썬)import sys# 검은색(B)는 1, 흰색(W)는 0# 처음이 검은색, 흰색인 체스판 확인black_first, white_first = 1, 0# 처음이 검은색, 흰색인 체스판을 만들기 위해 칠해야하는 개수black_count, white_count = 0, 0# 현재 칸now = 0total_count = 64input_list = []hei, wid= map(int, sys.stdin.readline().split())for i in range(hei):    input_list.append(list(sys.stdin.readline().rstrip()))# B, W로 이루어진 리스트를 1, 0으로 변환input_list = list(map(lambda li: [1 if x == 'B' else 0 for x in li], input_list))for y in range(0, hei-7):    for x in range(0, wid-7):        black_count, white_count = 0, 0        for y2 in range(0, 8):            for x2 in range(0, 8):                now = input_list[y+y2][x+x2]                # 처음이 검은색, 흰색인 체스판과 비교해 색이 다르다면                # 칠해야하는 개수에 1을 더함                if black_first ^ now:                    black_count += 1                if white_first ^ now:                    white_count += 1                # 체스판의 다음 칸                black_first = black_first ^ 1                white_first = white_first ^ 1            # 체스판에서 다음 줄로 넘어가는 경우 마지막 색이 유지되어야 하므로 다시 변환            black_first = black_first ^ 1            white_first = white_first ^ 1        # 이전까지 가장 적은 개수와 처음이 각각 검은색과 흰색인 체스판을 만들기 위해        # 칠해야 하는 개수 중 가장 작은 값을 결과값에 저장        total_count = min(black_count, white_count, total_count)sys.stdout.write(str(total_count) + \"\\n\")특이사항크게 2가지 방법을 생각해봤다.  처음이 검은색 또는 흰색인 체스판을 미리 만들어두고 입력받은 데이터의 범위와 비교하는 것  처음이 검은색 또는 흰색인 체스판을 따로 만들지 않고 각 칸을 옮기면서 입력받은 데이터의 범위와 비교하는 것여기서는 후자의 방법을 택했는데 전자의 방법을 고려해보는 것도 좋아보인다.참고문헌-"
  },
  
  {
    "title": "백준 10026번 적록색약",
    "url": "/posts/0008_boj_10026/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search), 깊이우선탐색(depth_first_search)",
    "date": "2022-01-21 17:12:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람...",
    "content": "정보문제 바로가기 [클릭]난이도: Gold5관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)예를 들어, 그림이 아래와 같은 경우에RRRBBGGBBBBBBRRBBRRRRRRRR적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.입력첫째 줄에 N이 주어진다. (1 ≤ N ≤ 100)둘째 줄부터 N개 줄에는 그림이 주어진다.출력적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.예제 입출력 1입력5RRRBBGGBBBBBBRRBBRRRRRRRR출력4 3코드(파이썬)import syssys.setrecursionlimit(10**5)def dfs(x, y, color):    d = [(1, 0), (0, -1), (-1, 0), (0, 1)]    visited[color].add((x, y))        for next_x, next_y in [(x+dx, y+dy) for dx, dy in d]:        if 0 &lt;= next_x &lt; n and 0 &lt;= next_y &lt; n and\\           (next_x, next_y) not in visited[color] and img[next_x][next_y] in color:            stack.append((next_x, next_y))            dfs(next_x, next_y, color)            stack.pop()                return resultvisited = dict(zip([\"RG\", \"R\", \"G\", \"B\"], [set(), set(), set(), set()]))result = dict(zip([\"RG\", \"R\", \"G\", \"B\"], [0, 0, 0, 0]))n = int(sys.stdin.readline())img = [list(line.rstrip('\\n')) for line in sys.stdin.readlines()]for i in range(n):    for j in range(n):        for color in result:            if img[i][j] in color and (i, j) not in visited[color]:                stack = list()                dfs(i, j, color)                result[color] += 1                print(result[\"R\"]+result[\"G\"]+result[\"B\"], result[\"RG\"]+result[\"B\"])특이사항  풀이 대부분이 DFS  내 코드(36,020KB, 116ms)에 비해 우수한 코드(바로가기, 33,800KB, 92ms)와 비교                  import syssys.setrecursionlimit(10**6)input = sys.stdin.readlinedef dfs(cur_x, cur_y, color):    global visit, cnt, graph, dir, color_dic    for x, y in dir:        nx = cur_x + x        ny = cur_y + y        if 0 &lt;= nx &lt; n and 0 &lt;= ny &lt; n and not visit[nx][ny] and color_dic[graph[nx][ny]] == color_dic[color]:            visit[nx][ny] = True            dfs(nx, ny, color)n = int(input())dir = [(1, 0), (0, 1), (-1, 0), (0, -1)]graph = [input().strip() for _ in range(n)]flag = 0for i in range(2):    color_dic = {        'R': 1,        'G': 2,        'B': 3,    }    cnt = 0    visit = [[False for __ in range(n)] for _ in range(n)]    if i == 1:        color_dic = {            'R': 1,            'G': 1,            'B': 3,        }    for j in range(n):        for k in range(n):            if not visit[j][k]:                cnt += 1                dfs(j, k, graph[j][k])    print(cnt)                    방문여부                  기존: visited로 4개 set으로 이루어진 dictionary 사용          개선: 1개 사용                    DFS 구성                  기존: 각 위치마다 4가지 경우 모두 탐색          개선: 각 위치의 색에 따라 탐색 진행                    참고문헌-"
  },
  
  {
    "title": "백준 1012번 유기농 배추",
    "url": "/posts/0007_boj_1012/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search), 깊이우선탐색(depth_first_search)",
    "date": "2022-01-20 16:05:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      512 MB      문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver2관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      512 MB      문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.                                                                                    1      1      0      0      0      0      0      0      0      0              0      1      0      0      0      0      0      0      0      0              0      0      0      0      1      0      0      0      0      0              0      0      0      0      1      0      0      0      0      0              0      0      1      1      0      0      0      1      1      1              0      0      0      0      1      0      0      1      1      1      입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 두 배추의 위치가 같은 경우는 없다.출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.예제 입출력 1입력210 8 170 01 01 14 24 34 52 43 47 48 49 47 58 59 57 68 69 610 10 15 5출력51예제 입출력 2입력15 3 60 21 22 23 24 24 0출력2코드(파이썬)import sysdef bfs(cabbage_now):    moves = [(0, 1), (0, -1), (1, 0), (-1, 0)]    next_ = list()        for cabbage in cabbage_now:        for move in moves:            tmp = (cabbage[0]+move[0], cabbage[1]+move[1])            if tmp in cabbages:                next_.append(tmp)                cabbages.remove(tmp)                return next_    cabbages = list()M, N, K = 0, 0, 0cnt = 0for _ in range(int(sys.stdin.readline())):    M, N, K = tuple(map(int, sys.stdin.readline().split()))    cabbages = [tuple(map(int, sys.stdin.readline().split())) for _ in range(K)]    cnt = 0            while cabbages:        next_ = [cabbages.pop()]                while next_:            next_ = bfs(next_)                cnt += 1    print(cnt)특이사항  풀이 대부분이 DFS  내 코드(29,452KB, 588ms)에 비해 우수한 코드(바로가기, 29,200KB, 68ms)와 비교                  import sys;input=sys.stdin.readlinesys.setrecursionlimit(10**7)def is_valid_coord(y,x):    return 0&lt;=y&lt;Y and 0&lt;=x&lt;Xdef dfs(y,x):    visited[y][x] = True    for k in range(4):        ny = y + dy[k]        nx = x + dx[k]        if is_valid_coord(ny,nx) and board[ny][nx] and not visited[ny][nx]:            dfs(ny,nx)dy = (1,0,-1,0)dx = (0,1,0,-1)for _ in range(int(input())):    global X,Y    X,Y,K = map(int, input().split())    board = [[0]*X for _ in range(Y)]    for _ in range(K):        j,i = map(int,input().split())        board[i][j] = 1            visited = [[False]*X for _ in range(Y)]    worms = 0    for y in range(Y):        for x in range(X):            if board[y][x] and not visited[y][x]:                worms += 1                dfs(y,x)    print(worms)                    구현방식                  기존: BFS          개선: DFS                    방문여부                  기존: 확인 X          개선: visited 리스트를 사용해 방문여부 저장                    참고문헌-"
  },
  
  {
    "title": "백준 1389번 케빈 베이컨의 6단계 법칙",
    "url": "/posts/0006_boj_1389/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 너비우선탐색(breadth_first_search), 플로이드-워셜 알고리즘(floyd_warshall_algorithm)",
    "date": "2022-01-20 14:59:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #플로이드-워셜조건            시간 제한      메모리 제한                  2 초      128 MB      문제케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #플로이드-워셜조건            시간 제한      메모리 제한                  2 초      128 MB      문제케빈 베이컨의 6단계 법칙에 의하면 지구에 있는 모든 사람들은 최대 6단계 이내에서 서로 아는 사람으로 연결될 수 있다. 케빈 베이컨 게임은 임의의 두 사람이 최소 몇 단계 만에 이어질 수 있는지 계산하는 게임이다.예를 들면, 전혀 상관없을 것 같은 인하대학교의 이강호와 서강대학교의 민세희는 몇 단계만에 이어질 수 있을까?천민호는 이강호와 같은 학교에 다니는 사이이다. 천민호와 최백준은 Baekjoon Online Judge를 통해 알게 되었다. 최백준과 김선영은 같이 Startlink를 창업했다. 김선영과 김도현은 같은 학교 동아리 소속이다. 김도현과 민세희는 같은 학교에 다니는 사이로 서로 알고 있다. 즉, 이강호-천민호-최백준-김선영-김도현-민세희 와 같이 5단계만 거치면 된다.케빈 베이컨은 미국 헐리우드 영화배우들 끼리 케빈 베이컨 게임을 했을때 나오는 단계의 총 합이 가장 적은 사람이라고 한다.오늘은 Baekjoon Online Judge의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 찾으려고 한다. 케빈 베이컨 수는 모든 사람과 케빈 베이컨 게임을 했을 때, 나오는 단계의 합이다.예를 들어, BOJ의 유저가 5명이고, 1과 3, 1과 4, 2와 3, 3과 4, 4와 5가 친구인 경우를 생각해보자.1은 2까지 3을 통해 2단계 만에, 3까지 1단계, 4까지 1단계, 5까지 4를 통해서 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+1+2 = 6이다.2는 1까지 3을 통해서 2단계 만에, 3까지 1단계 만에, 4까지 3을 통해서 2단계 만에, 5까지 3과 4를 통해서 3단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 2+1+2+3 = 8이다.3은 1까지 1단계, 2까지 1단계, 4까지 1단계, 5까지 4를 통해 2단계 만에 알 수 있다. 따라서, 케빈 베이컨의 수는 1+1+1+2 = 5이다.4는 1까지 1단계, 2까지 3을 통해 2단계, 3까지 1단계, 5까지 1단계 만에 알 수 있다. 4의 케빈 베이컨의 수는 1+2+1+1 = 5가 된다.마지막으로 5는 1까지 4를 통해 2단계, 2까지 4와 3을 통해 3단계, 3까지 4를 통해 2단계, 4까지 1단계 만에 알 수 있다. 5의 케빈 베이컨의 수는 2+3+2+1 = 8이다.5명의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람은 3과 4이다.BOJ 유저의 수와 친구 관계가 입력으로 주어졌을 때, 케빈 베이컨의 수가 가장 작은 사람을 구하는 프로그램을 작성하시오.입력첫째 줄에 유저의 수 N (2 ≤ N ≤ 100)과 친구 관계의 수 M (1 ≤ M ≤ 5,000)이 주어진다. 둘째 줄부터 M개의 줄에는 친구 관계가 주어진다. 친구 관계는 A와 B로 이루어져 있으며, A와 B가 친구라는 뜻이다. A와 B가 친구이면, B와 A도 친구이며, A와 B가 같은 경우는 없다. 친구 관계는 중복되어 들어올 수도 있으며, 친구가 한 명도 없는 사람은 없다. 또, 모든 사람은 친구 관계로 연결되어져 있다. 사람의 번호는 1부터 N까지이며, 두 사람이 같은 번호를 갖는 경우는 없다.출력첫째 줄에 BOJ의 유저 중에서 케빈 베이컨의 수가 가장 작은 사람을 출력한다. 그런 사람이 여러 명일 경우에는 번호가 가장 작은 사람을 출력한다.예제 입출력 1입력5 51 31 44 54 33 2출력3코드(파이썬)import sysn, m = map(int, sys.stdin.readline().split())kevin = [[0 for _ in range(n)] for _ in range(n)]for i in range(n):    kevin[i][i] = -1for f1, f2 in [map(int, line.split()) for line in sys.stdin.readlines()]:    kevin[f1-1][f2-1] = 1    kevin[f2-1][f1-1] = 1# (3)┌  C  ┐(2)#    A  ─  B#      (1)  for now_friend in range(n):    # A(now_friend)와 연결된 B(next_friend) 확인    for next_friend, cnt in enumerate(kevin[now_friend]):        if cnt &gt; 0:        # B(next_friend)와 연결된 C(between_friend) 확인            for between_friend in [i for i in range(n) if kevin[next_friend][i] &gt; 0]:                # 다음 상황에서 (3)의 값 업데이트                # kevin[now_friend][between_friend] == 0                                        =&gt; A에서 C로 가는 간선(3) 없음                # kevin[now_friend][between_friend] &gt; kevin[next_friend][between_friend] + cnt  =&gt; A에서 C로 가는 간선(3) 길이 &gt; A에서 B를 거쳐 C로 가는 간선(1 + 2) 길이                if kevin[now_friend][between_friend] == 0 or kevin[now_friend][between_friend] &gt; kevin[next_friend][between_friend] + cnt:                    kevin[now_friend][between_friend] = kevin[next_friend][between_friend] + cnt                    kevin[between_friend][now_friend] = kevin[next_friend][between_friend] + cnt        print(sorted([(i, sum(l)) for i, l in enumerate(kevin)], key=lambda x:(x[1], x[0]))[0][0] + 1)특이사항  기억 속에 남아있는 플로이드-워셜 알고리즘을 최대한 구현해보려 노력함  내 코드(30,860KB, 96ms)에 비해 우수한 코드 (바로가기, 30,864KB, 72ms)와 비교                  def bfs(x):total = 0queue = [x]while queue:    x = queue[0]    del queue[0]    for i in list(graph[x]):        if not visited[i]:            visited[i] = visited[x] + 1            total += visited[i]            queue.append(i)return total                    n, m = map(int, input().split())graph = list(set() for _ in range(n + 1))for _ in range(m):    temp = list(map(int, input().split()))    graph[temp[0]].add(temp[1])    graph[temp[1]].add(temp[0])min = 5000 * 100min_index = 0for i in range(1, n + 1):    visited = [0 for _ in range(n + 1)]    result = bfs(i)    if result &lt; min:        min = result        min_index = iprint(min_index)                    구현 방식                  기존: 플로이드-워셜 사용 노력          개선: BFS                      플로이드-워셜 알고리즘에 대해 정확한 파악이 필요함참고문헌  “플로이드-워셜 알고리즘”, 위키백과, https://ko.wikipedia.org/wiki/플로이드-워셜_알고리즘  안경잡이개발자, “24 플로이드 와샬(Floyd Warshall) 알고리즘”, 안경잡이개발자, https://blog.naver.com/ndb796/221234427842"
  },
  
  {
    "title": "백준 2667번 단지번호붙이기",
    "url": "/posts/0005_boj_2667/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-01-19 15:58:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  1 초      128 MB      문제&lt;그림 1&gt;과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. &lt;그림 2&gt;는 &lt;그림 1&gt;을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.입력첫 번째 줄에는 지도의 크기 N(정사각형이므로 가로와 세로의 크기는 같으며 5≤N≤25)이 입력되고, 그 다음 N줄에는 각각 N개의 자료(0혹은 1)가 입력된다.출력첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.예제 입출력 1입력70110100011010111101010000111010000001111100111000출력3789코드(파이썬)def dfs(s):    global cnt         directions = [(1, 0), (0, 1), (-1, 0), (0, -1)]    cnt += 1    visited.add(s)        for end in [(s[0]+d[0], s[1]+d[1]) for d in directions]:        if -1 &lt; end[0] &lt; n and -1 &lt; end[1] &lt; n and map_[end[0]][end[1]] and\\           end not in stack and end not in visited:            stack.append(end)            dfs(end)            stack.pop()    map_ = list()cnts = list()visited = set()group = 0n = int(input())map_ = [[int(ch) for ch in input()] for _ in range(n)]    for loc in sum([[(i, j) for j in range(n)] for i in range(n)], []):    if map_[loc[0]][loc[1]] and loc not in visited:        stack = list()        cnt = 0        group += 1                dfs(loc)                cnts.append(cnt)        print(group, *sorted(cnts), sep=\"\\n\")특이사항  DFS 사용해 탐색 진행  내 코드(31,108KB, 88ms)에 비해 우수한 코드 (바로가기, 30,864KB, 68ms)와 비교                  n = int(input())graph = []for i in range(n) :    graph.append(list(map(int, input())))        def dfs(x,y) :    global house    if x &lt;= -1 or x &gt;=n or y &lt;= -1 or y &gt;= n :        return False    global num    if graph[x][y] == 1 :        house += 1        graph[x][y] = 0        dfs(x-1, y)        dfs(x,y-1)        dfs(x+1, y)        dfs(x, y+1)        return True    return Falsecount = 0danji = []house = 0for i in range(n) :    for j in range(n) :        if dfs(i,j) == True :            count += 1            danji.append(house)            house = 0            print(count)danji.sort()for k in danji :    print(k)                    DFS 방식은 동일하나, 역시 구조의 차이      DFS의 이론 공부 필요      참고문헌-"
  },
  
  {
    "title": "백준 2178번 미로탐색",
    "url": "/posts/0004_boj_2178/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-01-18 11:02:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      192 MB      문제N×M크기의 배열로 표현되는 미로가 있다.            1        0        1        1    ...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색조건            시간 제한      메모리 제한                  1 초      192 MB      문제N×M크기의 배열로 표현되는 미로가 있다.            1        0        1        1        1        1                1        0        1        0        1        0                1        0        1        0        1        1                1        1        1        0        1        1    미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.입력첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.출력첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.예제 입출력 1입력4 6101111101010101011111011출력15예제 입출력 2입력4 6110110110110111111111101출력9예제 입출력 3입력2 2510111011101110111011101111110111011101110111011101출력38예제 입출력 4입력7 71011111111000110000011000001100000110000011111111출력13코드(파이썬)import sysdef bfs(start):    cnt = 1    queue = [start]    visited = set()    direction = [(1, 0), (-1, 0), (0, 1), (0, -1)]        while (n-1, m-1) not in queue:        cnt += 1                for _ in range(len(queue)):            s = queue.pop(0)            for d in direction:                e = (s[0]+d[0], s[1]+d[1])                                if e[0] &gt; -1 and e[0] &lt; n and\\                   e[1] &gt; -1 and e[1] &lt; m and\\                   maze[e[0]][e[1]] and e not in visited:                    visited.add(e)                    queue.append(e)            return cnt        n, m = map(int, sys.stdin.readline().split())maze = [tuple(map(int, list(l.rstrip(\"\\n\")))) for l in sys.stdin.readlines()]print(bfs((0, 0)))특이사항  DFS와 BFS를 동시에 사용  내 코드(31,376KB, 88ms)에 비해 우수한 코드 (바로가기, 30,864KB, 88ms)와 비교                  import sysn, m = map(int, sys.stdin.readline().split())arr = [list(map(int, sys.stdin.readline().rstrip())) for _ in range(n)]dx = [1, -1, 0, 0]dy = [0, 0, -1, 1]queue = [[0, 0]]while queue:    a, b = queue[0][0], queue[0][1]    del queue[0]    for i in range(4):        x = a + dx[i]        y = b + dy[i]        if 0 &lt;= x &lt; n and 0 &lt;= y &lt; m and arr[x][y] == 1:            queue.append([x, y])            arr[x][y] = arr[a][b] + 1print(arr[n - 1][m - 1])                    방문 여부                  기존: visited set으로 방문 여부 확인          개선: queue 하나로 해결                    maze, arr 배열(입력 배열)                  기존: maze에 수정 없음          개선: 각 위치까지의 최단 경로                    참고문헌-"
  },
  
  {
    "title": "백준 1260번 DFS와 BFS",
    "url": "/posts/0003_boj_1260/",
    "categories": "Problem_Solve, boj",
    "tags": "문제풀이(problem_solve), 백준(boj), 그래프이론(graph), 그래프탐색(graph_search), 깊이우선탐색(depth_first_search), 너비우선탐색(breadth_first_search)",
    "date": "2022-01-17 20:36:00 +0900",
    





    
    "snippet": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수...",
    "content": "정보문제 바로가기 [클릭]난이도: Silver1관련 개념: #그래프 이론 #그래프 탐색 #너비 우선 탐색 #깊이 우선 탐색조건            시간 제한      메모리 제한                  2 초      128 MB      문제그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.입력첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다.출력첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.예제 입출력 1입력4 5 11 21 31 42 43 4출력1 2 4 31 2 3 4예제 입출력 2입력5 5 35 45 21 23 43 1출력3 1 2 5 43 1 4 2 5예제 입출력 3입력1000 1 1000999 1000출력1000 9991000 999코드(파이썬)import syssys.setrecursionlimit(10001)def dfs(num):    dfs_result.append(num)    for end in graph[num]:        if end in graph[num] and end not in dfs_result:            check_dfs.append(end)            dfs(end)            check_dfs.pop()            def bfs(num):    queue = [num]        while queue:        bfs_result.extend(queue)                for _ in range(len(queue)):            start = queue.pop(0)                        for end in graph[start]:                if end not in bfs_result and end not in queue:                    queue.append(end)check_dfs = list()queue = list()dfs_result = list()bfs_result = list()n, m, s = map(int, sys.stdin.readline().split())graph = dict(zip(range(1, n+1), [list() for _ in range(n)]))for n1, n2 in [map(int, line.split()) for line in sys.stdin.readlines()]:    graph[n1].append(n2)    graph[n2].append(n1)    for k in graph:    graph[k].sort()    dfs(s)bfs(s)sys.stdout.write(\" \".join(map(str, dfs_result)) + \"\\n\")sys.stdout.write(\" \".join(map(str, bfs_result)))특이사항  DFS와 BFS를 동시에 사용  내 코드(35,376KB, 312ms)에 비해 우수한 코드 (바로가기, 32,428KB, 108ms)와 비교                  import sysfrom collections import dequedef bfs(graph, v, visited):    queue = deque([v])    visited[v] = True    while queue:        v = queue.popleft()        print(v, end = ' ')        for i in graph[v]:            if not visited[i]:                queue.append(i)                visited[i] = Truedef dfs(graph, v, visited):    visited[v] = True    print(v, end = ' ')    for i in graph[v]:        if not visited[i]:            dfs(graph, i, visited)n, m, v = map(int, sys.stdin.readline().split())graph = [[]for i in range(n + 1)]for i in range(m):    # a, b 를 입력 받은 후 그래프에 인접 노드로 넣어줌    a, b = map(int, sys.stdin.readline().split())    graph[a].append(b)    graph[b].append(a)# 탐색을 위해 그래프 정렬해줌for i in range(1, n+1):    graph[i].sort()visited = [False]*(n+1)dfs(graph, v, visited)print()visited = [False]*(n+1)bfs(graph, v, visited)                    기존: 간선이 여러 개인 점으로 인해 if문이 복잡해지는 단점 존재      개선: visited 리스트를 전달하는 방식      참고문헌-"
  },
  
  {
    "title": "문제 풀이 분류",
    "url": "/posts/0002_problem_solve/",
    "categories": "Problem_Solve, description",
    "tags": "문제풀이(problem_solve)",
    "date": "2022-01-17 20:28:00 +0900",
    





    
    "snippet": "백준, 프로그래머스 등 각종 코딩 문제의 풀이를 게시글로 남기고 있습니다.이전에 올렸던 풀이들은 문제풀이 Github에서 옮기고 있습니다. (2/41)작성일: 20.07.16수정일20.07.23 - 안내문 변경21.05.07 - 백준 문제 난이도, 관련 개념 추가21.05.18 - 프로그래머스 문제 추가21.12.22 - 각 문제 페이지 -&gt; 리...",
    "content": "백준, 프로그래머스 등 각종 코딩 문제의 풀이를 게시글로 남기고 있습니다.이전에 올렸던 풀이들은 문제풀이 Github에서 옮기고 있습니다. (2/41)작성일: 20.07.16수정일20.07.23 - 안내문 변경21.05.07 - 백준 문제 난이도, 관련 개념 추가21.05.18 - 프로그래머스 문제 추가21.12.22 - 각 문제 페이지 -&gt; 리스트 페이지 링크 추가21.12.23 - 백준 문제 태그에 링크 추가21.12.31 - 백준 문제 조건 수정, public/img 디렉터리 생성22.01.13 - 백준 문제별 우수코드에 출처 표기"
  },
  
  {
    "title": "게시글 분류",
    "url": "/posts/0001_classify_post/",
    "categories": "Programming, blog",
    "tags": "블로그(blog)",
    "date": "2022-01-17 20:22:00 +0900",
    





    
    "snippet": "2022-01-17 기준 게시글 분류입니다.0xxx: 프로그래밍1xxx: 프로그래밍2xxx: 프로그래밍3xxx: 문제해결4xxx: 예비5xxx: 예비6xxx: 예비7xxx: 예비8xxx: 후기9xxx: 잡담",
    "content": "2022-01-17 기준 게시글 분류입니다.0xxx: 프로그래밍1xxx: 프로그래밍2xxx: 프로그래밍3xxx: 문제해결4xxx: 예비5xxx: 예비6xxx: 예비7xxx: 예비8xxx: 후기9xxx: 잡담"
  },
  
  {
    "title": "첫 포스트",
    "url": "/posts/9001_first_post/",
    "categories": "Life, etc",
    "tags": "기타(etc)",
    "date": "2022-01-14 15:28:00 +0900",
    





    
    "snippet": "첫포스트입니다..ㅎㅎ아직 배울 게 많은 개발자입니다!제 작은 글이 찾아오신 분들께 큰 도움으로 다가갔으면 합니다!모두모두 환영합니다!",
    "content": "첫포스트입니다..ㅎㅎ아직 배울 게 많은 개발자입니다!제 작은 글이 찾아오신 분들께 큰 도움으로 다가갔으면 합니다!모두모두 환영합니다!"
  }
  
]

